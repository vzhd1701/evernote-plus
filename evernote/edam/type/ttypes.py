#
# Autogenerated by Thrift Compiler (0.21.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:enum,type_hints
#

from __future__ import annotations
import typing
from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec
from uuid import UUID
from enum import IntEnum

import sys
import evernote.edam.limits.ttypes

from thrift.transport import TTransport
all_structs = []


class PrivilegeLevel(IntEnum):
    """
    This enumeration defines the possible permission levels for a user.
    Free accounts will have a level of NORMAL and paid Premium accounts
    will have a level of PREMIUM.

    """
    NORMAL = 1
    PREMIUM = 3
    VIP = 5
    MANAGER = 7
    SUPPORT = 8
    ADMIN = 9



class ServiceLevel(IntEnum):
    """
    This enumeration defines the possible tiers of service that a user may have. A
    ServiceLevel of BUSINESS signifies a business-only account, which can never be any
    other ServiceLevel.

    """
    BASIC = 1
    PLUS = 2
    PREMIUM = 3
    BUSINESS = 4



class QueryFormat(IntEnum):
    """
    Every search query is specified as a sequence of characters.
    Currently, only the USER query format is supported.

    """
    USER = 1
    SEXP = 2



class NoteSortOrder(IntEnum):
    """
    This enumeration defines the possible sort ordering for notes when
    they are returned from a search result.

    """
    CREATED = 1
    UPDATED = 2
    RELEVANCE = 3
    UPDATE_SEQUENCE_NUMBER = 4
    TITLE = 5



class PremiumOrderStatus(IntEnum):
    """
    This enumeration defines the possible states of a premium account

    NONE:    the user has never attempted to become a premium subscriber

    PENDING: the user has requested a premium account but their charge has not
      been confirmed

    ACTIVE:  the user has been charged and their premium account is in good
     standing

    FAILED:  the system attempted to charge the was denied. We will periodically attempt to
     re-validate their order.

    CANCELLATION_PENDING: the user has requested that no further charges be made
      but the current account is still active.

    CANCELED: the premium account was canceled either because of failure to pay
      or user cancelation. No more attempts will be made to activate the account.

    """
    NONE = 0
    PENDING = 1
    ACTIVE = 2
    FAILED = 3
    CANCELLATION_PENDING = 4
    CANCELED = 5



class SharedNotebookPrivilegeLevel(IntEnum):
    """
    Privilege levels for accessing shared notebooks.

    Note that as of 2014-04, FULL_ACCESS is synonymous with BUSINESS_FULL_ACCESS.  If a
    user is a member of a business and has FULL_ACCESS privileges, then they will
    automatically be granted BUSINESS_FULL_ACCESS for notebooks in their business.  This
    will happen implicitly when they attempt to access the corresponding notebooks of
    the business.  BUSINESS_FULL_ACCESS is therefore deprecated.

    READ_NOTEBOOK: Recipient is able to read the contents of the shared notebook
      but does not have access to information about other recipients of the
      notebook or the activity stream information.

    MODIFY_NOTEBOOK_PLUS_ACTIVITY: Recipient has rights to read and modify the contents
      of the shared notebook, including the right to move notes to the trash and to create
      notes in the notebook.  The recipient can also access information about other
      recipients and the activity stream.

    READ_NOTEBOOK_PLUS_ACTIVITY: Recipient has READ_NOTEBOOK rights and can also
      access information about other recipients and the activity stream.

    GROUP: If the user belongs to a group, such as a Business, that has a defined
      privilege level, use the privilege level of the group as the privilege for
      the individual.

    FULL_ACCESS: Recipient has full rights to the shared notebook and recipient lists,
      including privilege to revoke and create invitations and to change privilege
      levels on invitations for individuals.  For members of a business, FULL_ACCESS
      privilege on business notebooks also grants the ability to change how the notebook
      will appear when shared with the business, including the rights to share and
      unshare the notebook with the business.

    BUSINESS_FULL_ACCESS: Deprecated.  See the note above about BUSINESS_FULL_ACCESS and
      FULL_ACCESS being synonymous.

    """
    READ_NOTEBOOK = 0
    MODIFY_NOTEBOOK_PLUS_ACTIVITY = 1
    READ_NOTEBOOK_PLUS_ACTIVITY = 2
    GROUP = 3
    FULL_ACCESS = 4
    BUSINESS_FULL_ACCESS = 5



class SharedNotePrivilegeLevel(IntEnum):
    """
    Privilege levels for accessing a shared note. All privilege levels convey "activity feed" access,
    which allows the recipient to access information about other recipients and the activity stream.

    READ_NOTE: Recipient has rights to read the shared note.

    MODIFY_NOTE: Recipient has all of the rights of READ_NOTE, plus rights to modify the shared
      note's content, title and resources. Other fields, including the notebook, tags and metadata,
      may not be modified.

    FULL_ACCESS: Recipient has all of the rights of MODIFY_NOTE, plus rights to share the note with
      other users via email, public note links, and note sharing. Recipient may also update and
      remove other recipient's note sharing rights.

    """
    READ_NOTE = 0
    MODIFY_NOTE = 1
    FULL_ACCESS = 2



class SponsoredGroupRole(IntEnum):
    """
    Enumeration of the roles that a User can have within a sponsored group.

    GROUP_MEMBER: The user is a member of the group with no special privileges.

    GROUP_ADMIN: The user is an administrator within the group.

    GROUP_OWNER: The user is the owner of the group.

    """
    GROUP_MEMBER = 1
    GROUP_ADMIN = 2
    GROUP_OWNER = 3



class BusinessUserRole(IntEnum):
    """
    Enumeration of the roles that a User can have within an Evernote Business account.

    ADMIN: The user is an administrator of the Evernote Business account.

    NORMAL: The user is a regular user within the Evernote Business account.

    """
    ADMIN = 1
    NORMAL = 2



class BusinessUserStatus(IntEnum):
    """
    The BusinessUserStatus indicates the status of the user in the business.

    A BusinessUser will typically start as ACTIVE.
    Only ACTIVE users can authenticate to the Business.

    <dl>
    <dt>ACTIVE<dt>
    <dd>The business user can authenticate to and access the business.</dd>
    <dt>DEACTIVATED<dt>
    <dd>The business user has been deactivated and cannot access the business</dd>
    </dl>

    """
    ACTIVE = 1
    DEACTIVATED = 2



class SharedNotebookInstanceRestrictions(IntEnum):
    """
    An enumeration describing restrictions on the domain of shared notebook
    instances that are valid for a given operation, as used, for example, in
    NotebookRestrictions.

    ASSIGNED: The domain consists of shared notebooks that belong, or are assigned,
    to the recipient.

    NO_SHARED_NOTEBOOKS: No shared notebooks are applicable to the operation.

    """
    ASSIGNED = 1
    NO_SHARED_NOTEBOOKS = 2



class ReminderEmailConfig(IntEnum):
    """
    An enumeration describing the configuration state related to receiving
    reminder e-mails from the service.  Reminder e-mails summarize notes
    based on their Note.attributes.reminderTime values.

    DO_NOT_SEND: The user has selected to not receive reminder e-mail.

    SEND_DAILY_EMAIL: The user has selected to receive reminder e-mail for those
      days when there is a reminder.

    """
    DO_NOT_SEND = 1
    SEND_DAILY_EMAIL = 2



class BusinessInvitationStatus(IntEnum):
    """
    An enumeration defining the possible states of a BusinessInvitation.

    APPROVED: The invitation was created or approved by a business admin and may be redeemed by the
      invited email.

    REQUESTED: The invitation was requested by a non-admin member of the business and must be
      approved by an admin before it may be redeemed. Invitations in this state do not count
      against a business' seat limit.

    REDEEMED: The invitation has already been redeemed. Invitations in this state do not count
      against a business' seat limit.

    """
    APPROVED = 0
    REQUESTED = 1
    REDEEMED = 2



class ContactType(IntEnum):
    """
    What kinds of Contacts does the Evernote service know about?

    """
    EVERNOTE = 1
    SMS = 2
    FACEBOOK = 3
    EMAIL = 4
    TWITTER = 5
    LINKEDIN = 6



class EntityType(IntEnum):
    """
    Entity types

    """
    NOTE = 1
    NOTEBOOK = 2
    WORKSPACE = 3



class RecipientStatus(IntEnum):
    """
    This enumeration defines the possible states that a notebook can be in for a recipient.
    It encompasses the "inMyList" boolean and default notebook status.

    <dl>
    <dt>NOT_IN_MY_LIST</dt>
    <dd>The notebook is not in the recipient's list (not "joined").</dd>
    <dt>IN_MY_LIST</dt>
    <dd>The notebook is in the recipient's notebook list (formerly, we would say
        that the recipient has "joined" the notebook)</dd>
    <dt>IN_MY_LIST_AND_DEFAULT_NOTEBOOK</dt>
    <dd>The same as IN_MY_LIST and this notebook is the user's default notebook.</dd>
    </dl>

    """
    NOT_IN_MY_LIST = 1
    IN_MY_LIST = 2
    IN_MY_LIST_AND_DEFAULT_NOTEBOOK = 3



class CanMoveToContainerStatus(IntEnum):
    """
    This enumeration defines the possible types of canMoveToContainer outcomes.
    <p />
    An outdated client is expected to signal a "Cannot Move, Please Upgrade To Learn Why"
    like response to the user if an unknown enumeration value is received.
    <dl>
    <dt>CAN_BE_MOVED</dt>
    <dd>Can move Notebook to Workspace.</dd>
    <dt>INSUFFICIENT_ENTITY_PRIVILEGE</dt>
    <dd>Can not move Notebook to Workspace, because either:
     a) Notebook not in Workspace and insufficient privilege on Notebook
     or b) Notebook in Workspace and membership on Workspace with insufficient privilege
     for move</dd>
    <dt>INSUFFICIENT_CONTAINER_PRIVILEGE</dt>
    <dd>Notebook in Workspace and no membership on Workspace.
    </dd>
    </dl>

    """
    CAN_BE_MOVED = 1
    INSUFFICIENT_ENTITY_PRIVILEGE = 2
    INSUFFICIENT_CONTAINER_PRIVILEGE = 3



class RelatedContentType(IntEnum):
    """
    This enumeration defines the possible types of related content.

    NEWS_ARTICLE: This related content is a news article
    PROFILE_PERSON: This match refers to the profile of an individual person
    PROFILE_ORGANIZATION: This match refers to the profile of an organization
    REFERENCE_MATERIAL: This related content is material from reference works

    """
    NEWS_ARTICLE = 1
    PROFILE_PERSON = 2
    PROFILE_ORGANIZATION = 3
    REFERENCE_MATERIAL = 4



class RelatedContentAccess(IntEnum):
    """
    This enumeration defines the possible ways to access related content.

    NOT_ACCESSIBLE: The content is not accessible given the user's privilege level, but
        still worth showing as a snippet. The content url may point to a webpage that
        explains why not, or explains how to access that content.

    DIRECT_LINK_ACCESS_OK: The content is accessible directly, and no additional login is
        required.

    DIRECT_LINK_LOGIN_REQUIRED: The content is accessible directly, but an additional login
        is required.

    DIRECT_LINK_EMBEDDED_VIEW: The content is accessible directly, and should be shown in
        an embedded web view.
        If the URL refers to a secured location under our control (for example,
        https://www.evernote.com/*), the client may include user-specific authentication
        credentials with the request.

    """
    NOT_ACCESSIBLE = 0
    DIRECT_LINK_ACCESS_OK = 1
    DIRECT_LINK_LOGIN_REQUIRED = 2
    DIRECT_LINK_EMBEDDED_VIEW = 3



class UserIdentityType(IntEnum):
    """


    """
    EVERNOTE_USERID = 1
    EMAIL = 2
    IDENTITYID = 3



class Data(object):
    """
     In several places, EDAM exchanges blocks of bytes of data for a component
     which may be relatively large.  For example:  the contents of a clipped
     HTML note, the bytes of an embedded image, or the recognition XML for
     a large image.  This structure is used in the protocol to represent
     any of those large blocks of data when they are transmitted or when
     they are only referenced their metadata.

    <dl>
     <dt>bodyHash</dt>
       <dd>This field carries a one-way hash of the contents of the
       data body, in binary form.  The hash function is MD5<br/>
       Length:  EDAM_HASH_LEN (exactly)
       </dd>

     <dt>size</dt>
       <dd>The length, in bytes, of the data body.
       </dd>

     <dt>body</dt>
       <dd>This field is set to contain the binary contents of the data
       whenever the resource is being transferred.  If only metadata is
       being exchanged, this field will be empty.  For example, a client could
       notify the service about the change to an attribute for a resource
       without transmitting the binary resource contents.
       </dd>
     </dl>

    Attributes:
     - bodyHash
     - size
     - body

    """
    thrift_spec: typing.Any = None


    def __init__(self, bodyHash: typing.Optional[bytes] = None, size: typing.Optional[int] = None, body: typing.Optional[bytes] = None,):
        self.bodyHash: typing.Optional[bytes] = bodyHash
        self.size: typing.Optional[int] = size
        self.body: typing.Optional[bytes] = body

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.bodyHash = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.body = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Data')
        if self.bodyHash is not None:
            oprot.writeFieldBegin('bodyHash', TType.STRING, 1)
            oprot.writeBinary(self.bodyHash)
            oprot.writeFieldEnd()
        if self.size is not None:
            oprot.writeFieldBegin('size', TType.I32, 2)
            oprot.writeI32(self.size)
            oprot.writeFieldEnd()
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRING, 3)
            oprot.writeBinary(self.body)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UserAttributes(object):
    """
     A structure holding the optional attributes that can be stored
     on a User.  These are generally less critical than the core User fields.

    <dl>
     <dt>defaultLocationName</dt>
       <dd>the location string that should be associated
       with the user in order to determine where notes are taken if not otherwise
       specified.<br/>
       Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
       </dd>

     <dt>defaultLatitude</dt>
       <dd>if set, this is the latitude that should be
       assigned to any notes that have no other latitude information.
       </dd>

     <dt>defaultLongitude</dt>
       <dd>if set, this is the longitude that should be
       assigned to any notes that have no other longitude information.
       </dd>

     <dt>preactivation</dt>
       <dd>if set, the user account is not yet confirmed for
       login.  I.e. the account has been created, but we are still waiting for
       the user to complete the activation step.
       </dd>

     <dt>viewedPromotions</dt>
       <dd>a list of promotions the user has seen.
        This list may occasionally be modified by the system when promotions are
        no longer available.<br/>
        Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
       </dd>

     <dt>incomingEmailAddress</dt>
       <dd>if set, this is the email address that the
        user may send email to in order to add an email note directly into the
        account via the SMTP email gateway.  This is the part of the email
        address before the '@' symbol ... our domain is not included.
        If this is not set, the user may not add notes via the gateway.<br/>
        Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
       </dd>

     <dt>recentMailedAddresses</dt>
       <dd>if set, this will contain a list of email
        addresses that have recently been used as recipients
        of outbound emails by the user.  This can be used to pre-populate a
        list of possible destinations when a user wishes to send a note via
        email.<br/>
        Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX each<br/>
        Max:  EDAM_USER_RECENT_MAILED_ADDRESSES_MAX entries
       </dd>

     <dt>comments</dt>
       <dd>Free-form text field that may hold general support
        information, etc.<br/>
        Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
       </dd>

     <dt>dateAgreedToTermsOfService</dt>
       <dd>The date/time when the user agreed to
        the terms of service.  This can be used as the effective "start date"
        for the account.
       </dd>

     <dt>maxReferrals</dt>
       <dd>The number of referrals that the user is permitted
        to make.
       </dd>

     <dt>referralCount</dt>
       <dd>The number of referrals sent from this account.
       </dd>

     <dt>refererCode</dt>
       <dd>A code indicating where the user was sent from. AKA
        promotion code
       </dd>

     <dt>sentEmailDate</dt>
       <dd>The most recent date when the user sent outbound
        emails from the service.  Used with sentEmailCount to limit the number
        of emails that can be sent per day.
       </dd>

     <dt>sentEmailCount</dt>
       <dd>The number of emails that were sent from the user
        via the service on sentEmailDate.  Used to enforce a limit on the number
        of emails per user per day to prevent spamming.
       </dd>

     <dt>dailyEmailLimit</dt>
       <dd>If set, this is the maximum number of emails that
        may be sent in a given day from this account.  If unset, the server will
        use the configured default limit.
       </dd>

     <dt>emailOptOutDate</dt>
       <dd>If set, this is the date when the user asked
        to be excluded from offers and promotions sent by Evernote.  If not set,
        then the user currently agrees to receive these messages.
       </dd>

     <dt>partnerEmailOptInDate</dt>
       <dd>If set, this is the date when the user asked
        to be included in offers and promotions sent by Evernote's partners.
        If not sent, then the user currently does not agree to receive these
        emails.
       </dd>

     <dt>preferredLanguage</dt>
       <dd>a 2 character language codes based on:
           http://ftp.ics.uci.edu/pub/ietf/http/related/iso639.txt used for
          localization purposes to determine what language to use for the web
          interface and for other direct communication (e.g. emails).
       </dd>

     <dt>preferredCountry</dt>
       <dd>Preferred country code based on ISO 3166-1-alpha-2 indicating the
       users preferred country</dd>

     <dt>clipFullPage</dt>
       <dd>Boolean flag set to true if the user wants to clip full pages by
       default when they use the web clipper without a selection.</dd>

     <dt>twitterUserName</dt>
       <dd>The username of the account of someone who has chosen to enable
       Twittering into Evernote.  This value is subject to change, since users
       may change their Twitter user name.</dd>

     <dt>twitterId</dt>
       <dd>The unique identifier of the user's Twitter account if that user
       has chosen to enable Twittering into Evernote.</dd>

     <dt>groupName</dt>
       <dd>A name identifier used to identify a particular set of branding and
        light customization.</dd>

     <dt>recognitionLanguage</dt>
       <dd>a 2 character language codes based on:
           http://ftp.ics.uci.edu/pub/ietf/http/related/iso639.txt
           If set, this is used to determine the language that should be used
           when processing images and PDF files to find text.
           If not set, then the 'preferredLanguage' will be used.
       </dd>

     <dt>educationalInstitution</dt>
       <dd>a flag indicating that the user is part of an educational institution which
       makes them eligible for discounts on bulk purchases
       </dd>

     <dt>businessAddress</dt>
       <dd>A string recording the business address of a Sponsored Account user who has requested invoicing.
       </dd>

     <dt>hideSponsorBilling</dt>
       <dd>A flag indicating whether to hide the billing information on a sponsored
           account owner's settings page
       </dd>

     <dt>useEmailAutoFiling</dt>
       <dd>A flag indicating whether the user chooses to allow Evernote to automatically
           file and tag emailed notes
       </dd>

     <dt>reminderEmailConfig</dt>
       <dd>Configuration state for whether or not the user wishes to receive
           reminder e-mail.  This setting applies to both the reminder e-mail sent
           for personal reminder notes and for the reminder e-mail sent for reminder
           notes in the user's business notebooks that the user has configured for
           e-mail notifications.
       </dd>

     <dt>emailAddressLastConfirmed</dt>
       <dd>If set, this contains the time at which the user last confirmed that the
           configured email address for this account is correct and up-to-date. If this is
           unset that indicates that the user's email address is unverified.
       </dd>

     <dt>passwordUpdated</dt>
       <dd>If set, this contains the time at which the user's password last changed. This
           will be unset for users created before the addition of this field who have not
           changed their passwords since the addition of this field.
       </dd>

     <dt>shouldLogClientEvent</dt>
       <dd>If set to True, the server will record LogRequest send from clients of this
            user as ClientEventLog.
       </dd>

     <dt>optOutMachineLearning</dt>
       <dd>If set to True, no Machine Learning nor human review will be done to this
            user's note contents.
       </dd>
       </dl>

    Attributes:
     - defaultLocationName
     - defaultLatitude
     - defaultLongitude
     - preactivation
     - viewedPromotions
     - incomingEmailAddress
     - recentMailedAddresses
     - comments
     - dateAgreedToTermsOfService
     - maxReferrals
     - referralCount
     - refererCode
     - sentEmailDate
     - sentEmailCount
     - dailyEmailLimit
     - emailOptOutDate
     - partnerEmailOptInDate
     - preferredLanguage
     - preferredCountry
     - clipFullPage
     - twitterUserName
     - twitterId
     - groupName
     - recognitionLanguage
     - referralProof
     - educationalDiscount
     - businessAddress
     - hideSponsorBilling
     - useEmailAutoFiling
     - reminderEmailConfig
     - emailAddressLastConfirmed
     - passwordUpdated
     - salesforcePushEnabled
     - shouldLogClientEvent
     - optOutMachineLearning

    """
    thrift_spec: typing.Any = None


    def __init__(self, defaultLocationName: typing.Optional[str] = None, defaultLatitude: typing.Optional[float] = None, defaultLongitude: typing.Optional[float] = None, preactivation: typing.Optional[bool] = None, viewedPromotions: typing.Optional[list[str]] = None, incomingEmailAddress: typing.Optional[str] = None, recentMailedAddresses: typing.Optional[list[str]] = None, comments: typing.Optional[str] = None, dateAgreedToTermsOfService: typing.Optional[int] = None, maxReferrals: typing.Optional[int] = None, referralCount: typing.Optional[int] = None, refererCode: typing.Optional[str] = None, sentEmailDate: typing.Optional[int] = None, sentEmailCount: typing.Optional[int] = None, dailyEmailLimit: typing.Optional[int] = None, emailOptOutDate: typing.Optional[int] = None, partnerEmailOptInDate: typing.Optional[int] = None, preferredLanguage: typing.Optional[str] = None, preferredCountry: typing.Optional[str] = None, clipFullPage: typing.Optional[bool] = None, twitterUserName: typing.Optional[str] = None, twitterId: typing.Optional[str] = None, groupName: typing.Optional[str] = None, recognitionLanguage: typing.Optional[str] = None, referralProof: typing.Optional[str] = None, educationalDiscount: typing.Optional[bool] = None, businessAddress: typing.Optional[str] = None, hideSponsorBilling: typing.Optional[bool] = None, useEmailAutoFiling: typing.Optional[bool] = None, reminderEmailConfig: typing.Optional[ReminderEmailConfig] = None, emailAddressLastConfirmed: typing.Optional[int] = None, passwordUpdated: typing.Optional[int] = None, salesforcePushEnabled: typing.Optional[bool] = None, shouldLogClientEvent: typing.Optional[bool] = None, optOutMachineLearning: typing.Optional[bool] = None,):
        self.defaultLocationName: typing.Optional[str] = defaultLocationName
        self.defaultLatitude: typing.Optional[float] = defaultLatitude
        self.defaultLongitude: typing.Optional[float] = defaultLongitude
        self.preactivation: typing.Optional[bool] = preactivation
        self.viewedPromotions: typing.Optional[list[str]] = viewedPromotions
        self.incomingEmailAddress: typing.Optional[str] = incomingEmailAddress
        self.recentMailedAddresses: typing.Optional[list[str]] = recentMailedAddresses
        self.comments: typing.Optional[str] = comments
        self.dateAgreedToTermsOfService: typing.Optional[int] = dateAgreedToTermsOfService
        self.maxReferrals: typing.Optional[int] = maxReferrals
        self.referralCount: typing.Optional[int] = referralCount
        self.refererCode: typing.Optional[str] = refererCode
        self.sentEmailDate: typing.Optional[int] = sentEmailDate
        self.sentEmailCount: typing.Optional[int] = sentEmailCount
        self.dailyEmailLimit: typing.Optional[int] = dailyEmailLimit
        self.emailOptOutDate: typing.Optional[int] = emailOptOutDate
        self.partnerEmailOptInDate: typing.Optional[int] = partnerEmailOptInDate
        self.preferredLanguage: typing.Optional[str] = preferredLanguage
        self.preferredCountry: typing.Optional[str] = preferredCountry
        self.clipFullPage: typing.Optional[bool] = clipFullPage
        self.twitterUserName: typing.Optional[str] = twitterUserName
        self.twitterId: typing.Optional[str] = twitterId
        self.groupName: typing.Optional[str] = groupName
        self.recognitionLanguage: typing.Optional[str] = recognitionLanguage
        self.referralProof: typing.Optional[str] = referralProof
        self.educationalDiscount: typing.Optional[bool] = educationalDiscount
        self.businessAddress: typing.Optional[str] = businessAddress
        self.hideSponsorBilling: typing.Optional[bool] = hideSponsorBilling
        self.useEmailAutoFiling: typing.Optional[bool] = useEmailAutoFiling
        self.reminderEmailConfig: typing.Optional[ReminderEmailConfig] = reminderEmailConfig
        self.emailAddressLastConfirmed: typing.Optional[int] = emailAddressLastConfirmed
        self.passwordUpdated: typing.Optional[int] = passwordUpdated
        self.salesforcePushEnabled: typing.Optional[bool] = salesforcePushEnabled
        self.shouldLogClientEvent: typing.Optional[bool] = shouldLogClientEvent
        self.optOutMachineLearning: typing.Optional[bool] = optOutMachineLearning

    def __setattr__(self, name, value):
        if name == "reminderEmailConfig":
            super().__setattr__(name, value if hasattr(value, 'value') else ReminderEmailConfig.__members__.get(value))
            return
        super().__setattr__(name, value)


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.defaultLocationName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.defaultLatitude = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.defaultLongitude = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.preactivation = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.viewedPromotions = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.viewedPromotions.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.incomingEmailAddress = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.recentMailedAddresses = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.recentMailedAddresses.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.comments = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I64:
                    self.dateAgreedToTermsOfService = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I32:
                    self.maxReferrals = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.I32:
                    self.referralCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.STRING:
                    self.refererCode = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.I64:
                    self.sentEmailDate = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.I32:
                    self.sentEmailCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.I32:
                    self.dailyEmailLimit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.I64:
                    self.emailOptOutDate = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.I64:
                    self.partnerEmailOptInDate = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.STRING:
                    self.preferredLanguage = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.STRING:
                    self.preferredCountry = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.BOOL:
                    self.clipFullPage = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 23:
                if ftype == TType.STRING:
                    self.twitterUserName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 24:
                if ftype == TType.STRING:
                    self.twitterId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 25:
                if ftype == TType.STRING:
                    self.groupName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 26:
                if ftype == TType.STRING:
                    self.recognitionLanguage = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 28:
                if ftype == TType.STRING:
                    self.referralProof = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 29:
                if ftype == TType.BOOL:
                    self.educationalDiscount = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 30:
                if ftype == TType.STRING:
                    self.businessAddress = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 31:
                if ftype == TType.BOOL:
                    self.hideSponsorBilling = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 33:
                if ftype == TType.BOOL:
                    self.useEmailAutoFiling = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 34:
                if ftype == TType.I32:
                    self.reminderEmailConfig = ReminderEmailConfig(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 35:
                if ftype == TType.I64:
                    self.emailAddressLastConfirmed = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 36:
                if ftype == TType.I64:
                    self.passwordUpdated = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 37:
                if ftype == TType.BOOL:
                    self.salesforcePushEnabled = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 38:
                if ftype == TType.BOOL:
                    self.shouldLogClientEvent = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 39:
                if ftype == TType.BOOL:
                    self.optOutMachineLearning = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UserAttributes')
        if self.defaultLocationName is not None:
            oprot.writeFieldBegin('defaultLocationName', TType.STRING, 1)
            oprot.writeString(self.defaultLocationName.encode('utf-8') if sys.version_info[0] == 2 else self.defaultLocationName)
            oprot.writeFieldEnd()
        if self.defaultLatitude is not None:
            oprot.writeFieldBegin('defaultLatitude', TType.DOUBLE, 2)
            oprot.writeDouble(self.defaultLatitude)
            oprot.writeFieldEnd()
        if self.defaultLongitude is not None:
            oprot.writeFieldBegin('defaultLongitude', TType.DOUBLE, 3)
            oprot.writeDouble(self.defaultLongitude)
            oprot.writeFieldEnd()
        if self.preactivation is not None:
            oprot.writeFieldBegin('preactivation', TType.BOOL, 4)
            oprot.writeBool(self.preactivation)
            oprot.writeFieldEnd()
        if self.viewedPromotions is not None:
            oprot.writeFieldBegin('viewedPromotions', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.viewedPromotions))
            for iter12 in self.viewedPromotions:
                oprot.writeString(iter12.encode('utf-8') if sys.version_info[0] == 2 else iter12)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.incomingEmailAddress is not None:
            oprot.writeFieldBegin('incomingEmailAddress', TType.STRING, 6)
            oprot.writeString(self.incomingEmailAddress.encode('utf-8') if sys.version_info[0] == 2 else self.incomingEmailAddress)
            oprot.writeFieldEnd()
        if self.recentMailedAddresses is not None:
            oprot.writeFieldBegin('recentMailedAddresses', TType.LIST, 7)
            oprot.writeListBegin(TType.STRING, len(self.recentMailedAddresses))
            for iter13 in self.recentMailedAddresses:
                oprot.writeString(iter13.encode('utf-8') if sys.version_info[0] == 2 else iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.comments is not None:
            oprot.writeFieldBegin('comments', TType.STRING, 9)
            oprot.writeString(self.comments.encode('utf-8') if sys.version_info[0] == 2 else self.comments)
            oprot.writeFieldEnd()
        if self.dateAgreedToTermsOfService is not None:
            oprot.writeFieldBegin('dateAgreedToTermsOfService', TType.I64, 11)
            oprot.writeI64(self.dateAgreedToTermsOfService)
            oprot.writeFieldEnd()
        if self.maxReferrals is not None:
            oprot.writeFieldBegin('maxReferrals', TType.I32, 12)
            oprot.writeI32(self.maxReferrals)
            oprot.writeFieldEnd()
        if self.referralCount is not None:
            oprot.writeFieldBegin('referralCount', TType.I32, 13)
            oprot.writeI32(self.referralCount)
            oprot.writeFieldEnd()
        if self.refererCode is not None:
            oprot.writeFieldBegin('refererCode', TType.STRING, 14)
            oprot.writeString(self.refererCode.encode('utf-8') if sys.version_info[0] == 2 else self.refererCode)
            oprot.writeFieldEnd()
        if self.sentEmailDate is not None:
            oprot.writeFieldBegin('sentEmailDate', TType.I64, 15)
            oprot.writeI64(self.sentEmailDate)
            oprot.writeFieldEnd()
        if self.sentEmailCount is not None:
            oprot.writeFieldBegin('sentEmailCount', TType.I32, 16)
            oprot.writeI32(self.sentEmailCount)
            oprot.writeFieldEnd()
        if self.dailyEmailLimit is not None:
            oprot.writeFieldBegin('dailyEmailLimit', TType.I32, 17)
            oprot.writeI32(self.dailyEmailLimit)
            oprot.writeFieldEnd()
        if self.emailOptOutDate is not None:
            oprot.writeFieldBegin('emailOptOutDate', TType.I64, 18)
            oprot.writeI64(self.emailOptOutDate)
            oprot.writeFieldEnd()
        if self.partnerEmailOptInDate is not None:
            oprot.writeFieldBegin('partnerEmailOptInDate', TType.I64, 19)
            oprot.writeI64(self.partnerEmailOptInDate)
            oprot.writeFieldEnd()
        if self.preferredLanguage is not None:
            oprot.writeFieldBegin('preferredLanguage', TType.STRING, 20)
            oprot.writeString(self.preferredLanguage.encode('utf-8') if sys.version_info[0] == 2 else self.preferredLanguage)
            oprot.writeFieldEnd()
        if self.preferredCountry is not None:
            oprot.writeFieldBegin('preferredCountry', TType.STRING, 21)
            oprot.writeString(self.preferredCountry.encode('utf-8') if sys.version_info[0] == 2 else self.preferredCountry)
            oprot.writeFieldEnd()
        if self.clipFullPage is not None:
            oprot.writeFieldBegin('clipFullPage', TType.BOOL, 22)
            oprot.writeBool(self.clipFullPage)
            oprot.writeFieldEnd()
        if self.twitterUserName is not None:
            oprot.writeFieldBegin('twitterUserName', TType.STRING, 23)
            oprot.writeString(self.twitterUserName.encode('utf-8') if sys.version_info[0] == 2 else self.twitterUserName)
            oprot.writeFieldEnd()
        if self.twitterId is not None:
            oprot.writeFieldBegin('twitterId', TType.STRING, 24)
            oprot.writeString(self.twitterId.encode('utf-8') if sys.version_info[0] == 2 else self.twitterId)
            oprot.writeFieldEnd()
        if self.groupName is not None:
            oprot.writeFieldBegin('groupName', TType.STRING, 25)
            oprot.writeString(self.groupName.encode('utf-8') if sys.version_info[0] == 2 else self.groupName)
            oprot.writeFieldEnd()
        if self.recognitionLanguage is not None:
            oprot.writeFieldBegin('recognitionLanguage', TType.STRING, 26)
            oprot.writeString(self.recognitionLanguage.encode('utf-8') if sys.version_info[0] == 2 else self.recognitionLanguage)
            oprot.writeFieldEnd()
        if self.referralProof is not None:
            oprot.writeFieldBegin('referralProof', TType.STRING, 28)
            oprot.writeString(self.referralProof.encode('utf-8') if sys.version_info[0] == 2 else self.referralProof)
            oprot.writeFieldEnd()
        if self.educationalDiscount is not None:
            oprot.writeFieldBegin('educationalDiscount', TType.BOOL, 29)
            oprot.writeBool(self.educationalDiscount)
            oprot.writeFieldEnd()
        if self.businessAddress is not None:
            oprot.writeFieldBegin('businessAddress', TType.STRING, 30)
            oprot.writeString(self.businessAddress.encode('utf-8') if sys.version_info[0] == 2 else self.businessAddress)
            oprot.writeFieldEnd()
        if self.hideSponsorBilling is not None:
            oprot.writeFieldBegin('hideSponsorBilling', TType.BOOL, 31)
            oprot.writeBool(self.hideSponsorBilling)
            oprot.writeFieldEnd()
        if self.useEmailAutoFiling is not None:
            oprot.writeFieldBegin('useEmailAutoFiling', TType.BOOL, 33)
            oprot.writeBool(self.useEmailAutoFiling)
            oprot.writeFieldEnd()
        if self.reminderEmailConfig is not None:
            oprot.writeFieldBegin('reminderEmailConfig', TType.I32, 34)
            oprot.writeI32(self.reminderEmailConfig.value)
            oprot.writeFieldEnd()
        if self.emailAddressLastConfirmed is not None:
            oprot.writeFieldBegin('emailAddressLastConfirmed', TType.I64, 35)
            oprot.writeI64(self.emailAddressLastConfirmed)
            oprot.writeFieldEnd()
        if self.passwordUpdated is not None:
            oprot.writeFieldBegin('passwordUpdated', TType.I64, 36)
            oprot.writeI64(self.passwordUpdated)
            oprot.writeFieldEnd()
        if self.salesforcePushEnabled is not None:
            oprot.writeFieldBegin('salesforcePushEnabled', TType.BOOL, 37)
            oprot.writeBool(self.salesforcePushEnabled)
            oprot.writeFieldEnd()
        if self.shouldLogClientEvent is not None:
            oprot.writeFieldBegin('shouldLogClientEvent', TType.BOOL, 38)
            oprot.writeBool(self.shouldLogClientEvent)
            oprot.writeFieldEnd()
        if self.optOutMachineLearning is not None:
            oprot.writeFieldBegin('optOutMachineLearning', TType.BOOL, 39)
            oprot.writeBool(self.optOutMachineLearning)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BusinessUserAttributes(object):
    """
    A structure holding the optional attributes associated with users
    in a business.

    <dl>
     <dt>title</dt>
     <dd>Free form text of this user's title in the business</dd>

     <dt>location</dt>
     <dd>City, State (for US) or City / Province for other countries</dd>

     <dt>department</dt>
     <dd>Free form text of the department this user belongs to.</dd>

     <dt>mobilePhone</dt>
     <dd>User's mobile phone number. Stored as plain text without any formatting.</dd>

     <dt>linkedInProfileUrl</dt>
     <dd>URL to user's public LinkedIn profile page. This should only contain
     the portion relative to the base LinkedIn URL. For example: "/pub/john-smith/".
     </dd>

     <dt>workPhone</dt>
     <dd>User's work phone number. Stored as plain text without any formatting.</dd>

     <dt>companyStartDate</dt>
     <dd>The date on which the user started working at their company.</dd>
    </dl>

    Attributes:
     - title
     - location
     - department
     - mobilePhone
     - linkedInProfileUrl
     - workPhone
     - companyStartDate

    """
    thrift_spec: typing.Any = None


    def __init__(self, title: typing.Optional[str] = None, location: typing.Optional[str] = None, department: typing.Optional[str] = None, mobilePhone: typing.Optional[str] = None, linkedInProfileUrl: typing.Optional[str] = None, workPhone: typing.Optional[str] = None, companyStartDate: typing.Optional[int] = None,):
        self.title: typing.Optional[str] = title
        self.location: typing.Optional[str] = location
        self.department: typing.Optional[str] = department
        self.mobilePhone: typing.Optional[str] = mobilePhone
        self.linkedInProfileUrl: typing.Optional[str] = linkedInProfileUrl
        self.workPhone: typing.Optional[str] = workPhone
        self.companyStartDate: typing.Optional[int] = companyStartDate

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.title = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.location = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.department = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.mobilePhone = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.linkedInProfileUrl = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.workPhone = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.companyStartDate = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BusinessUserAttributes')
        if self.title is not None:
            oprot.writeFieldBegin('title', TType.STRING, 1)
            oprot.writeString(self.title.encode('utf-8') if sys.version_info[0] == 2 else self.title)
            oprot.writeFieldEnd()
        if self.location is not None:
            oprot.writeFieldBegin('location', TType.STRING, 2)
            oprot.writeString(self.location.encode('utf-8') if sys.version_info[0] == 2 else self.location)
            oprot.writeFieldEnd()
        if self.department is not None:
            oprot.writeFieldBegin('department', TType.STRING, 3)
            oprot.writeString(self.department.encode('utf-8') if sys.version_info[0] == 2 else self.department)
            oprot.writeFieldEnd()
        if self.mobilePhone is not None:
            oprot.writeFieldBegin('mobilePhone', TType.STRING, 4)
            oprot.writeString(self.mobilePhone.encode('utf-8') if sys.version_info[0] == 2 else self.mobilePhone)
            oprot.writeFieldEnd()
        if self.linkedInProfileUrl is not None:
            oprot.writeFieldBegin('linkedInProfileUrl', TType.STRING, 5)
            oprot.writeString(self.linkedInProfileUrl.encode('utf-8') if sys.version_info[0] == 2 else self.linkedInProfileUrl)
            oprot.writeFieldEnd()
        if self.workPhone is not None:
            oprot.writeFieldBegin('workPhone', TType.STRING, 6)
            oprot.writeString(self.workPhone.encode('utf-8') if sys.version_info[0] == 2 else self.workPhone)
            oprot.writeFieldEnd()
        if self.companyStartDate is not None:
            oprot.writeFieldBegin('companyStartDate', TType.I64, 7)
            oprot.writeI64(self.companyStartDate)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Accounting(object):
    """
     This represents the bookkeeping information for the user's subscription.

    <dl>
     <dt>uploadLimitEnd</dt>
       <dd>The date and time when the current upload limit
       expires.  At this time, the monthly upload count reverts to 0 and a new
       limit is imposed.  This date and time is exclusive, so this is effectively
       the start of the new month.
       </dd>
     <dt>uploadLimitNextMonth</dt>
       <dd> When uploadLimitEnd is reached, the service
       will change uploadLimit to uploadLimitNextMonth. If a premium account is
       canceled, this mechanism will reset the quota appropriately.
       </dd>
     <dt>premiumServiceStatus</dt>
       <dd>Indicates the phases of a premium account
       during the billing process.
       </dd>
     <dt>premiumOrderNumber</dt>
       <dd>The order number used by the commerce system to
       process recurring payments
       </dd>
     <dt>premiumServiceStart</dt>
       <dd>The start date when this premium promotion
       began (this number will get overwritten if a premium service is canceled
       and then re-activated).
       </dd>
     <dt>premiumCommerceService</dt>
       <dd>The commerce system used (paypal, Google
       checkout, etc)
       </dd>
     <dt>premiumServiceSKU</dt>
       <dd>The code associated with the purchase eg. monthly
       or annual purchase. Clients should interpret this value and localize it.
       </dd>
     <dt>lastSuccessfulCharge</dt>
       <dd>Date the last time the user was charged.
       Null if never charged.
       </dd>
     <dt>lastFailedCharge</dt>
       <dd>Date the last time a charge was attempted and
       failed.
       </dd>
     <dt>lastFailedChargeReason</dt>
       <dd>Reason provided for the charge failure
       </dd>
     <dt>nextPaymentDue</dt>
       <dd>The end of the billing cycle. This could be in the
       past if there are failed charges.
       </dd>
     <dt>premiumLockUntil</dt>
       <dd>An internal variable to manage locking operations
       on the commerce variables.
       </dd>
     <dt>updated</dt>
       <dd>The date any modification where made to this record.
       </dd>
     <dt>premiumSubscriptionNumber</dt>
       <dd>The number number identifying the
       recurring subscription used to make the recurring charges.
       </dd>
     <dt>lastRequestedCharge</dt>
       <dd>Date charge last attempted</dd>
     <dt>currency</dt>
       <dd>ISO 4217 currency code</dd>
     <dt>unitPrice</dt>
       <dd>charge in the smallest unit of the currency (e.g. cents for USD)</dd>
     <dt>businessId</dt>
       <dd><i>DEPRECATED:</i>See BusinessUserInfo.</dd>
     <dt>businessName</dt>
       <dd><i>DEPRECATED:</i>See BusinessUserInfo.</dd>
     <dt>businessRole</dt>
       <dd><i>DEPRECATED:</i>See BusinessUserInfo.</dd>
     <dt>unitDiscount</dt>
       <dd>discount per seat in negative amount and smallest unit of the currency (e.g.
           cents for USD)</dd>
     <dt>nextChargeDate</dt>
       <dd>The next time the user will be charged, may or may not be the same as
           nextPaymentDue</dd>
     </dl>

    Attributes:
     - uploadLimitEnd
     - uploadLimitNextMonth
     - premiumServiceStatus
     - premiumOrderNumber
     - premiumCommerceService
     - premiumServiceStart
     - premiumServiceSKU
     - lastSuccessfulCharge
     - lastFailedCharge
     - lastFailedChargeReason
     - nextPaymentDue
     - premiumLockUntil
     - updated
     - premiumSubscriptionNumber
     - lastRequestedCharge
     - currency
     - unitPrice
     - businessId
     - businessName
     - businessRole
     - unitDiscount
     - nextChargeDate
     - availablePoints

    """
    thrift_spec: typing.Any = None


    def __init__(self, uploadLimitEnd: typing.Optional[int] = None, uploadLimitNextMonth: typing.Optional[int] = None, premiumServiceStatus: typing.Optional[PremiumOrderStatus] = None, premiumOrderNumber: typing.Optional[str] = None, premiumCommerceService: typing.Optional[str] = None, premiumServiceStart: typing.Optional[int] = None, premiumServiceSKU: typing.Optional[str] = None, lastSuccessfulCharge: typing.Optional[int] = None, lastFailedCharge: typing.Optional[int] = None, lastFailedChargeReason: typing.Optional[str] = None, nextPaymentDue: typing.Optional[int] = None, premiumLockUntil: typing.Optional[int] = None, updated: typing.Optional[int] = None, premiumSubscriptionNumber: typing.Optional[str] = None, lastRequestedCharge: typing.Optional[int] = None, currency: typing.Optional[str] = None, unitPrice: typing.Optional[int] = None, businessId: typing.Optional[int] = None, businessName: typing.Optional[str] = None, businessRole: typing.Optional[BusinessUserRole] = None, unitDiscount: typing.Optional[int] = None, nextChargeDate: typing.Optional[int] = None, availablePoints: typing.Optional[int] = None,):
        self.uploadLimitEnd: typing.Optional[int] = uploadLimitEnd
        self.uploadLimitNextMonth: typing.Optional[int] = uploadLimitNextMonth
        self.premiumServiceStatus: typing.Optional[PremiumOrderStatus] = premiumServiceStatus
        self.premiumOrderNumber: typing.Optional[str] = premiumOrderNumber
        self.premiumCommerceService: typing.Optional[str] = premiumCommerceService
        self.premiumServiceStart: typing.Optional[int] = premiumServiceStart
        self.premiumServiceSKU: typing.Optional[str] = premiumServiceSKU
        self.lastSuccessfulCharge: typing.Optional[int] = lastSuccessfulCharge
        self.lastFailedCharge: typing.Optional[int] = lastFailedCharge
        self.lastFailedChargeReason: typing.Optional[str] = lastFailedChargeReason
        self.nextPaymentDue: typing.Optional[int] = nextPaymentDue
        self.premiumLockUntil: typing.Optional[int] = premiumLockUntil
        self.updated: typing.Optional[int] = updated
        self.premiumSubscriptionNumber: typing.Optional[str] = premiumSubscriptionNumber
        self.lastRequestedCharge: typing.Optional[int] = lastRequestedCharge
        self.currency: typing.Optional[str] = currency
        self.unitPrice: typing.Optional[int] = unitPrice
        self.businessId: typing.Optional[int] = businessId
        self.businessName: typing.Optional[str] = businessName
        self.businessRole: typing.Optional[BusinessUserRole] = businessRole
        self.unitDiscount: typing.Optional[int] = unitDiscount
        self.nextChargeDate: typing.Optional[int] = nextChargeDate
        self.availablePoints: typing.Optional[int] = availablePoints

    def __setattr__(self, name, value):
        if name == "premiumServiceStatus":
            super().__setattr__(name, value if hasattr(value, 'value') else PremiumOrderStatus.__members__.get(value))
            return
        if name == "businessRole":
            super().__setattr__(name, value if hasattr(value, 'value') else BusinessUserRole.__members__.get(value))
            return
        super().__setattr__(name, value)


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I64:
                    self.uploadLimitEnd = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.uploadLimitNextMonth = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.premiumServiceStatus = PremiumOrderStatus(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.premiumOrderNumber = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.premiumCommerceService = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.premiumServiceStart = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.premiumServiceSKU = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.lastSuccessfulCharge = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I64:
                    self.lastFailedCharge = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRING:
                    self.lastFailedChargeReason = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I64:
                    self.nextPaymentDue = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.I64:
                    self.premiumLockUntil = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.I64:
                    self.updated = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.STRING:
                    self.premiumSubscriptionNumber = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.I64:
                    self.lastRequestedCharge = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.STRING:
                    self.currency = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.I32:
                    self.unitPrice = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.I32:
                    self.businessId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.STRING:
                    self.businessName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.I32:
                    self.businessRole = BusinessUserRole(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 23:
                if ftype == TType.I32:
                    self.unitDiscount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 24:
                if ftype == TType.I64:
                    self.nextChargeDate = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 25:
                if ftype == TType.I32:
                    self.availablePoints = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Accounting')
        if self.uploadLimitEnd is not None:
            oprot.writeFieldBegin('uploadLimitEnd', TType.I64, 2)
            oprot.writeI64(self.uploadLimitEnd)
            oprot.writeFieldEnd()
        if self.uploadLimitNextMonth is not None:
            oprot.writeFieldBegin('uploadLimitNextMonth', TType.I64, 3)
            oprot.writeI64(self.uploadLimitNextMonth)
            oprot.writeFieldEnd()
        if self.premiumServiceStatus is not None:
            oprot.writeFieldBegin('premiumServiceStatus', TType.I32, 4)
            oprot.writeI32(self.premiumServiceStatus.value)
            oprot.writeFieldEnd()
        if self.premiumOrderNumber is not None:
            oprot.writeFieldBegin('premiumOrderNumber', TType.STRING, 5)
            oprot.writeString(self.premiumOrderNumber.encode('utf-8') if sys.version_info[0] == 2 else self.premiumOrderNumber)
            oprot.writeFieldEnd()
        if self.premiumCommerceService is not None:
            oprot.writeFieldBegin('premiumCommerceService', TType.STRING, 6)
            oprot.writeString(self.premiumCommerceService.encode('utf-8') if sys.version_info[0] == 2 else self.premiumCommerceService)
            oprot.writeFieldEnd()
        if self.premiumServiceStart is not None:
            oprot.writeFieldBegin('premiumServiceStart', TType.I64, 7)
            oprot.writeI64(self.premiumServiceStart)
            oprot.writeFieldEnd()
        if self.premiumServiceSKU is not None:
            oprot.writeFieldBegin('premiumServiceSKU', TType.STRING, 8)
            oprot.writeString(self.premiumServiceSKU.encode('utf-8') if sys.version_info[0] == 2 else self.premiumServiceSKU)
            oprot.writeFieldEnd()
        if self.lastSuccessfulCharge is not None:
            oprot.writeFieldBegin('lastSuccessfulCharge', TType.I64, 9)
            oprot.writeI64(self.lastSuccessfulCharge)
            oprot.writeFieldEnd()
        if self.lastFailedCharge is not None:
            oprot.writeFieldBegin('lastFailedCharge', TType.I64, 10)
            oprot.writeI64(self.lastFailedCharge)
            oprot.writeFieldEnd()
        if self.lastFailedChargeReason is not None:
            oprot.writeFieldBegin('lastFailedChargeReason', TType.STRING, 11)
            oprot.writeString(self.lastFailedChargeReason.encode('utf-8') if sys.version_info[0] == 2 else self.lastFailedChargeReason)
            oprot.writeFieldEnd()
        if self.nextPaymentDue is not None:
            oprot.writeFieldBegin('nextPaymentDue', TType.I64, 12)
            oprot.writeI64(self.nextPaymentDue)
            oprot.writeFieldEnd()
        if self.premiumLockUntil is not None:
            oprot.writeFieldBegin('premiumLockUntil', TType.I64, 13)
            oprot.writeI64(self.premiumLockUntil)
            oprot.writeFieldEnd()
        if self.updated is not None:
            oprot.writeFieldBegin('updated', TType.I64, 14)
            oprot.writeI64(self.updated)
            oprot.writeFieldEnd()
        if self.premiumSubscriptionNumber is not None:
            oprot.writeFieldBegin('premiumSubscriptionNumber', TType.STRING, 16)
            oprot.writeString(self.premiumSubscriptionNumber.encode('utf-8') if sys.version_info[0] == 2 else self.premiumSubscriptionNumber)
            oprot.writeFieldEnd()
        if self.lastRequestedCharge is not None:
            oprot.writeFieldBegin('lastRequestedCharge', TType.I64, 17)
            oprot.writeI64(self.lastRequestedCharge)
            oprot.writeFieldEnd()
        if self.currency is not None:
            oprot.writeFieldBegin('currency', TType.STRING, 18)
            oprot.writeString(self.currency.encode('utf-8') if sys.version_info[0] == 2 else self.currency)
            oprot.writeFieldEnd()
        if self.unitPrice is not None:
            oprot.writeFieldBegin('unitPrice', TType.I32, 19)
            oprot.writeI32(self.unitPrice)
            oprot.writeFieldEnd()
        if self.businessId is not None:
            oprot.writeFieldBegin('businessId', TType.I32, 20)
            oprot.writeI32(self.businessId)
            oprot.writeFieldEnd()
        if self.businessName is not None:
            oprot.writeFieldBegin('businessName', TType.STRING, 21)
            oprot.writeString(self.businessName.encode('utf-8') if sys.version_info[0] == 2 else self.businessName)
            oprot.writeFieldEnd()
        if self.businessRole is not None:
            oprot.writeFieldBegin('businessRole', TType.I32, 22)
            oprot.writeI32(self.businessRole.value)
            oprot.writeFieldEnd()
        if self.unitDiscount is not None:
            oprot.writeFieldBegin('unitDiscount', TType.I32, 23)
            oprot.writeI32(self.unitDiscount)
            oprot.writeFieldEnd()
        if self.nextChargeDate is not None:
            oprot.writeFieldBegin('nextChargeDate', TType.I64, 24)
            oprot.writeI64(self.nextChargeDate)
            oprot.writeFieldEnd()
        if self.availablePoints is not None:
            oprot.writeFieldBegin('availablePoints', TType.I32, 25)
            oprot.writeI32(self.availablePoints)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BusinessUserInfo(object):
    """
    This structure is used to provide information about an Evernote Business
    membership, for members who are part of a business.

    <dl>
    <dt>businessId</dt>
      <dd>The ID of the Evernote Business account that the user is a member of.
    <dt>businessName</dt>
      <dd>The human-readable name of the Evernote Business account that the user
          is a member of.</dd>
    <dt>role</dt>
      <dd>The role of the user within the Evernote Business account that
          they are a member of.</dd>
    <dt>email</dt>
      <dd>An e-mail address that will be used by the service in the context of your
          Evernote Business activities.  For example, this e-mail address will be used
          when you e-mail a business note, when you update notes in the account of
          your business, etc.  The business e-mail cannot be used for identification
          purposes such as for logging into the service.
      </dd>
    <dt>updated</dt>
      <dd>Last time the business user or business user attributes were updated.</dd>
    </dl>

    Attributes:
     - businessId
     - businessName
     - role
     - email
     - updated

    """
    thrift_spec: typing.Any = None


    def __init__(self, businessId: typing.Optional[int] = None, businessName: typing.Optional[str] = None, role: typing.Optional[BusinessUserRole] = None, email: typing.Optional[str] = None, updated: typing.Optional[int] = None,):
        self.businessId: typing.Optional[int] = businessId
        self.businessName: typing.Optional[str] = businessName
        self.role: typing.Optional[BusinessUserRole] = role
        self.email: typing.Optional[str] = email
        self.updated: typing.Optional[int] = updated

    def __setattr__(self, name, value):
        if name == "role":
            super().__setattr__(name, value if hasattr(value, 'value') else BusinessUserRole.__members__.get(value))
            return
        super().__setattr__(name, value)


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.businessId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.businessName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.role = BusinessUserRole(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.email = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.updated = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BusinessUserInfo')
        if self.businessId is not None:
            oprot.writeFieldBegin('businessId', TType.I32, 1)
            oprot.writeI32(self.businessId)
            oprot.writeFieldEnd()
        if self.businessName is not None:
            oprot.writeFieldBegin('businessName', TType.STRING, 2)
            oprot.writeString(self.businessName.encode('utf-8') if sys.version_info[0] == 2 else self.businessName)
            oprot.writeFieldEnd()
        if self.role is not None:
            oprot.writeFieldBegin('role', TType.I32, 3)
            oprot.writeI32(self.role.value)
            oprot.writeFieldEnd()
        if self.email is not None:
            oprot.writeFieldBegin('email', TType.STRING, 4)
            oprot.writeString(self.email.encode('utf-8') if sys.version_info[0] == 2 else self.email)
            oprot.writeFieldEnd()
        if self.updated is not None:
            oprot.writeFieldBegin('updated', TType.I64, 5)
            oprot.writeI64(self.updated)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AccountLimits(object):
    """
     This structure is used to provide account limits that are in effect for this user.
    <dl>
     <dt>userMailLimitDaily</dt>
       <dd>The number of emails of any type that can be sent by a user from the
           service per day.  If an email is sent to two different recipients, this
           counts as two emails.
       </dd>
     <dt>noteSizeMax</dt>
       <dd>Maximum total size of a Note that can be added.  The size of a note is
           calculated as:
           ENML content length (in Unicode characters) plus the sum of all resource
           sizes (in bytes).
       </dd>
     <dt>resourceSizeMax</dt>
       <dd>Maximum size of a resource, in bytes
       </dd>
     <dt>userLinkedNotebookMax</dt>
       <dd>Maximum number of linked notebooks per account.
       </dd>
     <dt>uploadLimit</dt>
       <dd>The number of bytes that can be uploaded to the account
       in the current month.  For new notes that are created, this is the length
       of the note content (in Unicode characters) plus the size of each resource
       (in bytes).  For edited notes, this is the the difference between the old
       length and the new length (if this is greater than 0) plus the size of
       each new resource.
       </dd>
     <dt>userNoteCountMax</dt>
       <dd>Maximum number of Notes per user</dd>
     <dt>userNotebookCountMax</dt>
       <dd>Maximum number of Notebooks per user</dd>
     <dt>userTagCountMax</dt>
       <dd>Maximum number of Tags per account</dd>
     <dt>noteTagCountMax</dt>
       <dd>Maximum number of Tags per Note</dd>
     <dt>userSavedSearchesMax</dt>
       <dd>Maximum number of SavedSearches per account</dd>
     <dt>noteResourceCountMax</dt>
       <dd>The maximum number of Resources per Note</dd>
     </dl>

    Attributes:
     - userMailLimitDaily
     - noteSizeMax
     - resourceSizeMax
     - userLinkedNotebookMax
     - uploadLimit
     - userNoteCountMax
     - userNotebookCountMax
     - userTagCountMax
     - noteTagCountMax
     - userSavedSearchesMax
     - noteResourceCountMax

    """
    thrift_spec: typing.Any = None


    def __init__(self, userMailLimitDaily: typing.Optional[int] = None, noteSizeMax: typing.Optional[int] = None, resourceSizeMax: typing.Optional[int] = None, userLinkedNotebookMax: typing.Optional[int] = None, uploadLimit: typing.Optional[int] = None, userNoteCountMax: typing.Optional[int] = None, userNotebookCountMax: typing.Optional[int] = None, userTagCountMax: typing.Optional[int] = None, noteTagCountMax: typing.Optional[int] = None, userSavedSearchesMax: typing.Optional[int] = None, noteResourceCountMax: typing.Optional[int] = None,):
        self.userMailLimitDaily: typing.Optional[int] = userMailLimitDaily
        self.noteSizeMax: typing.Optional[int] = noteSizeMax
        self.resourceSizeMax: typing.Optional[int] = resourceSizeMax
        self.userLinkedNotebookMax: typing.Optional[int] = userLinkedNotebookMax
        self.uploadLimit: typing.Optional[int] = uploadLimit
        self.userNoteCountMax: typing.Optional[int] = userNoteCountMax
        self.userNotebookCountMax: typing.Optional[int] = userNotebookCountMax
        self.userTagCountMax: typing.Optional[int] = userTagCountMax
        self.noteTagCountMax: typing.Optional[int] = noteTagCountMax
        self.userSavedSearchesMax: typing.Optional[int] = userSavedSearchesMax
        self.noteResourceCountMax: typing.Optional[int] = noteResourceCountMax

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.userMailLimitDaily = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.noteSizeMax = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.resourceSizeMax = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.userLinkedNotebookMax = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.uploadLimit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.userNoteCountMax = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.userNotebookCountMax = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.userTagCountMax = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.noteTagCountMax = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.userSavedSearchesMax = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.noteResourceCountMax = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AccountLimits')
        if self.userMailLimitDaily is not None:
            oprot.writeFieldBegin('userMailLimitDaily', TType.I32, 1)
            oprot.writeI32(self.userMailLimitDaily)
            oprot.writeFieldEnd()
        if self.noteSizeMax is not None:
            oprot.writeFieldBegin('noteSizeMax', TType.I64, 2)
            oprot.writeI64(self.noteSizeMax)
            oprot.writeFieldEnd()
        if self.resourceSizeMax is not None:
            oprot.writeFieldBegin('resourceSizeMax', TType.I64, 3)
            oprot.writeI64(self.resourceSizeMax)
            oprot.writeFieldEnd()
        if self.userLinkedNotebookMax is not None:
            oprot.writeFieldBegin('userLinkedNotebookMax', TType.I32, 4)
            oprot.writeI32(self.userLinkedNotebookMax)
            oprot.writeFieldEnd()
        if self.uploadLimit is not None:
            oprot.writeFieldBegin('uploadLimit', TType.I64, 5)
            oprot.writeI64(self.uploadLimit)
            oprot.writeFieldEnd()
        if self.userNoteCountMax is not None:
            oprot.writeFieldBegin('userNoteCountMax', TType.I32, 6)
            oprot.writeI32(self.userNoteCountMax)
            oprot.writeFieldEnd()
        if self.userNotebookCountMax is not None:
            oprot.writeFieldBegin('userNotebookCountMax', TType.I32, 7)
            oprot.writeI32(self.userNotebookCountMax)
            oprot.writeFieldEnd()
        if self.userTagCountMax is not None:
            oprot.writeFieldBegin('userTagCountMax', TType.I32, 8)
            oprot.writeI32(self.userTagCountMax)
            oprot.writeFieldEnd()
        if self.noteTagCountMax is not None:
            oprot.writeFieldBegin('noteTagCountMax', TType.I32, 9)
            oprot.writeI32(self.noteTagCountMax)
            oprot.writeFieldEnd()
        if self.userSavedSearchesMax is not None:
            oprot.writeFieldBegin('userSavedSearchesMax', TType.I32, 10)
            oprot.writeI32(self.userSavedSearchesMax)
            oprot.writeFieldEnd()
        if self.noteResourceCountMax is not None:
            oprot.writeFieldBegin('noteResourceCountMax', TType.I32, 11)
            oprot.writeI32(self.noteResourceCountMax)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class User(object):
    """
     This represents the information about a single user account.
    <dl>
     <dt>id</dt>
       <dd>The unique numeric identifier for the account, which will not
       change for the lifetime of the account.
       </dd>

     <dt>username</dt>
       <dd>The name that uniquely identifies a single user account. This name
       may be presented by the user, along with their password, to log into
       their account.
       May only contain a-z, 0-9, or '-', and may not start or end with the '-'
       <br/>
       Length:  EDAM_USER_USERNAME_LEN_MIN - EDAM_USER_USERNAME_LEN_MAX
       <br/>
       Regex:  EDAM_USER_USERNAME_REGEX
       </dd>

     <dt>email</dt>
       <dd>The email address registered for the user.  Must comply with
       RFC 2821 and RFC 2822.<br/>
       Third party applications that authenticate using OAuth do not have
       access to this field.
       Length:  EDAM_EMAIL_LEN_MIN - EDAM_EMAIL_LEN_MAX
       <br/>
       Regex:  EDAM_EMAIL_REGEX
       </dd>

     <dt>name</dt>
       <dd>The printable name of the user, which may be a combination
       of given and family names.  This is used instead of separate "first"
       and "last" names due to variations in international name format/order.
       May not start or end with a whitespace character.  May contain any
       character but carriage return or newline (Unicode classes Zl and Zp).
       <br/>
       Length:  EDAM_USER_NAME_LEN_MIN - EDAM_USER_NAME_LEN_MAX
       <br/>
       Regex:  EDAM_USER_NAME_REGEX
       </dd>

     <dt>timezone</dt>
       <dd>The zone ID for the user's default location.  If present,
       this may be used to localize the display of any timestamp for which no
       other timezone is available.
       The format must be encoded as a standard zone ID such as
       "America/Los_Angeles" or "GMT+08:00"
       <br/>
       Length:  EDAM_TIMEZONE_LEN_MIN - EDAM_TIMEZONE_LEN_MAX
       <br/>
       Regex:  EDAM_TIMEZONE_REGEX
       </dd>

     <dt>serviceLevel</dt>
       <dd>The level of service the user currently receives. This will always be populated
           for users retrieved from the Evernote service.
       </dd>

     <dt>created</dt>
       <dd>The date and time when this user account was created in the
       service.
       </dd>

     <dt>updated</dt>
       <dd>The date and time when this user account was last modified
       in the service.
       </dd>

     <dt>deleted</dt>
       <dd>If the account has been deleted from the system (e.g. as
       the result of a legal request by the user), the date and time of the
       deletion will be represented here.  If not, this value will not be set.
       </dd>

     <dt>active</dt>
       <dd>If the user account is available for login and
       synchronization, this flag will be set to true.
       </dd>

     <dt>shardId</dt>
       <dd>DEPRECATED - Client applications should have no need to use this field.
       </dd>

     <dt>attributes</dt>
       <dd>If present, this will contain a list of the attributes
       for this user account.
       </dd>

     <dt>accounting</dt>
       <dd>Bookkeeping information for the user's subscription.
       </dd>

     <dt>businessUserInfo</dt>
       <dd>If present, this will contain a set of business information
       relating to the user's business membership.  If not present, the
       user is not currently part of a business.
       </dd>

     <dt>photoUrl</dt>
       <dd>The URL of the photo that represents this User. This field is filled in by the
       service and is read-only to clients. If <code>photoLastUpdated</code> is
       not set, this url will point to a placeholder user photo generated by the
       service.</dd>

     <dt>photoLastUpdated</dt>
       <dd>The time at which the photo at 'photoUrl' was last updated by this User. This
       field will be null if the User never set a profile photo. This field is filled in by
       the service and is read-only to clients.</dd>

     <dt>accountLimits</dt>
       <dd>Account limits applicable for this user.</dd>

    Attributes:
     - id
     - username
     - email
     - name
     - timezone
     - privilege
     - serviceLevel
     - created
     - updated
     - deleted
     - active
     - shardId
     - attributes
     - accounting
     - businessUserInfo
     - photoUrl
     - photoLastUpdated
     - accountLimits

    """
    thrift_spec: typing.Any = None


    def __init__(self, id: typing.Optional[int] = None, username: typing.Optional[str] = None, email: typing.Optional[str] = None, name: typing.Optional[str] = None, timezone: typing.Optional[str] = None, privilege: typing.Optional[PrivilegeLevel] = None, serviceLevel: typing.Optional[ServiceLevel] = None, created: typing.Optional[int] = None, updated: typing.Optional[int] = None, deleted: typing.Optional[int] = None, active: typing.Optional[bool] = None, shardId: typing.Optional[str] = None, attributes: typing.Optional[UserAttributes] = None, accounting: typing.Optional[Accounting] = None, businessUserInfo: typing.Optional[BusinessUserInfo] = None, photoUrl: typing.Optional[str] = None, photoLastUpdated: typing.Optional[int] = None, accountLimits: typing.Optional[AccountLimits] = None,):
        self.id: typing.Optional[int] = id
        self.username: typing.Optional[str] = username
        self.email: typing.Optional[str] = email
        self.name: typing.Optional[str] = name
        self.timezone: typing.Optional[str] = timezone
        self.privilege: typing.Optional[PrivilegeLevel] = privilege
        self.serviceLevel: typing.Optional[ServiceLevel] = serviceLevel
        self.created: typing.Optional[int] = created
        self.updated: typing.Optional[int] = updated
        self.deleted: typing.Optional[int] = deleted
        self.active: typing.Optional[bool] = active
        self.shardId: typing.Optional[str] = shardId
        self.attributes: typing.Optional[UserAttributes] = attributes
        self.accounting: typing.Optional[Accounting] = accounting
        self.businessUserInfo: typing.Optional[BusinessUserInfo] = businessUserInfo
        self.photoUrl: typing.Optional[str] = photoUrl
        self.photoLastUpdated: typing.Optional[int] = photoLastUpdated
        self.accountLimits: typing.Optional[AccountLimits] = accountLimits

    def __setattr__(self, name, value):
        if name == "privilege":
            super().__setattr__(name, value if hasattr(value, 'value') else PrivilegeLevel.__members__.get(value))
            return
        if name == "serviceLevel":
            super().__setattr__(name, value if hasattr(value, 'value') else ServiceLevel.__members__.get(value))
            return
        super().__setattr__(name, value)


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.email = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.timezone = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.privilege = PrivilegeLevel(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.I32:
                    self.serviceLevel = ServiceLevel(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.created = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I64:
                    self.updated = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I64:
                    self.deleted = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.BOOL:
                    self.active = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.STRING:
                    self.shardId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.STRUCT:
                    self.attributes = UserAttributes()
                    self.attributes.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.STRUCT:
                    self.accounting = Accounting()
                    self.accounting.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.STRUCT:
                    self.businessUserInfo = BusinessUserInfo()
                    self.businessUserInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.STRING:
                    self.photoUrl = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.I64:
                    self.photoLastUpdated = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.STRUCT:
                    self.accountLimits = AccountLimits()
                    self.accountLimits.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('User')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I32, 1)
            oprot.writeI32(self.id)
            oprot.writeFieldEnd()
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 2)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        if self.email is not None:
            oprot.writeFieldBegin('email', TType.STRING, 3)
            oprot.writeString(self.email.encode('utf-8') if sys.version_info[0] == 2 else self.email)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 4)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.timezone is not None:
            oprot.writeFieldBegin('timezone', TType.STRING, 6)
            oprot.writeString(self.timezone.encode('utf-8') if sys.version_info[0] == 2 else self.timezone)
            oprot.writeFieldEnd()
        if self.privilege is not None:
            oprot.writeFieldBegin('privilege', TType.I32, 7)
            oprot.writeI32(self.privilege.value)
            oprot.writeFieldEnd()
        if self.created is not None:
            oprot.writeFieldBegin('created', TType.I64, 9)
            oprot.writeI64(self.created)
            oprot.writeFieldEnd()
        if self.updated is not None:
            oprot.writeFieldBegin('updated', TType.I64, 10)
            oprot.writeI64(self.updated)
            oprot.writeFieldEnd()
        if self.deleted is not None:
            oprot.writeFieldBegin('deleted', TType.I64, 11)
            oprot.writeI64(self.deleted)
            oprot.writeFieldEnd()
        if self.active is not None:
            oprot.writeFieldBegin('active', TType.BOOL, 13)
            oprot.writeBool(self.active)
            oprot.writeFieldEnd()
        if self.shardId is not None:
            oprot.writeFieldBegin('shardId', TType.STRING, 14)
            oprot.writeString(self.shardId.encode('utf-8') if sys.version_info[0] == 2 else self.shardId)
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.STRUCT, 15)
            self.attributes.write(oprot)
            oprot.writeFieldEnd()
        if self.accounting is not None:
            oprot.writeFieldBegin('accounting', TType.STRUCT, 16)
            self.accounting.write(oprot)
            oprot.writeFieldEnd()
        if self.businessUserInfo is not None:
            oprot.writeFieldBegin('businessUserInfo', TType.STRUCT, 18)
            self.businessUserInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.photoUrl is not None:
            oprot.writeFieldBegin('photoUrl', TType.STRING, 19)
            oprot.writeString(self.photoUrl.encode('utf-8') if sys.version_info[0] == 2 else self.photoUrl)
            oprot.writeFieldEnd()
        if self.photoLastUpdated is not None:
            oprot.writeFieldBegin('photoLastUpdated', TType.I64, 20)
            oprot.writeI64(self.photoLastUpdated)
            oprot.writeFieldEnd()
        if self.serviceLevel is not None:
            oprot.writeFieldBegin('serviceLevel', TType.I32, 21)
            oprot.writeI32(self.serviceLevel.value)
            oprot.writeFieldEnd()
        if self.accountLimits is not None:
            oprot.writeFieldBegin('accountLimits', TType.STRUCT, 22)
            self.accountLimits.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Contact(object):
    """
    A structure that represents contact information. Note this does not necessarily correspond to
    an Evernote user.

    <dl>
    <dt>name</dt>
    <dd>The displayable name of this contact. This field is filled in by the service and
        is read-only to clients.
    </dd>
    <dt>id</dt>
    <dd>A unique identifier for this ContactType.
    </dd>
    <dt>type</dt>
    <dd>What service does this contact come from?
    </dd>
    <dt>photoUrl</dt>
    <dd>A URL of a profile photo representing this Contact. This field is filled in by the
        service and is read-only to clients.
    </dd>
    <dt>photoLastUpdated</dt>
    <dd>timestamp when the profile photo at 'photoUrl' was last updated.
        This field will be null if the user has never set a profile photo.
        This field is filled in by the service and is read-only to clients.
    </dd>
    <dt>messagingPermit</dt>
    <dd>This field will only be filled by the service when it is giving a Contact record
        to a client, and that client does not normally have enough permission to send a
        new message to the person represented through this Contact. In that case, this
        whole Contact record could be used to send a new Message to the Contact, and the
        service will inspect this permit to confirm that operation was allowed.
    </dd>
    <dt>messagingPermitExpires</dt>
    <dd>If this field is set, then this (whole) Contact record may be used in calls to
        sendMessage until this time. After that time, those calls may be rejected by the
        service if the caller does not have direct permission to initiate a message with
        the represented Evernote user.
    </dd>
    </dl>

    Attributes:
     - name
     - id
     - type
     - photoUrl
     - photoLastUpdated
     - messagingPermit
     - messagingPermitExpires

    """
    thrift_spec: typing.Any = None


    def __init__(self, name: typing.Optional[str] = None, id: typing.Optional[str] = None, type: typing.Optional[ContactType] = None, photoUrl: typing.Optional[str] = None, photoLastUpdated: typing.Optional[int] = None, messagingPermit: typing.Optional[bytes] = None, messagingPermitExpires: typing.Optional[int] = None,):
        self.name: typing.Optional[str] = name
        self.id: typing.Optional[str] = id
        self.type: typing.Optional[ContactType] = type
        self.photoUrl: typing.Optional[str] = photoUrl
        self.photoLastUpdated: typing.Optional[int] = photoLastUpdated
        self.messagingPermit: typing.Optional[bytes] = messagingPermit
        self.messagingPermitExpires: typing.Optional[int] = messagingPermitExpires

    def __setattr__(self, name, value):
        if name == "type":
            super().__setattr__(name, value if hasattr(value, 'value') else ContactType.__members__.get(value))
            return
        super().__setattr__(name, value)


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.type = ContactType(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.photoUrl = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.photoLastUpdated = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.messagingPermit = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.messagingPermitExpires = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Contact')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 2)
            oprot.writeString(self.id.encode('utf-8') if sys.version_info[0] == 2 else self.id)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 3)
            oprot.writeI32(self.type.value)
            oprot.writeFieldEnd()
        if self.photoUrl is not None:
            oprot.writeFieldBegin('photoUrl', TType.STRING, 4)
            oprot.writeString(self.photoUrl.encode('utf-8') if sys.version_info[0] == 2 else self.photoUrl)
            oprot.writeFieldEnd()
        if self.photoLastUpdated is not None:
            oprot.writeFieldBegin('photoLastUpdated', TType.I64, 5)
            oprot.writeI64(self.photoLastUpdated)
            oprot.writeFieldEnd()
        if self.messagingPermit is not None:
            oprot.writeFieldBegin('messagingPermit', TType.STRING, 6)
            oprot.writeBinary(self.messagingPermit)
            oprot.writeFieldEnd()
        if self.messagingPermitExpires is not None:
            oprot.writeFieldBegin('messagingPermitExpires', TType.I64, 7)
            oprot.writeI64(self.messagingPermitExpires)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Identity(object):
    """
    An object that represents the relationship between a Contact that possibly
    belongs to an Evernote User.

    <dl>
     <dt>id</dt>
     <dd>The unique identifier for this mapping.
     </dd>

     <dt>contact<dt>
     <dd>The Contact that can be used to address this Identity. May be unset.
     </dd>

     <dt>userId</dt>
     <dd>The Evernote User id that is connected to the Contact. May be unset
         if this identity has not yet been claimed, or the caller is not
         connected to this identity.
     </dd>

     <dt>deactivated</dt>
     <dd>Indicates that the contact for this identity is no longer active and
     should not be used when creating new threads using Destination.recipients,
     unless you know of another Identity instance with the same contact information
     that is active.  If you are connected to the user (see userConnected), you
     can still create threads using their Evernote-type contact.</dd>

     <dt>sameBusiness</dt>
     <dd>Does this Identity belong to someone who is in the same business as the
         caller?
     </dd>

     <dt>blocked</dt>
     <dd>Has the caller blocked the Evernote user this Identity represents?
     </dd>

     <dt>userConnected</dt>
     <dd>Indicates that the caller is "connected" to the user of this
     identity via this identity.  When you have a connection via an
     identity, you should always create new threads using the
     Evernote-type contact (see ContactType) using the userId field
     from a connected Identity.  On the Evernote service, the
     Evernote-type contact is the most durable. Phone numbers and
     e-mail addresses can get re-assigned but your Evernote account
     user ID will remain the same.  A connection exists when both of
     you are in the same business or the user has replied to a thread
     that you are on.  When connected, you will also get to see more
     information about the user who has claimed the identity.  Note
     that you are never connected to yourself since you won't be
     sending messages to yourself, but you will obviously see your own
     profile information.
     </dd>

     <dt>eventId</dt>
     <dd>A server-assigned sequence number for the events in the messages
     subsystem.
     </dd>
    </dl>

    Attributes:
     - id
     - contact
     - userId
     - deactivated
     - sameBusiness
     - blocked
     - userConnected
     - eventId

    """
    thrift_spec: typing.Any = None


    def __init__(self, id: int = None, contact: typing.Optional[Contact] = None, userId: typing.Optional[int] = None, deactivated: typing.Optional[bool] = None, sameBusiness: typing.Optional[bool] = None, blocked: typing.Optional[bool] = None, userConnected: typing.Optional[bool] = None, eventId: typing.Optional[int] = None,):
        self.id: int = id
        self.contact: typing.Optional[Contact] = contact
        self.userId: typing.Optional[int] = userId
        self.deactivated: typing.Optional[bool] = deactivated
        self.sameBusiness: typing.Optional[bool] = sameBusiness
        self.blocked: typing.Optional[bool] = blocked
        self.userConnected: typing.Optional[bool] = userConnected
        self.eventId: typing.Optional[int] = eventId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.contact = Contact()
                    self.contact.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.userId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.deactivated = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.sameBusiness = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.blocked = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.userConnected = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.eventId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Identity')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.contact is not None:
            oprot.writeFieldBegin('contact', TType.STRUCT, 2)
            self.contact.write(oprot)
            oprot.writeFieldEnd()
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.I32, 3)
            oprot.writeI32(self.userId)
            oprot.writeFieldEnd()
        if self.deactivated is not None:
            oprot.writeFieldBegin('deactivated', TType.BOOL, 4)
            oprot.writeBool(self.deactivated)
            oprot.writeFieldEnd()
        if self.sameBusiness is not None:
            oprot.writeFieldBegin('sameBusiness', TType.BOOL, 5)
            oprot.writeBool(self.sameBusiness)
            oprot.writeFieldEnd()
        if self.blocked is not None:
            oprot.writeFieldBegin('blocked', TType.BOOL, 6)
            oprot.writeBool(self.blocked)
            oprot.writeFieldEnd()
        if self.userConnected is not None:
            oprot.writeFieldBegin('userConnected', TType.BOOL, 7)
            oprot.writeBool(self.userConnected)
            oprot.writeFieldEnd()
        if self.eventId is not None:
            oprot.writeFieldBegin('eventId', TType.I64, 8)
            oprot.writeI64(self.eventId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Tag(object):
    """
     A tag within a user's account is a unique name which may be organized
     a simple hierarchy.
    <dl>
     <dt>guid</dt>
       <dd>The unique identifier of this tag. Will be set by the service,
       so may be omitted by the client when creating the Tag.
       <br/>
       Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
       <br/>
       Regex:  EDAM_GUID_REGEX
       </dd>

     <dt>name</dt>
       <dd>A sequence of characters representing the tag's identifier.
       Case is preserved, but is ignored for comparisons.
       This means that an account may only have one tag with a given name, via
       case-insensitive comparison, so an account may not have both "food" and
       "Food" tags.
       May not contain a comma (','), and may not begin or end with a space.
       <br/>
       Length:  EDAM_TAG_NAME_LEN_MIN - EDAM_TAG_NAME_LEN_MAX
       <br/>
       Regex:  EDAM_TAG_NAME_REGEX
       </dd>

     <dt>parentGuid</dt>
       <dd>If this is set, then this is the GUID of the tag that
       holds this tag within the tag organizational hierarchy.  If this is
       not set, then the tag has no parent and it is a "top level" tag.
       Cycles are not allowed (e.g. a->parent->parent == a) and will be
       rejected by the service.
       <br/>
       Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
       <br/>
       Regex:  EDAM_GUID_REGEX
       </dd>

     <dt>updateSequenceNum</dt>
       <dd>A number identifying the last transaction to
       modify the state of this object.  The USN values are sequential within an
       account, and can be used to compare the order of modifications within the
       service.
       </dd>
     </dl>

    Attributes:
     - guid
     - name
     - parentGuid
     - updateSequenceNum

    """
    thrift_spec: typing.Any = None


    def __init__(self, guid: typing.Optional[str] = None, name: typing.Optional[str] = None, parentGuid: typing.Optional[str] = None, updateSequenceNum: typing.Optional[int] = None,):
        self.guid: typing.Optional[str] = guid
        self.name: typing.Optional[str] = name
        self.parentGuid: typing.Optional[str] = parentGuid
        self.updateSequenceNum: typing.Optional[int] = updateSequenceNum

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.parentGuid = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.updateSequenceNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Tag')
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 1)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.parentGuid is not None:
            oprot.writeFieldBegin('parentGuid', TType.STRING, 3)
            oprot.writeString(self.parentGuid.encode('utf-8') if sys.version_info[0] == 2 else self.parentGuid)
            oprot.writeFieldEnd()
        if self.updateSequenceNum is not None:
            oprot.writeFieldBegin('updateSequenceNum', TType.I32, 4)
            oprot.writeI32(self.updateSequenceNum)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LazyMap(object):
    """
    A structure that wraps a map of name/value pairs whose values are not
    always present in the structure in order to reduce space when obtaining
    batches of entities that contain the map.

    When the server provides the client with a LazyMap, it will fill in either
    the keysOnly field or the fullMap field, but never both, based on the API
    and parameters.

    When a client provides a LazyMap to the server as part of an update to
    an object, the server will only update the LazyMap if the fullMap field is
    set. If the fullMap field is not set, the server will not make any changes
    to the map.

    Check the API documentation of the individual calls involving the LazyMap
    for full details including the constraints of the names and values of the
    map.

    <dl>
    <dt>keysOnly</dt>
      <dd>The set of keys for the map.  This field is ignored by the
          server when set.
      </dd>

    <dt>fullMap</dt>
      <dd>The complete map, including all keys and values.
      </dd>
    </dl>

    Attributes:
     - keysOnly
     - fullMap

    """
    thrift_spec: typing.Any = None


    def __init__(self, keysOnly: typing.Optional[set[str]] = None, fullMap: typing.Optional[dict[str, str]] = None,):
        self.keysOnly: typing.Optional[set[str]] = keysOnly
        self.fullMap: typing.Optional[dict[str, str]] = fullMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.SET:
                    self.keysOnly = set()
                    (_etype17, _size14) = iprot.readSetBegin()
                    for _i18 in range(_size14):
                        _elem19 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.keysOnly.add(_elem19)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.fullMap = {}
                    (_ktype21, _vtype22, _size20) = iprot.readMapBegin()
                    for _i24 in range(_size20):
                        _key25 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val26 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.fullMap[_key25] = _val26
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LazyMap')
        if self.keysOnly is not None:
            oprot.writeFieldBegin('keysOnly', TType.SET, 1)
            oprot.writeSetBegin(TType.STRING, len(self.keysOnly))
            for iter27 in self.keysOnly:
                oprot.writeString(iter27.encode('utf-8') if sys.version_info[0] == 2 else iter27)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.fullMap is not None:
            oprot.writeFieldBegin('fullMap', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.fullMap))
            for kiter28, viter29 in self.fullMap.items():
                oprot.writeString(kiter28.encode('utf-8') if sys.version_info[0] == 2 else kiter28)
                oprot.writeString(viter29.encode('utf-8') if sys.version_info[0] == 2 else viter29)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ResourceAttributes(object):
    """
    Structure holding the optional attributes of a Resource
    <dl>
    <dt>sourceURL</dt>
      <dd>the original location where the resource was hosted
      <br/>
       Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
      </dd>

    <dt>timestamp</dt>
      <dd>the date and time that is associated with this resource
      (e.g. the time embedded in an image from a digital camera with a clock)
      </dd>

    <dt>latitude</dt>
      <dd>the latitude where the resource was captured
      </dd>

    <dt>longitude</dt>
      <dd>the longitude where the resource was captured
      </dd>

    <dt>altitude</dt>
      <dd>the altitude where the resource was captured
      </dd>

    <dt>cameraMake</dt>
      <dd>information about an image's camera, e.g. as embedded in
      the image's EXIF data
      <br/>
      Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
      </dd>

    <dt>cameraModel</dt>
      <dd>information about an image's camera, e.g. as embedded
      in the image's EXIF data
      <br/>
      Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
      </dd>

    <dt>clientWillIndex</dt>
      <dd>if true, then the original client that submitted
      the resource plans to submit the recognition index for this resource at a
      later time.
      </dd>

    <dt>recoType</dt>
      <dd>DEPRECATED - this field is no longer set by the service, so should
        be ignored.
      </dd>

    <dt>fileName</dt>
      <dd>if the resource came from a source that provided an
      explicit file name, the original name will be stored here.  Many resources
      come from unnamed sources, so this will not always be set.
      </dd>

    <dt>attachment</dt>
      <dd>this will be true if the resource should be displayed as an attachment,
      or false if the resource should be displayed inline (if possible).
      </dd>

    <dt>applicationData</dt>
    <dd>Provides a location for applications to store a relatively small
    (4kb) blob of data associated with a Resource that is not visible to the user
    and that is opaque to the Evernote service. A single application may use at most
    one entry in this map, using its API consumer key as the map key. See the
    documentation for LazyMap for a description of when the actual map values
    are returned by the service.
    <p>To safely add or modify your application's entry in the map, use
    NoteStore.setResourceApplicationDataEntry. To safely remove your application's
    entry from the map, use NoteStore.unsetResourceApplicationDataEntry.</p>
    Minimum length of a name (key): EDAM_APPLICATIONDATA_NAME_LEN_MIN
    <br/>
    Sum max size of key and value: EDAM_APPLICATIONDATA_ENTRY_LEN_MAX
    <br/>
    Syntax regex for name (key): EDAM_APPLICATIONDATA_NAME_REGEX
    </dd>

    </dl>

    Attributes:
     - sourceURL
     - timestamp
     - latitude
     - longitude
     - altitude
     - cameraMake
     - cameraModel
     - clientWillIndex
     - recoType
     - fileName
     - attachment
     - applicationData

    """
    thrift_spec: typing.Any = None


    def __init__(self, sourceURL: typing.Optional[str] = None, timestamp: typing.Optional[int] = None, latitude: typing.Optional[float] = None, longitude: typing.Optional[float] = None, altitude: typing.Optional[float] = None, cameraMake: typing.Optional[str] = None, cameraModel: typing.Optional[str] = None, clientWillIndex: typing.Optional[bool] = None, recoType: typing.Optional[str] = None, fileName: typing.Optional[str] = None, attachment: typing.Optional[bool] = None, applicationData: typing.Optional[LazyMap] = None,):
        self.sourceURL: typing.Optional[str] = sourceURL
        self.timestamp: typing.Optional[int] = timestamp
        self.latitude: typing.Optional[float] = latitude
        self.longitude: typing.Optional[float] = longitude
        self.altitude: typing.Optional[float] = altitude
        self.cameraMake: typing.Optional[str] = cameraMake
        self.cameraModel: typing.Optional[str] = cameraModel
        self.clientWillIndex: typing.Optional[bool] = clientWillIndex
        self.recoType: typing.Optional[str] = recoType
        self.fileName: typing.Optional[str] = fileName
        self.attachment: typing.Optional[bool] = attachment
        self.applicationData: typing.Optional[LazyMap] = applicationData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sourceURL = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.latitude = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.longitude = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.altitude = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.cameraMake = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.cameraModel = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.clientWillIndex = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.recoType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.fileName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.BOOL:
                    self.attachment = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRUCT:
                    self.applicationData = LazyMap()
                    self.applicationData.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ResourceAttributes')
        if self.sourceURL is not None:
            oprot.writeFieldBegin('sourceURL', TType.STRING, 1)
            oprot.writeString(self.sourceURL.encode('utf-8') if sys.version_info[0] == 2 else self.sourceURL)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 2)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.latitude is not None:
            oprot.writeFieldBegin('latitude', TType.DOUBLE, 3)
            oprot.writeDouble(self.latitude)
            oprot.writeFieldEnd()
        if self.longitude is not None:
            oprot.writeFieldBegin('longitude', TType.DOUBLE, 4)
            oprot.writeDouble(self.longitude)
            oprot.writeFieldEnd()
        if self.altitude is not None:
            oprot.writeFieldBegin('altitude', TType.DOUBLE, 5)
            oprot.writeDouble(self.altitude)
            oprot.writeFieldEnd()
        if self.cameraMake is not None:
            oprot.writeFieldBegin('cameraMake', TType.STRING, 6)
            oprot.writeString(self.cameraMake.encode('utf-8') if sys.version_info[0] == 2 else self.cameraMake)
            oprot.writeFieldEnd()
        if self.cameraModel is not None:
            oprot.writeFieldBegin('cameraModel', TType.STRING, 7)
            oprot.writeString(self.cameraModel.encode('utf-8') if sys.version_info[0] == 2 else self.cameraModel)
            oprot.writeFieldEnd()
        if self.clientWillIndex is not None:
            oprot.writeFieldBegin('clientWillIndex', TType.BOOL, 8)
            oprot.writeBool(self.clientWillIndex)
            oprot.writeFieldEnd()
        if self.recoType is not None:
            oprot.writeFieldBegin('recoType', TType.STRING, 9)
            oprot.writeString(self.recoType.encode('utf-8') if sys.version_info[0] == 2 else self.recoType)
            oprot.writeFieldEnd()
        if self.fileName is not None:
            oprot.writeFieldBegin('fileName', TType.STRING, 10)
            oprot.writeString(self.fileName.encode('utf-8') if sys.version_info[0] == 2 else self.fileName)
            oprot.writeFieldEnd()
        if self.attachment is not None:
            oprot.writeFieldBegin('attachment', TType.BOOL, 11)
            oprot.writeBool(self.attachment)
            oprot.writeFieldEnd()
        if self.applicationData is not None:
            oprot.writeFieldBegin('applicationData', TType.STRUCT, 12)
            self.applicationData.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Resource(object):
    """
    Every media file that is embedded or attached to a note is represented
    through a Resource entry.
    <dl>
    <dt>guid</dt>
      <dd>The unique identifier of this resource.  Will be set whenever
      a resource is retrieved from the service, but may be null when a client
      is creating a resource.
      <br/>
      Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
      <br/>
      Regex:  EDAM_GUID_REGEX
      </dd>

    <dt>noteGuid</dt>
      <dd>The unique identifier of the Note that holds this
      Resource. Will be set whenever the resource is retrieved from the service,
      but may be null when a client is creating a resource.
      <br/>
      Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
      <br/>
      Regex:  EDAM_GUID_REGEX
      </dd>

    <dt>data</dt>
      <dd>The contents of the resource.
      Maximum length:  The data.body is limited to EDAM_RESOURCE_SIZE_MAX_FREE
      for free accounts and EDAM_RESOURCE_SIZE_MAX_PREMIUM for premium accounts.
      </dd>

    <dt>mime</dt>
      <dd>The MIME type for the embedded resource.  E.g. "image/gif"
      <br/>
      Length:  EDAM_MIME_LEN_MIN - EDAM_MIME_LEN_MAX
      <br/>
      Regex:  EDAM_MIME_REGEX
      </dd>

    <dt>width</dt>
      <dd>If set, this contains the display width of this resource, in
      pixels.
      </dd>

    <dt>height</dt>
      <dd>If set, this contains the display height of this resource,
      in pixels.
      </dd>

    <dt>duration</dt>
      <dd>DEPRECATED: ignored.
      </dd>

    <dt>active</dt>
      <dd>If the resource is active or not.
      </dd>

    <dt>recognition</dt>
      <dd>If set, this will hold the encoded data that provides
      information on search and recognition within this resource.
      </dd>

    <dt>attributes</dt>
      <dd>A list of the attributes for this resource.
      </dd>

    <dt>updateSequenceNum</dt>
      <dd>A number identifying the last transaction to
      modify the state of this object. The USN values are sequential within an
      account, and can be used to compare the order of modifications within the
      service.
      </dd>

    <dt>alternateData</dt>
      <dd>Some Resources may be assigned an alternate data format by the service
      which may be more appropriate for indexing or rendering than the original
      data provided by the user.  In these cases, the alternate data form will
      be available via this Data element.  If a Resource has no alternate form,
      this field will be unset.</dd>
    </dl>

    Attributes:
     - guid
     - noteGuid
     - data
     - mime
     - width
     - height
     - duration
     - active
     - recognition
     - attributes
     - updateSequenceNum
     - alternateData

    """
    thrift_spec: typing.Any = None


    def __init__(self, guid: typing.Optional[str] = None, noteGuid: typing.Optional[str] = None, data: typing.Optional[Data] = None, mime: typing.Optional[str] = None, width: typing.Optional[int] = None, height: typing.Optional[int] = None, duration: typing.Optional[int] = None, active: typing.Optional[bool] = None, recognition: typing.Optional[Data] = None, attributes: typing.Optional[ResourceAttributes] = None, updateSequenceNum: typing.Optional[int] = None, alternateData: typing.Optional[Data] = None,):
        self.guid: typing.Optional[str] = guid
        self.noteGuid: typing.Optional[str] = noteGuid
        self.data: typing.Optional[Data] = data
        self.mime: typing.Optional[str] = mime
        self.width: typing.Optional[int] = width
        self.height: typing.Optional[int] = height
        self.duration: typing.Optional[int] = duration
        self.active: typing.Optional[bool] = active
        self.recognition: typing.Optional[Data] = recognition
        self.attributes: typing.Optional[ResourceAttributes] = attributes
        self.updateSequenceNum: typing.Optional[int] = updateSequenceNum
        self.alternateData: typing.Optional[Data] = alternateData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.noteGuid = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.data = Data()
                    self.data.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.mime = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I16:
                    self.width = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I16:
                    self.height = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I16:
                    self.duration = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.active = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.recognition = Data()
                    self.recognition.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.attributes = ResourceAttributes()
                    self.attributes.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I32:
                    self.updateSequenceNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRUCT:
                    self.alternateData = Data()
                    self.alternateData.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Resource')
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 1)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        if self.noteGuid is not None:
            oprot.writeFieldBegin('noteGuid', TType.STRING, 2)
            oprot.writeString(self.noteGuid.encode('utf-8') if sys.version_info[0] == 2 else self.noteGuid)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRUCT, 3)
            self.data.write(oprot)
            oprot.writeFieldEnd()
        if self.mime is not None:
            oprot.writeFieldBegin('mime', TType.STRING, 4)
            oprot.writeString(self.mime.encode('utf-8') if sys.version_info[0] == 2 else self.mime)
            oprot.writeFieldEnd()
        if self.width is not None:
            oprot.writeFieldBegin('width', TType.I16, 5)
            oprot.writeI16(self.width)
            oprot.writeFieldEnd()
        if self.height is not None:
            oprot.writeFieldBegin('height', TType.I16, 6)
            oprot.writeI16(self.height)
            oprot.writeFieldEnd()
        if self.duration is not None:
            oprot.writeFieldBegin('duration', TType.I16, 7)
            oprot.writeI16(self.duration)
            oprot.writeFieldEnd()
        if self.active is not None:
            oprot.writeFieldBegin('active', TType.BOOL, 8)
            oprot.writeBool(self.active)
            oprot.writeFieldEnd()
        if self.recognition is not None:
            oprot.writeFieldBegin('recognition', TType.STRUCT, 9)
            self.recognition.write(oprot)
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.STRUCT, 11)
            self.attributes.write(oprot)
            oprot.writeFieldEnd()
        if self.updateSequenceNum is not None:
            oprot.writeFieldBegin('updateSequenceNum', TType.I32, 12)
            oprot.writeI32(self.updateSequenceNum)
            oprot.writeFieldEnd()
        if self.alternateData is not None:
            oprot.writeFieldBegin('alternateData', TType.STRUCT, 13)
            self.alternateData.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NoteAttributes(object):
    """
    The list of optional attributes that can be stored on a note.
    <dl>
    <dt>subjectDate</dt>
      <dd>time that the note refers to
      </dd>

    <dt>latitude</dt>
      <dd>the latitude where the note was taken
      </dd>

    <dt>longitude</dt>
      <dd>the longitude where the note was taken
      </dd>

    <dt>altitude</dt>
      <dd>the altitude where the note was taken
      </dd>

    <dt>author</dt>
      <dd>the author of the content of the note
      <br/>
      Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
      </dd>

    <dt>source</dt>
      <dd>the method that the note was added to the account, if the
      note wasn't directly authored in an Evernote desktop client.
      <br/>
      Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
      </dd>

    <dt>sourceURL</dt>
      <dd>the original location where the resource was hosted. For web clips,
      this will be the URL of the page that was clipped.
      <br/>
      Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
      </dd>

    <dt>sourceApplication</dt>
      <dd>an identifying string for the application that
      created this note.  This string does not have a guaranteed syntax or
      structure -- it is intended for human inspection and tracking.
      <br/>
      Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
      </dd>

    <dt>shareDate</dt>
     <dd>The date and time when this note was directly shared via its own URL.
     This is only set on notes that were individually shared - it is independent
     of any notebook-level sharing of the containing notebook. This field
     is treated as "read-only" for clients; the server will ignore changes
     to this field from an external client.
     </dd>

    <dt>reminderOrder</dt>
    <dd>The set of notes with this parameter set are considered
    "reminders" and are to be treated specially by clients to give them
    higher UI prominence within a notebook.  The value is used to sort
    the reminder notes within the notebook with higher values
    representing greater prominence.  Outside of the context of a
    notebook, the value of this parameter is undefined.  The value is
    not intended to be compared to the values of reminder notes in
    other notebooks.  In order to allow clients to place a note at a
    higher precedence than other notes, you should never set a value
    greater than the current time (as defined for a Timetstamp). To
    place a note at higher precedence than existing notes, set the
    value to the current time as defined for a timestamp (milliseconds
    since the epoch).  Synchronizing clients must remember the time when
    the update was performed, using the local clock on the client,
    and use that value when they later upload the note to the service.
    Clients must not set the reminderOrder to the reminderTime as the
    reminderTime could be in the future.  Those two fields are never
    intended to be related.  The correct value for reminderOrder field
    for new notes is the "current" time when the user indicated that
    the note is a reminder.  Clients may implement a separate
    "sort by date" feature to show notes ordered by reminderTime.
    Whenever a reminderDoneTime or reminderTime is set but a
    reminderOrder is not set, the server will fill in the current
    server time for the reminderOrder field.</dd>

    <dt>reminderDoneTime</dt>
    <dd>The date and time when a user dismissed/"marked done" the reminder
    on the note.  Users typically do not manually set this value directly
    as it is set to the time when the user dismissed/"marked done" the
    reminder.</dd>

    <dt>reminderTime</dt>
    <dd>The date and time a user has selected to be reminded of the note.
    A note with this value set is known as a "reminder" and the user can
    be reminded, via e-mail or client-specific notifications, of the note
    when the time is reached or about to be reached.  When a user sets
    a reminder time on a note that has a reminder done time, and that
    reminder time is in the future, then the reminder done time should be
    cleared.  This should happen regardless of any existing reminder time
    that may have previously existed on the note.</dd>

    <dt>placeName</dt>
    <dd>Allows the user to assign a human-readable location name associated
    with a note. Users may assign values like 'Home' and 'Work'. Place
    names may also be populated with values from geonames database
    (e.g., a restaurant name). Applications are encouraged to normalize values
    so that grouping values by place name provides a useful result. Applications
    MUST NOT automatically add place name values based on geolocation without
    confirmation from the user; that is, the value in this field should be
    more useful than a simple automated lookup based on the note's latitude
    and longitude.</dd>

    <dt>contentClass</dt>
    <dd>The class (or type) of note. This field is used to indicate to
    clients that special structured information is represented within
    the note such that special rules apply when making
    modifications. If contentClass is set and the client
    application does not specifically support the specified class,
    the client MUST treat the note as read-only. In this case, the
    client MAY modify the note's notebook and tags via the
    Note.notebookGuid and Note.tagGuids fields.  The client MAY also
    modify the reminderOrder field as well as the reminderTime and
    reminderDoneTime fields.
    <p>Applications should set contentClass only when they are creating notes
    that contain structured information that needs to be maintained in order
    for the user to be able to use the note within that application.
    Setting contentClass makes a note read-only in other applications, so
    there is a trade-off when an application chooses to use contentClass.
    Applications that set contentClass when creating notes must use a contentClass
    string of the form <i>CompanyName.ApplicationName</i> to ensure uniqueness.</p>
    Length restrictions: EDAM_NOTE_CONTENT_CLASS_LEN_MIN, EDAM_NOTE_CONTENT_CLASS_LEN_MAX
    <br/>
    Regex: EDAM_NOTE_CONTENT_CLASS_REGEX
    </dd>

    <dt>applicationData</dt>
    <dd>Provides a location for applications to store a relatively small
    (4kb) blob of data that is not meant to be visible to the user and
    that is opaque to the Evernote service. A single application may use at most
    one entry in this map, using its API consumer key as the map key. See the
    documentation for LazyMap for a description of when the actual map values
    are returned by the service.
    <p>To safely add or modify your application's entry in the map, use
    NoteStore.setNoteApplicationDataEntry. To safely remove your application's
    entry from the map, use NoteStore.unsetNoteApplicationDataEntry.</p>
    Minimum length of a name (key): EDAM_APPLICATIONDATA_NAME_LEN_MIN
    <br/>
    Sum max size of key and value: EDAM_APPLICATIONDATA_ENTRY_LEN_MAX
    <br/>
    Syntax regex for name (key): EDAM_APPLICATIONDATA_NAME_REGEX
    </dd>

    <dt>creatorId</dt>
    <dd>The numeric user ID of the user who originally created the note.</dd>

    <dt>lastEditedBy</dt>
    <dd>An indication of who made the last change to the note.  If you are
    accessing the note via a shared notebook to which you have modification
    rights, or if you are the owner of the notebook to which the note belongs,
    then you have access to the value.  In this case, the value will be
    unset if the owner of the notebook containing the note was the last to
    make the modification, else it will be a string describing the
    guest who made the last edit.  If you do not have access to this value,
    it will be left unset.  This field is read-only by clients.  The server
    will ignore all values set by clients into this field.</dd>

    <dt>lastEditorId</dt>
    <dd>The numeric user ID of the user described in lastEditedBy.</dd>

    <dt>classifications</dt>
    <dd>A map of classifications applied to the note by clients or by the
    Evernote service. The key is the string name of the classification type,
    and the value is a constant that begins with CLASSIFICATION_.</dd>

    <dt>sharedWithBusiness</dt>
    <dd>When this flag is set on a business note, any user in that business
    may view the note if they request it by GUID. This field is read-only by
    clients. The server will ignore all values set by clients into this field.

    To share a note with the business, use NoteStore.shareNoteWithBusiness and
    to stop sharing a note with the business, use NoteStore.stopSharingNoteWithBusiness.
    </dd>

    <dt>conflictSourceNoteGuid</dt>
    <dd>If set, this specifies the GUID of a note that caused a sync conflict
    resulting in the creation of a duplicate note. The duplicated note contains
    the user's changes that could not be applied as a result of the sync conflict,
    and uses the conflictSourceNoteGuid field to specify the note that caused the
    conflict. This allows clients to provide a customized user experience for note
    conflicts.
    </dd>

    <dt>noteTitleQuality</dt>
    <dd>If set, this specifies that the note's title was automatically generated
    and indicates the likelihood that the generated title is useful for display to
    the user. If not set, the note's title was manually entered by the user.

    Clients MUST set this attribute to one of the following values when the
    corresponding note's title was not manually entered by the user:
    EDAM_NOTE_TITLE_QUALITY_UNTITLED, EDAM_NOTE_TITLE_QUALITY_LOW,
    EDAM_NOTE_TITLE_QUALITY_MEDIUM or EDAM_NOTE_TITLE_QUALITY_HIGH.

    When a user edits a note's title, clients MUST unset this value.
    </dd>
    </dl>

    Attributes:
     - subjectDate
     - latitude
     - longitude
     - altitude
     - author
     - source
     - sourceURL
     - sourceApplication
     - shareDate
     - reminderOrder
     - reminderDoneTime
     - reminderTime
     - placeName
     - contentClass
     - applicationData
     - lastEditedBy
     - classifications
     - creatorId
     - lastEditorId
     - sharedWithBusiness
     - conflictSourceNoteGuid
     - noteTitleQuality

    """
    thrift_spec: typing.Any = None


    def __init__(self, subjectDate: typing.Optional[int] = None, latitude: typing.Optional[float] = None, longitude: typing.Optional[float] = None, altitude: typing.Optional[float] = None, author: typing.Optional[str] = None, source: typing.Optional[str] = None, sourceURL: typing.Optional[str] = None, sourceApplication: typing.Optional[str] = None, shareDate: typing.Optional[int] = None, reminderOrder: typing.Optional[int] = None, reminderDoneTime: typing.Optional[int] = None, reminderTime: typing.Optional[int] = None, placeName: typing.Optional[str] = None, contentClass: typing.Optional[str] = None, applicationData: typing.Optional[LazyMap] = None, lastEditedBy: typing.Optional[str] = None, classifications: typing.Optional[dict[str, str]] = None, creatorId: typing.Optional[int] = None, lastEditorId: typing.Optional[int] = None, sharedWithBusiness: typing.Optional[bool] = None, conflictSourceNoteGuid: typing.Optional[str] = None, noteTitleQuality: typing.Optional[int] = None,):
        self.subjectDate: typing.Optional[int] = subjectDate
        self.latitude: typing.Optional[float] = latitude
        self.longitude: typing.Optional[float] = longitude
        self.altitude: typing.Optional[float] = altitude
        self.author: typing.Optional[str] = author
        self.source: typing.Optional[str] = source
        self.sourceURL: typing.Optional[str] = sourceURL
        self.sourceApplication: typing.Optional[str] = sourceApplication
        self.shareDate: typing.Optional[int] = shareDate
        self.reminderOrder: typing.Optional[int] = reminderOrder
        self.reminderDoneTime: typing.Optional[int] = reminderDoneTime
        self.reminderTime: typing.Optional[int] = reminderTime
        self.placeName: typing.Optional[str] = placeName
        self.contentClass: typing.Optional[str] = contentClass
        self.applicationData: typing.Optional[LazyMap] = applicationData
        self.lastEditedBy: typing.Optional[str] = lastEditedBy
        self.classifications: typing.Optional[dict[str, str]] = classifications
        self.creatorId: typing.Optional[int] = creatorId
        self.lastEditorId: typing.Optional[int] = lastEditorId
        self.sharedWithBusiness: typing.Optional[bool] = sharedWithBusiness
        self.conflictSourceNoteGuid: typing.Optional[str] = conflictSourceNoteGuid
        self.noteTitleQuality: typing.Optional[int] = noteTitleQuality

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.subjectDate = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.DOUBLE:
                    self.latitude = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.DOUBLE:
                    self.longitude = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.DOUBLE:
                    self.altitude = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRING:
                    self.author = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.STRING:
                    self.source = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.STRING:
                    self.sourceURL = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.STRING:
                    self.sourceApplication = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.I64:
                    self.shareDate = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.I64:
                    self.reminderOrder = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.I64:
                    self.reminderDoneTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.I64:
                    self.reminderTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.STRING:
                    self.placeName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.STRING:
                    self.contentClass = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 23:
                if ftype == TType.STRUCT:
                    self.applicationData = LazyMap()
                    self.applicationData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 24:
                if ftype == TType.STRING:
                    self.lastEditedBy = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 26:
                if ftype == TType.MAP:
                    self.classifications = {}
                    (_ktype31, _vtype32, _size30) = iprot.readMapBegin()
                    for _i34 in range(_size30):
                        _key35 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val36 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.classifications[_key35] = _val36
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 27:
                if ftype == TType.I32:
                    self.creatorId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 28:
                if ftype == TType.I32:
                    self.lastEditorId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 29:
                if ftype == TType.BOOL:
                    self.sharedWithBusiness = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 30:
                if ftype == TType.STRING:
                    self.conflictSourceNoteGuid = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 31:
                if ftype == TType.I32:
                    self.noteTitleQuality = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NoteAttributes')
        if self.subjectDate is not None:
            oprot.writeFieldBegin('subjectDate', TType.I64, 1)
            oprot.writeI64(self.subjectDate)
            oprot.writeFieldEnd()
        if self.latitude is not None:
            oprot.writeFieldBegin('latitude', TType.DOUBLE, 10)
            oprot.writeDouble(self.latitude)
            oprot.writeFieldEnd()
        if self.longitude is not None:
            oprot.writeFieldBegin('longitude', TType.DOUBLE, 11)
            oprot.writeDouble(self.longitude)
            oprot.writeFieldEnd()
        if self.altitude is not None:
            oprot.writeFieldBegin('altitude', TType.DOUBLE, 12)
            oprot.writeDouble(self.altitude)
            oprot.writeFieldEnd()
        if self.author is not None:
            oprot.writeFieldBegin('author', TType.STRING, 13)
            oprot.writeString(self.author.encode('utf-8') if sys.version_info[0] == 2 else self.author)
            oprot.writeFieldEnd()
        if self.source is not None:
            oprot.writeFieldBegin('source', TType.STRING, 14)
            oprot.writeString(self.source.encode('utf-8') if sys.version_info[0] == 2 else self.source)
            oprot.writeFieldEnd()
        if self.sourceURL is not None:
            oprot.writeFieldBegin('sourceURL', TType.STRING, 15)
            oprot.writeString(self.sourceURL.encode('utf-8') if sys.version_info[0] == 2 else self.sourceURL)
            oprot.writeFieldEnd()
        if self.sourceApplication is not None:
            oprot.writeFieldBegin('sourceApplication', TType.STRING, 16)
            oprot.writeString(self.sourceApplication.encode('utf-8') if sys.version_info[0] == 2 else self.sourceApplication)
            oprot.writeFieldEnd()
        if self.shareDate is not None:
            oprot.writeFieldBegin('shareDate', TType.I64, 17)
            oprot.writeI64(self.shareDate)
            oprot.writeFieldEnd()
        if self.reminderOrder is not None:
            oprot.writeFieldBegin('reminderOrder', TType.I64, 18)
            oprot.writeI64(self.reminderOrder)
            oprot.writeFieldEnd()
        if self.reminderDoneTime is not None:
            oprot.writeFieldBegin('reminderDoneTime', TType.I64, 19)
            oprot.writeI64(self.reminderDoneTime)
            oprot.writeFieldEnd()
        if self.reminderTime is not None:
            oprot.writeFieldBegin('reminderTime', TType.I64, 20)
            oprot.writeI64(self.reminderTime)
            oprot.writeFieldEnd()
        if self.placeName is not None:
            oprot.writeFieldBegin('placeName', TType.STRING, 21)
            oprot.writeString(self.placeName.encode('utf-8') if sys.version_info[0] == 2 else self.placeName)
            oprot.writeFieldEnd()
        if self.contentClass is not None:
            oprot.writeFieldBegin('contentClass', TType.STRING, 22)
            oprot.writeString(self.contentClass.encode('utf-8') if sys.version_info[0] == 2 else self.contentClass)
            oprot.writeFieldEnd()
        if self.applicationData is not None:
            oprot.writeFieldBegin('applicationData', TType.STRUCT, 23)
            self.applicationData.write(oprot)
            oprot.writeFieldEnd()
        if self.lastEditedBy is not None:
            oprot.writeFieldBegin('lastEditedBy', TType.STRING, 24)
            oprot.writeString(self.lastEditedBy.encode('utf-8') if sys.version_info[0] == 2 else self.lastEditedBy)
            oprot.writeFieldEnd()
        if self.classifications is not None:
            oprot.writeFieldBegin('classifications', TType.MAP, 26)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.classifications))
            for kiter37, viter38 in self.classifications.items():
                oprot.writeString(kiter37.encode('utf-8') if sys.version_info[0] == 2 else kiter37)
                oprot.writeString(viter38.encode('utf-8') if sys.version_info[0] == 2 else viter38)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.creatorId is not None:
            oprot.writeFieldBegin('creatorId', TType.I32, 27)
            oprot.writeI32(self.creatorId)
            oprot.writeFieldEnd()
        if self.lastEditorId is not None:
            oprot.writeFieldBegin('lastEditorId', TType.I32, 28)
            oprot.writeI32(self.lastEditorId)
            oprot.writeFieldEnd()
        if self.sharedWithBusiness is not None:
            oprot.writeFieldBegin('sharedWithBusiness', TType.BOOL, 29)
            oprot.writeBool(self.sharedWithBusiness)
            oprot.writeFieldEnd()
        if self.conflictSourceNoteGuid is not None:
            oprot.writeFieldBegin('conflictSourceNoteGuid', TType.STRING, 30)
            oprot.writeString(self.conflictSourceNoteGuid.encode('utf-8') if sys.version_info[0] == 2 else self.conflictSourceNoteGuid)
            oprot.writeFieldEnd()
        if self.noteTitleQuality is not None:
            oprot.writeFieldBegin('noteTitleQuality', TType.I32, 31)
            oprot.writeI32(self.noteTitleQuality)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SharedNote(object):
    """
    Represents a relationship between a note and a single share invitation recipient. The recipient
    is identified via an Identity, and has a given privilege that specifies what actions they may
    take on the note.

    <dl>
      <dt>sharerUserID</dt>
      <dd>The user ID of the user who shared the note with the recipient.</dd>

      <dt>recipientIdentity</dt>
      <dd>The identity of the recipient of the share. For a given note, there may be only one
        SharedNote per recipient identity. Only recipientIdentity.id is guaranteed to be set.
        Other fields on the Identity may or my not be set based on the requesting user's
        relationship with the recipient.</dd>

      <dt>privilege</dt>
      <dd>The privilege level that the share grants to the recipient.</dd>

      <dt>serviceCreated</dt>
      <dd>The time at which the share was created.</dd>

      <dt>serviceUpdated</dt>
      <dd>The time at which the share was last updated.</dd>

      <dt>serviceAssigned</dt>
      <dd>The time at which the share was assigned to a specific recipient user ID.</dd>
    </dl>

    Attributes:
     - sharerUserID
     - recipientIdentity
     - privilege
     - serviceCreated
     - serviceUpdated
     - serviceAssigned

    """
    thrift_spec: typing.Any = None


    def __init__(self, sharerUserID: typing.Optional[int] = None, recipientIdentity: typing.Optional[Identity] = None, privilege: typing.Optional[SharedNotePrivilegeLevel] = None, serviceCreated: typing.Optional[int] = None, serviceUpdated: typing.Optional[int] = None, serviceAssigned: typing.Optional[int] = None,):
        self.sharerUserID: typing.Optional[int] = sharerUserID
        self.recipientIdentity: typing.Optional[Identity] = recipientIdentity
        self.privilege: typing.Optional[SharedNotePrivilegeLevel] = privilege
        self.serviceCreated: typing.Optional[int] = serviceCreated
        self.serviceUpdated: typing.Optional[int] = serviceUpdated
        self.serviceAssigned: typing.Optional[int] = serviceAssigned

    def __setattr__(self, name, value):
        if name == "privilege":
            super().__setattr__(name, value if hasattr(value, 'value') else SharedNotePrivilegeLevel.__members__.get(value))
            return
        super().__setattr__(name, value)


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sharerUserID = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.recipientIdentity = Identity()
                    self.recipientIdentity.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.privilege = SharedNotePrivilegeLevel(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.serviceCreated = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.serviceUpdated = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.serviceAssigned = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SharedNote')
        if self.sharerUserID is not None:
            oprot.writeFieldBegin('sharerUserID', TType.I32, 1)
            oprot.writeI32(self.sharerUserID)
            oprot.writeFieldEnd()
        if self.recipientIdentity is not None:
            oprot.writeFieldBegin('recipientIdentity', TType.STRUCT, 2)
            self.recipientIdentity.write(oprot)
            oprot.writeFieldEnd()
        if self.privilege is not None:
            oprot.writeFieldBegin('privilege', TType.I32, 3)
            oprot.writeI32(self.privilege.value)
            oprot.writeFieldEnd()
        if self.serviceCreated is not None:
            oprot.writeFieldBegin('serviceCreated', TType.I64, 4)
            oprot.writeI64(self.serviceCreated)
            oprot.writeFieldEnd()
        if self.serviceUpdated is not None:
            oprot.writeFieldBegin('serviceUpdated', TType.I64, 5)
            oprot.writeI64(self.serviceUpdated)
            oprot.writeFieldEnd()
        if self.serviceAssigned is not None:
            oprot.writeFieldBegin('serviceAssigned', TType.I64, 6)
            oprot.writeI64(self.serviceAssigned)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NoteRestrictions(object):
    """
    This structure captures information about the operations that cannot be performed on a given
    note that has been shared with a recipient via a SharedNote. The following operations are
    <b>never</b> allowed based on SharedNotes, and as such are left out of the NoteRestrictions
    structure for brevity:

    <ul>
      <li>Expunging a note (NoteStore.expungeNote)</li>
      <li>Moving a note to the trash (Note.active)</li>
      <li>Updating a note's notebook (Note.notebookGuid)</li>
      <li>Updating a note's tags (Note.tagGuids, Note.tagNames)</li>
      <li>Updating a note's attributes (Note.attributes)</li>
      <li>Sharing a note with the business (NoteStore.shareNoteWithBusiness</li>
      <li>Getting a note's version history (NoteStore.listNoteVersions,
        NoteStore.getNoteVersion)</li>
    </ul>

    When a client has permission to update a note's title or content, it may also update the
    Note.updated timestamp.

    <b>This structure reflects only the privileges / restrictions conveyed by the SharedNote.</b>
    It does not incorporate privileges conveyed by a potential SharedNotebook to the same
    recipient. As such, the actual permissions that the recipient has on the note may differ from
    the permissions expressed in this structure.

    For example, consider a user with read-only access to a shared notebook, and a read-write share
    of a specific note in the notebook. The note restrictions would contain noUpdateTitle = false,
    while the notebook restrictions would contain noUpdateNotes = true. In this case, the user is
    allowed to update the note title based on the note restrictions.

    Alternatively, consider a user with read-write access to a shared notebook, and a read-only
    share of a specific note in that notebook. The note restrictions would contain
    noUpdateTitle = true, while the notebook restrictions would contain noUpdateNotes = false. In
    this case, the user would have full edit permissions on the note based on the notebook
    restrictions.

    <dl>
      <dt>noUpdateTitle</dt>
      <dd>The client may not update the note's title (Note.title).</dd>

      <dt>noUpdateContent<dt>
      <dd>The client may not update the note's content. Content includes Note.content
        and Note.resources, as well as the related fields Note.contentHash and
        Note.contentLength.</dd>

      <dt>noEmail</dt>
      <dd>The client may not email the note (NoteStore.emailNote).</dd>

      <dt>noShare</dt>
      <dd>The client may not share the note with specific recipients
        (NoteStore.createOrUpdateSharedNotes).</dd>

      <dt>noSharePublicly</dt>
      <dd>The client may not make the note public (NoteStore.shareNote).</dd>
    </dl>

    Attributes:
     - noUpdateTitle
     - noUpdateContent
     - noEmail
     - noShare
     - noSharePublicly

    """
    thrift_spec: typing.Any = None


    def __init__(self, noUpdateTitle: typing.Optional[bool] = None, noUpdateContent: typing.Optional[bool] = None, noEmail: typing.Optional[bool] = None, noShare: typing.Optional[bool] = None, noSharePublicly: typing.Optional[bool] = None,):
        self.noUpdateTitle: typing.Optional[bool] = noUpdateTitle
        self.noUpdateContent: typing.Optional[bool] = noUpdateContent
        self.noEmail: typing.Optional[bool] = noEmail
        self.noShare: typing.Optional[bool] = noShare
        self.noSharePublicly: typing.Optional[bool] = noSharePublicly

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.noUpdateTitle = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.noUpdateContent = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.noEmail = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.noShare = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.noSharePublicly = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NoteRestrictions')
        if self.noUpdateTitle is not None:
            oprot.writeFieldBegin('noUpdateTitle', TType.BOOL, 1)
            oprot.writeBool(self.noUpdateTitle)
            oprot.writeFieldEnd()
        if self.noUpdateContent is not None:
            oprot.writeFieldBegin('noUpdateContent', TType.BOOL, 2)
            oprot.writeBool(self.noUpdateContent)
            oprot.writeFieldEnd()
        if self.noEmail is not None:
            oprot.writeFieldBegin('noEmail', TType.BOOL, 3)
            oprot.writeBool(self.noEmail)
            oprot.writeFieldEnd()
        if self.noShare is not None:
            oprot.writeFieldBegin('noShare', TType.BOOL, 4)
            oprot.writeBool(self.noShare)
            oprot.writeFieldEnd()
        if self.noSharePublicly is not None:
            oprot.writeFieldBegin('noSharePublicly', TType.BOOL, 5)
            oprot.writeBool(self.noSharePublicly)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NoteLimits(object):
    """
    Represents the owner's account related limits on a Note.
    The field uploaded represents the total number of bytes that have been uploaded
    to this account and is taken from the SyncState struct. All other fields
    represent account related limits and are taken from the AccountLimits struct.
    <p />
    See SyncState and AccountLimits struct field definitions for more details.

    Attributes:
     - noteResourceCountMax
     - uploadLimit
     - resourceSizeMax
     - noteSizeMax
     - uploaded

    """
    thrift_spec: typing.Any = None


    def __init__(self, noteResourceCountMax: typing.Optional[int] = None, uploadLimit: typing.Optional[int] = None, resourceSizeMax: typing.Optional[int] = None, noteSizeMax: typing.Optional[int] = None, uploaded: typing.Optional[int] = None,):
        self.noteResourceCountMax: typing.Optional[int] = noteResourceCountMax
        self.uploadLimit: typing.Optional[int] = uploadLimit
        self.resourceSizeMax: typing.Optional[int] = resourceSizeMax
        self.noteSizeMax: typing.Optional[int] = noteSizeMax
        self.uploaded: typing.Optional[int] = uploaded

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.noteResourceCountMax = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.uploadLimit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.resourceSizeMax = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.noteSizeMax = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.uploaded = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NoteLimits')
        if self.noteResourceCountMax is not None:
            oprot.writeFieldBegin('noteResourceCountMax', TType.I32, 1)
            oprot.writeI32(self.noteResourceCountMax)
            oprot.writeFieldEnd()
        if self.uploadLimit is not None:
            oprot.writeFieldBegin('uploadLimit', TType.I64, 2)
            oprot.writeI64(self.uploadLimit)
            oprot.writeFieldEnd()
        if self.resourceSizeMax is not None:
            oprot.writeFieldBegin('resourceSizeMax', TType.I64, 3)
            oprot.writeI64(self.resourceSizeMax)
            oprot.writeFieldEnd()
        if self.noteSizeMax is not None:
            oprot.writeFieldBegin('noteSizeMax', TType.I64, 4)
            oprot.writeI64(self.noteSizeMax)
            oprot.writeFieldEnd()
        if self.uploaded is not None:
            oprot.writeFieldBegin('uploaded', TType.I64, 5)
            oprot.writeI64(self.uploaded)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Note(object):
    """
    Represents a single note in the user's account.

    <dl>
    <dt>guid</dt>
      <dd>The unique identifier of this note.  Will be set by the
      server, but will be omitted by clients calling NoteStore.createNote()
      <br/>
      Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
      <br/>
      Regex:  EDAM_GUID_REGEX
      </dd>

    <dt>title</dt>
      <dd>The subject of the note.  Can't begin or end with a space.
      <br/>
      Length:  EDAM_NOTE_TITLE_LEN_MIN - EDAM_NOTE_TITLE_LEN_MAX
      <br/>
      Regex:  EDAM_NOTE_TITLE_REGEX
      </dd>

    <dt>content</dt>
      <dd>The XHTML block that makes up the note.  This is
      the canonical form of the note's contents, so will include abstract
      Evernote tags for internal resource references.  A client may create
      a separate transformed version of this content for internal presentation,
      but the same canonical bytes should be used for transmission and
      comparison unless the user chooses to modify their content.
      <br/>
      Length:  EDAM_NOTE_CONTENT_LEN_MIN - EDAM_NOTE_CONTENT_LEN_MAX
      </dd>

    <dt>contentHash</dt>
      <dd>The binary MD5 checksum of the UTF-8 encoded content
      body. This will always be set by the server, but clients may choose to omit
      this when they submit a note with content.
      <br/>
      Length:  EDAM_HASH_LEN (exactly)
      </dd>

    <dt>contentLength</dt>
      <dd>The number of Unicode characters in the content of
      the note.  This will always be set by the service, but clients may choose
      to omit this value when they submit a Note.
      </dd>

    <dt>created</dt>
      <dd>The date and time when the note was created in one of the
      clients.  In most cases, this will match the user's sense of when
      the note was created, and ordering between notes will be based on
      ordering of this field.  However, this is not a "reliable" timestamp
      if a client has an incorrect clock, so it cannot provide a true absolute
      ordering between notes.  Notes created directly through the service
      (e.g. via the web GUI) will have an absolutely ordered "created" value.
      </dd>

    <dt>updated</dt>
      <dd>The date and time when the note was last modified in one of
      the clients.  In most cases, this will match the user's sense of when
      the note was modified, but this field may not be absolutely reliable
      due to the possibility of client clock errors.
      </dd>

    <dt>deleted</dt>
      <dd>If present, the note is considered "deleted", and this
      stores the date and time when the note was deleted by one of the clients.
      In most cases, this will match the user's sense of when the note was
      deleted, but this field may be unreliable due to the possibility of
      client clock errors.
      </dd>

    <dt>active</dt>
      <dd>If the note is available for normal actions and viewing,
      this flag will be set to true.
      </dd>

    <dt>updateSequenceNum</dt>
      <dd>A number identifying the last transaction to
      modify the state of this note (including changes to the note's attributes
      or resources).  The USN values are sequential within an account,
      and can be used to compare the order of modifications within the service.
      </dd>

    <dt>notebookGuid</dt>
      <dd>The unique identifier of the notebook that contains
      this note.  If no notebookGuid is provided on a call to createNote(), the
      default notebook will be used instead.
      <br/>
      Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
      <br/>
      Regex:  EDAM_GUID_REGEX
      </dd>

    <dt>tagGuids</dt>
      <dd>A list of the GUID identifiers for tags that are applied to this note.
      This may be provided in a call to createNote() to unambiguously declare
      the tags that should be assigned to the new note.  Alternately, clients
      may pass the names of desired tags via the 'tagNames' field during
      note creation.
      If the list of tags are omitted on a call to createNote(), then
      the server will assume that no changes have been made to the resources.
      Maximum:  EDAM_NOTE_TAGS_MAX tags per note
      </dd>

    <dt>resources</dt>
      <dd>The list of resources that are embedded within this note.
      If the list of resources are omitted on a call to updateNote(), then
      the server will assume that no changes have been made to the resources.
      The binary contents of the resources must be provided when the resource
      is first sent to the service, but it will be omitted by the service when
      the Note is returned in the future.
      Maximum:  EDAM_NOTE_RESOURCES_MAX resources per note
      </dd>

    <dt>attributes</dt>
      <dd>A list of the attributes for this note.
      If the list of attributes are omitted on a call to updateNote(), then
      the server will assume that no changes have been made to the resources.
      </dd>

    <dt>tagNames</dt>
      <dd>May be provided by clients during calls to createNote() as an
      alternative to providing the tagGuids of existing tags.  If any tagNames
      are provided during createNote(), these will be found, or created if they
      don't already exist.  Created tags will have no parent (they will be at
      the top level of the tag panel).
      </dd>

    <dt>sharedNotes</dt>
      <dd>The list of recipients with whom this note has been shared. This field will be unset if
        the caller has access to the note via the containing notebook, but does not have activity
        feed permission for that notebook. This field is read-only. Clients may not make changes to
        a note's sharing state via this field.
      </dd>

      <dt>restrictions</dt>
      <dd>If this field is set, the user has note-level permissions that may differ from their
        notebook-level permissions. In this case, the restrictions structure specifies
        a set of restrictions limiting the actions that a user may take on the note based
        on their note-level permissions. If this field is unset, then there are no
        note-specific restrictions. However, a client may still be limited based on the user's
        notebook permissions.</dd>
    </dl>

    Attributes:
     - guid
     - title
     - content
     - contentHash
     - contentLength
     - created
     - updated
     - deleted
     - active
     - updateSequenceNum
     - notebookGuid
     - tagGuids
     - resources
     - attributes
     - tagNames
     - sharedNotes
     - restrictions
     - limits

    """
    thrift_spec: typing.Any = None


    def __init__(self, guid: typing.Optional[str] = None, title: typing.Optional[str] = None, content: typing.Optional[str] = None, contentHash: typing.Optional[bytes] = None, contentLength: typing.Optional[int] = None, created: typing.Optional[int] = None, updated: typing.Optional[int] = None, deleted: typing.Optional[int] = None, active: typing.Optional[bool] = None, updateSequenceNum: typing.Optional[int] = None, notebookGuid: typing.Optional[str] = None, tagGuids: typing.Optional[list[str]] = None, resources: typing.Optional[list[Resource]] = None, attributes: typing.Optional[NoteAttributes] = None, tagNames: typing.Optional[list[str]] = None, sharedNotes: typing.Optional[list[SharedNote]] = None, restrictions: typing.Optional[NoteRestrictions] = None, limits: typing.Optional[NoteLimits] = None,):
        self.guid: typing.Optional[str] = guid
        self.title: typing.Optional[str] = title
        self.content: typing.Optional[str] = content
        self.contentHash: typing.Optional[bytes] = contentHash
        self.contentLength: typing.Optional[int] = contentLength
        self.created: typing.Optional[int] = created
        self.updated: typing.Optional[int] = updated
        self.deleted: typing.Optional[int] = deleted
        self.active: typing.Optional[bool] = active
        self.updateSequenceNum: typing.Optional[int] = updateSequenceNum
        self.notebookGuid: typing.Optional[str] = notebookGuid
        self.tagGuids: typing.Optional[list[str]] = tagGuids
        self.resources: typing.Optional[list[Resource]] = resources
        self.attributes: typing.Optional[NoteAttributes] = attributes
        self.tagNames: typing.Optional[list[str]] = tagNames
        self.sharedNotes: typing.Optional[list[SharedNote]] = sharedNotes
        self.restrictions: typing.Optional[NoteRestrictions] = restrictions
        self.limits: typing.Optional[NoteLimits] = limits

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.title = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.content = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.contentHash = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.contentLength = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.created = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.updated = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.deleted = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.BOOL:
                    self.active = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.updateSequenceNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRING:
                    self.notebookGuid = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.LIST:
                    self.tagGuids = []
                    (_etype42, _size39) = iprot.readListBegin()
                    for _i43 in range(_size39):
                        _elem44 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.tagGuids.append(_elem44)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.LIST:
                    self.resources = []
                    (_etype48, _size45) = iprot.readListBegin()
                    for _i49 in range(_size45):
                        _elem50 = Resource()
                        _elem50.read(iprot)
                        self.resources.append(_elem50)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.STRUCT:
                    self.attributes = NoteAttributes()
                    self.attributes.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.LIST:
                    self.tagNames = []
                    (_etype54, _size51) = iprot.readListBegin()
                    for _i55 in range(_size51):
                        _elem56 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.tagNames.append(_elem56)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.LIST:
                    self.sharedNotes = []
                    (_etype60, _size57) = iprot.readListBegin()
                    for _i61 in range(_size57):
                        _elem62 = SharedNote()
                        _elem62.read(iprot)
                        self.sharedNotes.append(_elem62)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.STRUCT:
                    self.restrictions = NoteRestrictions()
                    self.restrictions.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.STRUCT:
                    self.limits = NoteLimits()
                    self.limits.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Note')
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 1)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        if self.title is not None:
            oprot.writeFieldBegin('title', TType.STRING, 2)
            oprot.writeString(self.title.encode('utf-8') if sys.version_info[0] == 2 else self.title)
            oprot.writeFieldEnd()
        if self.content is not None:
            oprot.writeFieldBegin('content', TType.STRING, 3)
            oprot.writeString(self.content.encode('utf-8') if sys.version_info[0] == 2 else self.content)
            oprot.writeFieldEnd()
        if self.contentHash is not None:
            oprot.writeFieldBegin('contentHash', TType.STRING, 4)
            oprot.writeBinary(self.contentHash)
            oprot.writeFieldEnd()
        if self.contentLength is not None:
            oprot.writeFieldBegin('contentLength', TType.I32, 5)
            oprot.writeI32(self.contentLength)
            oprot.writeFieldEnd()
        if self.created is not None:
            oprot.writeFieldBegin('created', TType.I64, 6)
            oprot.writeI64(self.created)
            oprot.writeFieldEnd()
        if self.updated is not None:
            oprot.writeFieldBegin('updated', TType.I64, 7)
            oprot.writeI64(self.updated)
            oprot.writeFieldEnd()
        if self.deleted is not None:
            oprot.writeFieldBegin('deleted', TType.I64, 8)
            oprot.writeI64(self.deleted)
            oprot.writeFieldEnd()
        if self.active is not None:
            oprot.writeFieldBegin('active', TType.BOOL, 9)
            oprot.writeBool(self.active)
            oprot.writeFieldEnd()
        if self.updateSequenceNum is not None:
            oprot.writeFieldBegin('updateSequenceNum', TType.I32, 10)
            oprot.writeI32(self.updateSequenceNum)
            oprot.writeFieldEnd()
        if self.notebookGuid is not None:
            oprot.writeFieldBegin('notebookGuid', TType.STRING, 11)
            oprot.writeString(self.notebookGuid.encode('utf-8') if sys.version_info[0] == 2 else self.notebookGuid)
            oprot.writeFieldEnd()
        if self.tagGuids is not None:
            oprot.writeFieldBegin('tagGuids', TType.LIST, 12)
            oprot.writeListBegin(TType.STRING, len(self.tagGuids))
            for iter63 in self.tagGuids:
                oprot.writeString(iter63.encode('utf-8') if sys.version_info[0] == 2 else iter63)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.resources is not None:
            oprot.writeFieldBegin('resources', TType.LIST, 13)
            oprot.writeListBegin(TType.STRUCT, len(self.resources))
            for iter64 in self.resources:
                iter64.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.STRUCT, 14)
            self.attributes.write(oprot)
            oprot.writeFieldEnd()
        if self.tagNames is not None:
            oprot.writeFieldBegin('tagNames', TType.LIST, 15)
            oprot.writeListBegin(TType.STRING, len(self.tagNames))
            for iter65 in self.tagNames:
                oprot.writeString(iter65.encode('utf-8') if sys.version_info[0] == 2 else iter65)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sharedNotes is not None:
            oprot.writeFieldBegin('sharedNotes', TType.LIST, 16)
            oprot.writeListBegin(TType.STRUCT, len(self.sharedNotes))
            for iter66 in self.sharedNotes:
                iter66.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.restrictions is not None:
            oprot.writeFieldBegin('restrictions', TType.STRUCT, 17)
            self.restrictions.write(oprot)
            oprot.writeFieldEnd()
        if self.limits is not None:
            oprot.writeFieldBegin('limits', TType.STRUCT, 18)
            self.limits.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Publishing(object):
    """
    If a Notebook has been opened to the public, the Notebook will have a
    reference to one of these structures, which gives the location and optional
    description of the externally-visible public Notebook.
    <dl>
    <dt>uri</dt>
      <dd>If this field is present, then the notebook is published for
      mass consumption on the Internet under the provided URI, which is
      relative to a defined base publishing URI defined by the service.
      This field can only be modified via the web service GUI ... publishing
      cannot be modified via an offline client.
      <br/>
      Length:  EDAM_PUBLISHING_URI_LEN_MIN - EDAM_PUBLISHING_URI_LEN_MAX
      <br/>
      Regex:  EDAM_PUBLISHING_URI_REGEX
      </dd>

    <dt>order</dt>
      <dd>When the notes are publicly displayed, they will be sorted
      based on the requested criteria.
      </dd>

    <dt>ascending</dt>
      <dd>If this is set to true, then the public notes will be
      displayed in ascending order (e.g. from oldest to newest).  Otherwise,
      the notes will be displayed in descending order (e.g. newest to oldest).
      </dd>

    <dt>publicDescription</dt>
      <dd>This field may be used to provide a short
      description of the notebook, which may be displayed when (e.g.) the
      notebook is shown in a public view.  Can't begin or end with a space.
      <br/>
      Length:  EDAM_PUBLISHING_DESCRIPTION_LEN_MIN -
               EDAM_PUBLISHING_DESCRIPTION_LEN_MAX
      <br/>
      Regex:  EDAM_PUBLISHING_DESCRIPTION_REGEX
      </dd>

    </dl>

    Attributes:
     - uri
     - order
     - ascending
     - publicDescription

    """
    thrift_spec: typing.Any = None


    def __init__(self, uri: typing.Optional[str] = None, order: typing.Optional[NoteSortOrder] = None, ascending: typing.Optional[bool] = None, publicDescription: typing.Optional[str] = None,):
        self.uri: typing.Optional[str] = uri
        self.order: typing.Optional[NoteSortOrder] = order
        self.ascending: typing.Optional[bool] = ascending
        self.publicDescription: typing.Optional[str] = publicDescription

    def __setattr__(self, name, value):
        if name == "order":
            super().__setattr__(name, value if hasattr(value, 'value') else NoteSortOrder.__members__.get(value))
            return
        super().__setattr__(name, value)


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.uri = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.order = NoteSortOrder(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.ascending = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.publicDescription = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Publishing')
        if self.uri is not None:
            oprot.writeFieldBegin('uri', TType.STRING, 1)
            oprot.writeString(self.uri.encode('utf-8') if sys.version_info[0] == 2 else self.uri)
            oprot.writeFieldEnd()
        if self.order is not None:
            oprot.writeFieldBegin('order', TType.I32, 2)
            oprot.writeI32(self.order.value)
            oprot.writeFieldEnd()
        if self.ascending is not None:
            oprot.writeFieldBegin('ascending', TType.BOOL, 3)
            oprot.writeBool(self.ascending)
            oprot.writeFieldEnd()
        if self.publicDescription is not None:
            oprot.writeFieldBegin('publicDescription', TType.STRING, 4)
            oprot.writeString(self.publicDescription.encode('utf-8') if sys.version_info[0] == 2 else self.publicDescription)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BusinessNotebook(object):
    """
    If a Notebook contained in an Evernote Business account has been published
    the to business library, the Notebook will have a reference to one of these
    structures, which specifies how the Notebook will be represented in the
    library.

    <dl>
    <dt>notebookDescription</dt>
      <dd>A short description of the notebook's content that will be displayed
          in the business library user interface. The description may not begin
          or end with whitespace.
      <br/>
      Length: EDAM_BUSINESS_NOTEBOOK_DESCRIPTION_LEN_MIN -
              EDAM_BUSINESS_NOTEBOOK_DESCRIPTION_LEN_MAX
      <br/>
      Regex:  EDAM_BUSINESS_NOTEBOOK_DESCRIPTION_REGEX
      </dd>

    <dt>privilege</dt>
      <dd>The privileges that will be granted to users who join the notebook through
          the business library.
      </dd>

    <dt>recommended</dt>
      <dd>Whether the notebook should be "recommended" when displayed in the business
          library user interface.
      </dd>
    </dl>

    Attributes:
     - notebookDescription
     - privilege
     - recommended

    """
    thrift_spec: typing.Any = None


    def __init__(self, notebookDescription: typing.Optional[str] = None, privilege: typing.Optional[SharedNotebookPrivilegeLevel] = None, recommended: typing.Optional[bool] = None,):
        self.notebookDescription: typing.Optional[str] = notebookDescription
        self.privilege: typing.Optional[SharedNotebookPrivilegeLevel] = privilege
        self.recommended: typing.Optional[bool] = recommended

    def __setattr__(self, name, value):
        if name == "privilege":
            super().__setattr__(name, value if hasattr(value, 'value') else SharedNotebookPrivilegeLevel.__members__.get(value))
            return
        super().__setattr__(name, value)


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.notebookDescription = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.privilege = SharedNotebookPrivilegeLevel(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.recommended = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BusinessNotebook')
        if self.notebookDescription is not None:
            oprot.writeFieldBegin('notebookDescription', TType.STRING, 1)
            oprot.writeString(self.notebookDescription.encode('utf-8') if sys.version_info[0] == 2 else self.notebookDescription)
            oprot.writeFieldEnd()
        if self.privilege is not None:
            oprot.writeFieldBegin('privilege', TType.I32, 2)
            oprot.writeI32(self.privilege.value)
            oprot.writeFieldEnd()
        if self.recommended is not None:
            oprot.writeFieldBegin('recommended', TType.BOOL, 3)
            oprot.writeBool(self.recommended)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SavedSearchScope(object):
    """
    A structure defining the scope of a SavedSearch.

    <dl>
      <dt>includeAccount</dt>
      <dd>The search should include notes from the account that contains the SavedSearch.</dd>

      <dt>includePersonalLinkedNotebooks</dt>
      <dd>The search should include notes within those shared notebooks
      that the user has joined that are NOT business notebooks.</dd>

      <dt>includeBusinessLinkedNotebooks</dt>
      <dd>The search should include notes within those shared notebooks
      that the user has joined that are business notebooks in the business that
      the user is currently a member of.</dd>
    </dl>

    Attributes:
     - includeAccount
     - includePersonalLinkedNotebooks
     - includeBusinessLinkedNotebooks

    """
    thrift_spec: typing.Any = None


    def __init__(self, includeAccount: typing.Optional[bool] = None, includePersonalLinkedNotebooks: typing.Optional[bool] = None, includeBusinessLinkedNotebooks: typing.Optional[bool] = None,):
        self.includeAccount: typing.Optional[bool] = includeAccount
        self.includePersonalLinkedNotebooks: typing.Optional[bool] = includePersonalLinkedNotebooks
        self.includeBusinessLinkedNotebooks: typing.Optional[bool] = includeBusinessLinkedNotebooks

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.includeAccount = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.includePersonalLinkedNotebooks = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.includeBusinessLinkedNotebooks = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SavedSearchScope')
        if self.includeAccount is not None:
            oprot.writeFieldBegin('includeAccount', TType.BOOL, 1)
            oprot.writeBool(self.includeAccount)
            oprot.writeFieldEnd()
        if self.includePersonalLinkedNotebooks is not None:
            oprot.writeFieldBegin('includePersonalLinkedNotebooks', TType.BOOL, 2)
            oprot.writeBool(self.includePersonalLinkedNotebooks)
            oprot.writeFieldEnd()
        if self.includeBusinessLinkedNotebooks is not None:
            oprot.writeFieldBegin('includeBusinessLinkedNotebooks', TType.BOOL, 3)
            oprot.writeBool(self.includeBusinessLinkedNotebooks)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SavedSearch(object):
    """
    A named search associated with the account that can be quickly re-used.
    <dl>
    <dt>guid</dt>
      <dd>The unique identifier of this search.  Will be set by the
      service, so may be omitted by the client when creating.
      <br/>
      Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
      <br/>
      Regex:  EDAM_GUID_REGEX
      </dd>

    <dt>name</dt>
      <dd>The name of the saved search to display in the GUI.  The
      account may only contain one search with a given name (case-insensitive
      compare). Can't begin or end with a space.
      <br/>
      Length:  EDAM_SAVED_SEARCH_NAME_LEN_MIN - EDAM_SAVED_SEARCH_NAME_LEN_MAX
      <br/>
      Regex:  EDAM_SAVED_SEARCH_NAME_REGEX
      </dd>

    <dt>query</dt>
      <dd>A string expressing the search to be performed.
      <br/>
      Length:  EDAM_SAVED_SEARCH_QUERY_LEN_MIN - EDAM_SAVED_SEARCH_QUERY_LEN_MAX
      </dd>

    <dt>format</dt>
      <dd>The format of the query string, to determine how to parse
      and process it.
      </dd>

    <dt>updateSequenceNum</dt>
      <dd>A number identifying the last transaction to
      modify the state of this object.  The USN values are sequential within an
      account, and can be used to compare the order of modifications within the
      service.
      </dd>

    <dt>scope</dt>
      <dd><p>Specifies the set of notes that should be included in the search, if
       possible.</p>
       <p>Clients are expected to search as much of the desired scope as possible,
       with the understanding that a given client may not be able to cover the full
       specified scope. For example, when executing a search that includes notes in both
       the owner's account and business notebooks, a mobile client may choose to only
       search within the user's account because it is not capable of searching both
       scopes simultaneously. When a search across multiple scopes is not possible,
       a client may choose which scope to search based on the current application
       context. If a client cannot search any of the desired scopes, it should refuse
       to execute the search.</p>
       </dd>
    </dl>

    Attributes:
     - guid
     - name
     - query
     - format
     - updateSequenceNum
     - scope

    """
    thrift_spec: typing.Any = None


    def __init__(self, guid: typing.Optional[str] = None, name: typing.Optional[str] = None, query: typing.Optional[str] = None, format: typing.Optional[QueryFormat] = None, updateSequenceNum: typing.Optional[int] = None, scope: typing.Optional[SavedSearchScope] = None,):
        self.guid: typing.Optional[str] = guid
        self.name: typing.Optional[str] = name
        self.query: typing.Optional[str] = query
        self.format: typing.Optional[QueryFormat] = format
        self.updateSequenceNum: typing.Optional[int] = updateSequenceNum
        self.scope: typing.Optional[SavedSearchScope] = scope

    def __setattr__(self, name, value):
        if name == "format":
            super().__setattr__(name, value if hasattr(value, 'value') else QueryFormat.__members__.get(value))
            return
        super().__setattr__(name, value)


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.query = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.format = QueryFormat(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.updateSequenceNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.scope = SavedSearchScope()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SavedSearch')
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 1)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.STRING, 3)
            oprot.writeString(self.query.encode('utf-8') if sys.version_info[0] == 2 else self.query)
            oprot.writeFieldEnd()
        if self.format is not None:
            oprot.writeFieldBegin('format', TType.I32, 4)
            oprot.writeI32(self.format.value)
            oprot.writeFieldEnd()
        if self.updateSequenceNum is not None:
            oprot.writeFieldBegin('updateSequenceNum', TType.I32, 5)
            oprot.writeI32(self.updateSequenceNum)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 6)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SharedNotebookRecipientSettings(object):
    """
    Settings meant for the recipient of a shared notebook, such as
    for indicating which types of notifications the recipient wishes
    for reminders, etc.

    The reminderNotifyEmail and reminderNotifyInApp fields have a
    3-state read value but a 2-state write value.  On read, it is
    possible to observe "unset", true, or false.  The initial state is
    "unset".  When you choose to set a value, you may set it to either
    true or false, but you cannot unset the value.  Once one of these
    members has a true/false value, it will always have a true/false
    value.

    <dl>
    <dt>reminderNotifyEmail</dt>
    <dd>Indicates that the user wishes to receive daily e-mail notifications
        for reminders associated with the notebook. This may be true only for
        business notebooks that belong to the business of which the user is a
        member. You may only set this value on a notebook in your business.</dd>
    <dt>reminderNotifyInApp</dt>
    <dd>Indicates that the user wishes to receive notifications for
        reminders by applications that support providing such
        notifications.  The exact nature of the notification is defined
        by the individual applications.</dd>
    </dl>


    Attributes:
     - reminderNotifyEmail
     - reminderNotifyInApp

    """
    thrift_spec: typing.Any = None


    def __init__(self, reminderNotifyEmail: typing.Optional[bool] = None, reminderNotifyInApp: typing.Optional[bool] = None,):
        self.reminderNotifyEmail: typing.Optional[bool] = reminderNotifyEmail
        self.reminderNotifyInApp: typing.Optional[bool] = reminderNotifyInApp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.reminderNotifyEmail = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.reminderNotifyInApp = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SharedNotebookRecipientSettings')
        if self.reminderNotifyEmail is not None:
            oprot.writeFieldBegin('reminderNotifyEmail', TType.BOOL, 1)
            oprot.writeBool(self.reminderNotifyEmail)
            oprot.writeFieldEnd()
        if self.reminderNotifyInApp is not None:
            oprot.writeFieldBegin('reminderNotifyInApp', TType.BOOL, 2)
            oprot.writeBool(self.reminderNotifyInApp)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NotebookRecipientSettings(object):
    """
    Settings meant for the recipient of a notebook share.

    Some of these fields have a 3-state read value but a 2-state write value.
    On read, it is possible to observe "unset", true, or false. The initial
    state is "unset". When you choose to set a value, you may set it to either
    true or false, but you cannot unset the value. Once one of these members
    has a true/false value, it will always have a true/false value.

    <dl>
    <dt>reminderNotifyEmail</dt>
    <dd>Indicates that the user wishes to receive daily e-mail notifications
        for reminders associated with the notebook. This may be
        true only for business notebooks that belong to the business of
        which the user is a member. You may only set this value on a
        notebook in your business. This value will initially be unset.</dd>
    <dt>reminderNotifyInApp</dt>
    <dd>Indicates that the user wishes to receive notifications for
        reminders by applications that support providing such
        notifications.  The exact nature of the notification is defined
        by the individual applications. This value will initially be unset.</dd>
    </dl>
    <dt>inMyList</dt>
    <dd>DEPRECATED: Use recipientStatus instead.
        The notebook is on the recipient's notebook list (formerly, we would say
        that the recipient has "joined" the notebook)</dd>
    <dt>recipientStatus</dt>
    <dd>The notebook is on/off the recipient's notebook list (formerly, we would say
        that the recipient has "joined" the notebook) and perhaps also their
        default notebook</dd>
    <dt>stack</dt>
    <dd>The stack the recipient has put this notebook into. See Notebook.stack
    for a definition. Every recipient can have their own stack value for the same
    notebook.</dd>
    </dl>


    Attributes:
     - reminderNotifyEmail
     - reminderNotifyInApp
     - inMyList
     - stack
     - recipientStatus

    """
    thrift_spec: typing.Any = None


    def __init__(self, reminderNotifyEmail: typing.Optional[bool] = None, reminderNotifyInApp: typing.Optional[bool] = None, inMyList: typing.Optional[bool] = None, stack: typing.Optional[str] = None, recipientStatus: typing.Optional[RecipientStatus] = None,):
        self.reminderNotifyEmail: typing.Optional[bool] = reminderNotifyEmail
        self.reminderNotifyInApp: typing.Optional[bool] = reminderNotifyInApp
        self.inMyList: typing.Optional[bool] = inMyList
        self.stack: typing.Optional[str] = stack
        self.recipientStatus: typing.Optional[RecipientStatus] = recipientStatus

    def __setattr__(self, name, value):
        if name == "recipientStatus":
            super().__setattr__(name, value if hasattr(value, 'value') else RecipientStatus.__members__.get(value))
            return
        super().__setattr__(name, value)


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.reminderNotifyEmail = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.reminderNotifyInApp = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.inMyList = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.stack = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.recipientStatus = RecipientStatus(iprot.readI32())
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NotebookRecipientSettings')
        if self.reminderNotifyEmail is not None:
            oprot.writeFieldBegin('reminderNotifyEmail', TType.BOOL, 1)
            oprot.writeBool(self.reminderNotifyEmail)
            oprot.writeFieldEnd()
        if self.reminderNotifyInApp is not None:
            oprot.writeFieldBegin('reminderNotifyInApp', TType.BOOL, 2)
            oprot.writeBool(self.reminderNotifyInApp)
            oprot.writeFieldEnd()
        if self.inMyList is not None:
            oprot.writeFieldBegin('inMyList', TType.BOOL, 3)
            oprot.writeBool(self.inMyList)
            oprot.writeFieldEnd()
        if self.stack is not None:
            oprot.writeFieldBegin('stack', TType.STRING, 4)
            oprot.writeString(self.stack.encode('utf-8') if sys.version_info[0] == 2 else self.stack)
            oprot.writeFieldEnd()
        if self.recipientStatus is not None:
            oprot.writeFieldBegin('recipientStatus', TType.I32, 5)
            oprot.writeI32(self.recipientStatus.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SharedNotebook(object):
    """
    Shared notebooks represent a relationship between a notebook and a single
    share invitation recipient.
    <dl>
    <dt>id</dt>
    <dd>The primary identifier of the share, which is not globally unique.</dd>

    <dt>userId</dt>
    <dd>The user id of the owner of the notebook.</dd>

    <dt>notebookGuid</dt>
    <dd>The GUID of the notebook that has been shared.</dd>

    <dt>email</dt>
    <dd>A string containing a display name for the recipient of the share. This may
        be an email address, a phone number, a full name, or some other descriptive
        string This field is read-only to clients. It will be filled in by the service
        when returning shared notebooks.
    </dd>

    <dt>recipientIdentityId</dt>
    <dd>The IdentityID of the share recipient. If present, only the user who has
        claimed that identity may access this share.
    </dd>

    <dt>notebookModifiable</dt>
    <dd>DEPRECATED</dd>

    <dt>serviceCreated</dt>
    <dd>The date that the owner first created the share with the specific email
      address.</dd>

    <dt>serviceUpdated</dt>
    <dd>The date the shared notebook was last updated on the service.  This
        will be updated when authenticateToSharedNotebook is called the first
        time with a shared notebook (i.e. when the username is bound to that
        shared notebook), and also when the SharedNotebook privilege is updated
        as part of a shareNotebook(...) call, as well as on any calls to
        updateSharedNotebook(...).
    </dd>

    <dt>username</dt>
    <dd>DEPRECATED. The username of the user who can access this share. This
        value is read-only to clients. It will be filled in by the service when
        returning shared notebooks.
    </dd>

    <dt>privilege</dt>
    <dd>The privilege level granted to the notebook, activity stream, and
        invitations.  See the corresponding enumeration for details.
    </dd>

    <dt>recipientSettings</dt>
    <dd>Settings intended for use only by the recipient of this shared
        notebook.  You should skip setting this value unless you want
        to change the value contained inside the structure, and only if
        you are the recipient.</dd>

    <dt>globalId</dt>
    <dd>An immutable, opaque string that acts as a globally unique
        identifier for this shared notebook record.  You can use this field to
        match linked notebook and shared notebook records as well as to
        create new LinkedNotebook records.  This field replaces the deprecated
        shareKey field.
    </dd>

    <dt>sharerUserId</dt>
    <dd>The user id of the user who shared a notebook via this shared notebook
        instance. This may not be the same as userId, since a user with full
        access to a notebook may have created a new share for that notebook. For
        Business, this represents the user who shared the business notebook. This
        field is currently unset for a SharedNotebook created by joining a
        notebook that has been published to the business.
    </dd>

    <dt>recipientUsername</dt>
    <dd>The username of the user who can access this share. This is the username
        for the user with the id in recipientUserId. This value can be set
        by clients when calling shareNotebook(...), and that will result in the
        created SharedNotebook being assigned to a user. This value is always set
        if serviceAssigned is set.
    </dd>

    <dt>recipientUserId</dt>
    <dd>The id of the user who can access this share. This is the id for the user
        with the username in recipientUsername. This value is read-only and set
        by the service. Value set by clients will be ignored. This field may be unset
        for unjoined notebooks and is always set if serviceAssigned is set. Clients should
        prefer this field over recipientUsername unless they need to use usernames
        directly.
    </dd>

    <dt>serviceAssigned</dt>
    <dd>The date this SharedNotebook was assigned (i.e. has been associated with an
        Evernote user whose user ID is set in recipientUserId). Unset if the SharedNotebook
        is not assigned. This field is a read-only value that is set by the service.
    </dd>
    </dl>

    Attributes:
     - id
     - userId
     - notebookGuid
     - email
     - recipientIdentityId
     - notebookModifiable
     - serviceCreated
     - serviceUpdated
     - globalId
     - username
     - privilege
     - recipientSettings
     - sharerUserId
     - recipientUsername
     - recipientUserId
     - serviceAssigned

    """
    thrift_spec: typing.Any = None


    def __init__(self, id: typing.Optional[int] = None, userId: typing.Optional[int] = None, notebookGuid: typing.Optional[str] = None, email: typing.Optional[str] = None, recipientIdentityId: typing.Optional[int] = None, notebookModifiable: typing.Optional[bool] = None, serviceCreated: typing.Optional[int] = None, serviceUpdated: typing.Optional[int] = None, globalId: typing.Optional[str] = None, username: typing.Optional[str] = None, privilege: typing.Optional[SharedNotebookPrivilegeLevel] = None, recipientSettings: typing.Optional[SharedNotebookRecipientSettings] = None, sharerUserId: typing.Optional[int] = None, recipientUsername: typing.Optional[str] = None, recipientUserId: typing.Optional[int] = None, serviceAssigned: typing.Optional[int] = None,):
        self.id: typing.Optional[int] = id
        self.userId: typing.Optional[int] = userId
        self.notebookGuid: typing.Optional[str] = notebookGuid
        self.email: typing.Optional[str] = email
        self.recipientIdentityId: typing.Optional[int] = recipientIdentityId
        self.notebookModifiable: typing.Optional[bool] = notebookModifiable
        self.serviceCreated: typing.Optional[int] = serviceCreated
        self.serviceUpdated: typing.Optional[int] = serviceUpdated
        self.globalId: typing.Optional[str] = globalId
        self.username: typing.Optional[str] = username
        self.privilege: typing.Optional[SharedNotebookPrivilegeLevel] = privilege
        self.recipientSettings: typing.Optional[SharedNotebookRecipientSettings] = recipientSettings
        self.sharerUserId: typing.Optional[int] = sharerUserId
        self.recipientUsername: typing.Optional[str] = recipientUsername
        self.recipientUserId: typing.Optional[int] = recipientUserId
        self.serviceAssigned: typing.Optional[int] = serviceAssigned

    def __setattr__(self, name, value):
        if name == "privilege":
            super().__setattr__(name, value if hasattr(value, 'value') else SharedNotebookPrivilegeLevel.__members__.get(value))
            return
        super().__setattr__(name, value)


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.userId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.notebookGuid = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.email = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.I64:
                    self.recipientIdentityId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.notebookModifiable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.serviceCreated = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I64:
                    self.serviceUpdated = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.globalId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.privilege = SharedNotebookPrivilegeLevel(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRUCT:
                    self.recipientSettings = SharedNotebookRecipientSettings()
                    self.recipientSettings.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.I32:
                    self.sharerUserId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.STRING:
                    self.recipientUsername = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.I32:
                    self.recipientUserId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.I64:
                    self.serviceAssigned = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SharedNotebook')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.I32, 2)
            oprot.writeI32(self.userId)
            oprot.writeFieldEnd()
        if self.notebookGuid is not None:
            oprot.writeFieldBegin('notebookGuid', TType.STRING, 3)
            oprot.writeString(self.notebookGuid.encode('utf-8') if sys.version_info[0] == 2 else self.notebookGuid)
            oprot.writeFieldEnd()
        if self.email is not None:
            oprot.writeFieldBegin('email', TType.STRING, 4)
            oprot.writeString(self.email.encode('utf-8') if sys.version_info[0] == 2 else self.email)
            oprot.writeFieldEnd()
        if self.notebookModifiable is not None:
            oprot.writeFieldBegin('notebookModifiable', TType.BOOL, 5)
            oprot.writeBool(self.notebookModifiable)
            oprot.writeFieldEnd()
        if self.serviceCreated is not None:
            oprot.writeFieldBegin('serviceCreated', TType.I64, 7)
            oprot.writeI64(self.serviceCreated)
            oprot.writeFieldEnd()
        if self.globalId is not None:
            oprot.writeFieldBegin('globalId', TType.STRING, 8)
            oprot.writeString(self.globalId.encode('utf-8') if sys.version_info[0] == 2 else self.globalId)
            oprot.writeFieldEnd()
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 9)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        if self.serviceUpdated is not None:
            oprot.writeFieldBegin('serviceUpdated', TType.I64, 10)
            oprot.writeI64(self.serviceUpdated)
            oprot.writeFieldEnd()
        if self.privilege is not None:
            oprot.writeFieldBegin('privilege', TType.I32, 11)
            oprot.writeI32(self.privilege.value)
            oprot.writeFieldEnd()
        if self.recipientSettings is not None:
            oprot.writeFieldBegin('recipientSettings', TType.STRUCT, 13)
            self.recipientSettings.write(oprot)
            oprot.writeFieldEnd()
        if self.sharerUserId is not None:
            oprot.writeFieldBegin('sharerUserId', TType.I32, 14)
            oprot.writeI32(self.sharerUserId)
            oprot.writeFieldEnd()
        if self.recipientUsername is not None:
            oprot.writeFieldBegin('recipientUsername', TType.STRING, 15)
            oprot.writeString(self.recipientUsername.encode('utf-8') if sys.version_info[0] == 2 else self.recipientUsername)
            oprot.writeFieldEnd()
        if self.serviceAssigned is not None:
            oprot.writeFieldBegin('serviceAssigned', TType.I64, 16)
            oprot.writeI64(self.serviceAssigned)
            oprot.writeFieldEnd()
        if self.recipientUserId is not None:
            oprot.writeFieldBegin('recipientUserId', TType.I32, 17)
            oprot.writeI32(self.recipientUserId)
            oprot.writeFieldEnd()
        if self.recipientIdentityId is not None:
            oprot.writeFieldBegin('recipientIdentityId', TType.I64, 18)
            oprot.writeI64(self.recipientIdentityId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CanMoveToContainerRestrictions(object):
    """
    Specifies if the client can move a Notebook to a Workspace.

    Attributes:
     - canMoveToContainer

    """
    thrift_spec: typing.Any = None


    def __init__(self, canMoveToContainer: typing.Optional[CanMoveToContainerStatus] = None,):
        self.canMoveToContainer: typing.Optional[CanMoveToContainerStatus] = canMoveToContainer

    def __setattr__(self, name, value):
        if name == "canMoveToContainer":
            super().__setattr__(name, value if hasattr(value, 'value') else CanMoveToContainerStatus.__members__.get(value))
            return
        super().__setattr__(name, value)


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.canMoveToContainer = CanMoveToContainerStatus(iprot.readI32())
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CanMoveToContainerRestrictions')
        if self.canMoveToContainer is not None:
            oprot.writeFieldBegin('canMoveToContainer', TType.I32, 1)
            oprot.writeI32(self.canMoveToContainer.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NotebookRestrictions(object):
    """
    This structure captures information about the types of operations
    that cannot be performed on a given notebook with a type of
    authenticated access and credentials.  The values filled into this
    structure are based on then-current values in the server database
    for shared notebooks and notebook publishing records, as well as
    information related to the authentication token.  Information from
    the authentication token includes the application that is accessing
    the server, as defined by the permissions granted by consumer (api)
    key, and the method used to obtain the token, for example via
    authenticateToSharedNotebook, authenticateToBusiness, etc.  Note
    that changes to values in this structure that are the result of
    shared notebook or publishing record changes are communicated to
    the client via a change in the notebook USN during sync.  It is
    important to use the same access method, parameters, and consumer
    key in order obtain correct results from the sync engine.

    The server has the final say on what is allowed as values may
    change between calls to obtain NotebookRestrictions instances
    and to operate on data on the service.

    If the following are set and true, then the given restriction is
    in effect, as accessed by the same authentication token from which
    the values were obtained.

    <dl>
    <dt>noReadNotes</dt>
      <dd>The client is not able to read notes from the service and
      the notebook is write-only.
      </dd>
    <dt>noCreateNotes</dt>
      <dd>The client may not create new notes in the notebook.
      </dd>
    <dt>noUpdateNotes</dt>
      <dd>The client may not update notes currently in the notebook.
      </dd>
    <dt>noExpungeNotes</dt>
      <dd>The client may not expunge notes currently in the notebook.
      </dd>
    <dt>noShareNotes</dt>
      <dd>The client may not share notes in the notebook via the
      shareNote or createOrUpdateSharedNotes methods.
      </dd>
    <dt>noEmailNotes</dt>
      <dd>The client may not e-mail notes by guid via the Evernote
      service by using the emailNote method.  Email notes by value
      by populating the note parameter instead.
      </dd>
    <dt>noSendMessageToRecipients</dt>
      <dd>The client may not send messages to the share recipients of
      the notebook.
      </dd>
    <dt>noUpdateNotebook</dt>
      <dd>The client may not update the Notebook object itself, for
      example, via the updateNotebook method.
      </dd>
    <dt>noExpungeNotebook</dt>
      <dd>The client may not expunge the Notebook object itself, for
      example, via the expungeNotebook method.
      </dd>
    <dt>noSetDefaultNotebook</dt>
      <dd>The client may not set this notebook to be the default notebook.
      The caller should leave Notebook.defaultNotebook unset.
      </dd>
    <dt>noSetNotebookStack</dt>
      <dd>If the client is able to update the Notebook, the Notebook.stack
      value may not be set.
      </dd>
    <dt>noPublishToPublic</dt>
      <dd>The client may not publish the notebook to the public.
      For example, business notebooks may not be shared publicly.
      </dd>
    <dt>noPublishToBusinessLibrary</dt>
      <dd>The client may not publish the notebook to the business library.
      </dd>
    <dt>noCreateTags</dt>
      <dd>The client may not complete an operation that results in a new tag
      being created in the owner's account.
      </dd>
    <dt>noUpdateTags</dt>
      <dd>The client may not update tags in the owner's account.
      </dd>
    <dt>noExpungeTags</dt>
      <dd>The client may not expunge tags in the owner's account.
      </dd>
    <dt>noSetParentTag</dt>
      <dd>If the client is able to create or update tags in the owner's account,
      then they will not be able to set the parent tag.  Leave the value unset.
      </dd>
    <dt>noCreateSharedNotebooks</dt>
      <dd>The client is unable to create shared notebooks for the notebook.
      </dd>
    <dt>updateWhichSharedNotebookRestrictions</dt>
      <dd>Restrictions on which shared notebook instances can be updated.  If the
      value is not set or null, then the client can update any of the shared notebooks
      associated with the notebook on which the NotebookRestrictions are defined.
      See the enumeration for further details.
      </dd>
    <dt>expungeWhichSharedNotebookRestrictions</dt>
      <dd>Restrictions on which shared notebook instances can be expunged.  If the
      value is not set or null, then the client can expunge any of the shared notebooks
      associated with the notebook on which the NotebookRestrictions are defined.
      See the enumeration for further details.
      </dd>
    <dt>noShareNotesWithBusiness</dt>
      <dd>The client may not share notes in the notebook via the shareNoteWithBusiness
      method.
      </dd>
    <dt>noRenameNotebook</dt>
      <dd>The client may not rename this notebook.</dd>
    <dt>noSetInMyList</dt>
      <dd>clients may not change the NotebookRecipientSettings.inMyList settings for
      this notebook.</dd>
    <dt>noSetContact</dt>
      <dd>The contact for this notebook may not be changed.</dd>
    </dl>
    <dt>canMoveToContainerRestrictions</dt>
      <dd>Specifies if the client can move this notebook to a container and if not,
      the reason why.</dd>
    <dt>noCanMoveNote</dt>
      <dd>If set, the client cannot move a Note into or out of the Notebook.</dd>
    </dl>

    Attributes:
     - noReadNotes
     - noCreateNotes
     - noUpdateNotes
     - noExpungeNotes
     - noShareNotes
     - noEmailNotes
     - noSendMessageToRecipients
     - noUpdateNotebook
     - noExpungeNotebook
     - noSetDefaultNotebook
     - noSetNotebookStack
     - noPublishToPublic
     - noPublishToBusinessLibrary
     - noCreateTags
     - noUpdateTags
     - noExpungeTags
     - noSetParentTag
     - noCreateSharedNotebooks
     - updateWhichSharedNotebookRestrictions
     - expungeWhichSharedNotebookRestrictions
     - noShareNotesWithBusiness
     - noRenameNotebook
     - noSetInMyList
     - noChangeContact
     - canMoveToContainerRestrictions
     - noSetReminderNotifyEmail
     - noSetReminderNotifyInApp
     - noSetRecipientSettingsStack
     - noCanMoveNote

    """
    thrift_spec: typing.Any = None


    def __init__(self, noReadNotes: typing.Optional[bool] = None, noCreateNotes: typing.Optional[bool] = None, noUpdateNotes: typing.Optional[bool] = None, noExpungeNotes: typing.Optional[bool] = None, noShareNotes: typing.Optional[bool] = None, noEmailNotes: typing.Optional[bool] = None, noSendMessageToRecipients: typing.Optional[bool] = None, noUpdateNotebook: typing.Optional[bool] = None, noExpungeNotebook: typing.Optional[bool] = None, noSetDefaultNotebook: typing.Optional[bool] = None, noSetNotebookStack: typing.Optional[bool] = None, noPublishToPublic: typing.Optional[bool] = None, noPublishToBusinessLibrary: typing.Optional[bool] = None, noCreateTags: typing.Optional[bool] = None, noUpdateTags: typing.Optional[bool] = None, noExpungeTags: typing.Optional[bool] = None, noSetParentTag: typing.Optional[bool] = None, noCreateSharedNotebooks: typing.Optional[bool] = None, updateWhichSharedNotebookRestrictions: typing.Optional[SharedNotebookInstanceRestrictions] = None, expungeWhichSharedNotebookRestrictions: typing.Optional[SharedNotebookInstanceRestrictions] = None, noShareNotesWithBusiness: typing.Optional[bool] = None, noRenameNotebook: typing.Optional[bool] = None, noSetInMyList: typing.Optional[bool] = None, noChangeContact: typing.Optional[bool] = None, canMoveToContainerRestrictions: typing.Optional[CanMoveToContainerRestrictions] = None, noSetReminderNotifyEmail: typing.Optional[bool] = None, noSetReminderNotifyInApp: typing.Optional[bool] = None, noSetRecipientSettingsStack: typing.Optional[bool] = None, noCanMoveNote: typing.Optional[bool] = None,):
        self.noReadNotes: typing.Optional[bool] = noReadNotes
        self.noCreateNotes: typing.Optional[bool] = noCreateNotes
        self.noUpdateNotes: typing.Optional[bool] = noUpdateNotes
        self.noExpungeNotes: typing.Optional[bool] = noExpungeNotes
        self.noShareNotes: typing.Optional[bool] = noShareNotes
        self.noEmailNotes: typing.Optional[bool] = noEmailNotes
        self.noSendMessageToRecipients: typing.Optional[bool] = noSendMessageToRecipients
        self.noUpdateNotebook: typing.Optional[bool] = noUpdateNotebook
        self.noExpungeNotebook: typing.Optional[bool] = noExpungeNotebook
        self.noSetDefaultNotebook: typing.Optional[bool] = noSetDefaultNotebook
        self.noSetNotebookStack: typing.Optional[bool] = noSetNotebookStack
        self.noPublishToPublic: typing.Optional[bool] = noPublishToPublic
        self.noPublishToBusinessLibrary: typing.Optional[bool] = noPublishToBusinessLibrary
        self.noCreateTags: typing.Optional[bool] = noCreateTags
        self.noUpdateTags: typing.Optional[bool] = noUpdateTags
        self.noExpungeTags: typing.Optional[bool] = noExpungeTags
        self.noSetParentTag: typing.Optional[bool] = noSetParentTag
        self.noCreateSharedNotebooks: typing.Optional[bool] = noCreateSharedNotebooks
        self.updateWhichSharedNotebookRestrictions: typing.Optional[SharedNotebookInstanceRestrictions] = updateWhichSharedNotebookRestrictions
        self.expungeWhichSharedNotebookRestrictions: typing.Optional[SharedNotebookInstanceRestrictions] = expungeWhichSharedNotebookRestrictions
        self.noShareNotesWithBusiness: typing.Optional[bool] = noShareNotesWithBusiness
        self.noRenameNotebook: typing.Optional[bool] = noRenameNotebook
        self.noSetInMyList: typing.Optional[bool] = noSetInMyList
        self.noChangeContact: typing.Optional[bool] = noChangeContact
        self.canMoveToContainerRestrictions: typing.Optional[CanMoveToContainerRestrictions] = canMoveToContainerRestrictions
        self.noSetReminderNotifyEmail: typing.Optional[bool] = noSetReminderNotifyEmail
        self.noSetReminderNotifyInApp: typing.Optional[bool] = noSetReminderNotifyInApp
        self.noSetRecipientSettingsStack: typing.Optional[bool] = noSetRecipientSettingsStack
        self.noCanMoveNote: typing.Optional[bool] = noCanMoveNote

    def __setattr__(self, name, value):
        if name == "updateWhichSharedNotebookRestrictions":
            super().__setattr__(name, value if hasattr(value, 'value') else SharedNotebookInstanceRestrictions.__members__.get(value))
            return
        if name == "expungeWhichSharedNotebookRestrictions":
            super().__setattr__(name, value if hasattr(value, 'value') else SharedNotebookInstanceRestrictions.__members__.get(value))
            return
        super().__setattr__(name, value)


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.noReadNotes = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.noCreateNotes = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.noUpdateNotes = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.noExpungeNotes = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.noShareNotes = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.noEmailNotes = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.noSendMessageToRecipients = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.noUpdateNotebook = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.BOOL:
                    self.noExpungeNotebook = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.BOOL:
                    self.noSetDefaultNotebook = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.BOOL:
                    self.noSetNotebookStack = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.BOOL:
                    self.noPublishToPublic = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.BOOL:
                    self.noPublishToBusinessLibrary = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.BOOL:
                    self.noCreateTags = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.BOOL:
                    self.noUpdateTags = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.BOOL:
                    self.noExpungeTags = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.BOOL:
                    self.noSetParentTag = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.BOOL:
                    self.noCreateSharedNotebooks = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.I32:
                    self.updateWhichSharedNotebookRestrictions = SharedNotebookInstanceRestrictions(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.I32:
                    self.expungeWhichSharedNotebookRestrictions = SharedNotebookInstanceRestrictions(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.BOOL:
                    self.noShareNotesWithBusiness = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.BOOL:
                    self.noRenameNotebook = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 23:
                if ftype == TType.BOOL:
                    self.noSetInMyList = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 24:
                if ftype == TType.BOOL:
                    self.noChangeContact = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 26:
                if ftype == TType.STRUCT:
                    self.canMoveToContainerRestrictions = CanMoveToContainerRestrictions()
                    self.canMoveToContainerRestrictions.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 27:
                if ftype == TType.BOOL:
                    self.noSetReminderNotifyEmail = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 28:
                if ftype == TType.BOOL:
                    self.noSetReminderNotifyInApp = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 29:
                if ftype == TType.BOOL:
                    self.noSetRecipientSettingsStack = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 30:
                if ftype == TType.BOOL:
                    self.noCanMoveNote = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NotebookRestrictions')
        if self.noReadNotes is not None:
            oprot.writeFieldBegin('noReadNotes', TType.BOOL, 1)
            oprot.writeBool(self.noReadNotes)
            oprot.writeFieldEnd()
        if self.noCreateNotes is not None:
            oprot.writeFieldBegin('noCreateNotes', TType.BOOL, 2)
            oprot.writeBool(self.noCreateNotes)
            oprot.writeFieldEnd()
        if self.noUpdateNotes is not None:
            oprot.writeFieldBegin('noUpdateNotes', TType.BOOL, 3)
            oprot.writeBool(self.noUpdateNotes)
            oprot.writeFieldEnd()
        if self.noExpungeNotes is not None:
            oprot.writeFieldBegin('noExpungeNotes', TType.BOOL, 4)
            oprot.writeBool(self.noExpungeNotes)
            oprot.writeFieldEnd()
        if self.noShareNotes is not None:
            oprot.writeFieldBegin('noShareNotes', TType.BOOL, 5)
            oprot.writeBool(self.noShareNotes)
            oprot.writeFieldEnd()
        if self.noEmailNotes is not None:
            oprot.writeFieldBegin('noEmailNotes', TType.BOOL, 6)
            oprot.writeBool(self.noEmailNotes)
            oprot.writeFieldEnd()
        if self.noSendMessageToRecipients is not None:
            oprot.writeFieldBegin('noSendMessageToRecipients', TType.BOOL, 7)
            oprot.writeBool(self.noSendMessageToRecipients)
            oprot.writeFieldEnd()
        if self.noUpdateNotebook is not None:
            oprot.writeFieldBegin('noUpdateNotebook', TType.BOOL, 8)
            oprot.writeBool(self.noUpdateNotebook)
            oprot.writeFieldEnd()
        if self.noExpungeNotebook is not None:
            oprot.writeFieldBegin('noExpungeNotebook', TType.BOOL, 9)
            oprot.writeBool(self.noExpungeNotebook)
            oprot.writeFieldEnd()
        if self.noSetDefaultNotebook is not None:
            oprot.writeFieldBegin('noSetDefaultNotebook', TType.BOOL, 10)
            oprot.writeBool(self.noSetDefaultNotebook)
            oprot.writeFieldEnd()
        if self.noSetNotebookStack is not None:
            oprot.writeFieldBegin('noSetNotebookStack', TType.BOOL, 11)
            oprot.writeBool(self.noSetNotebookStack)
            oprot.writeFieldEnd()
        if self.noPublishToPublic is not None:
            oprot.writeFieldBegin('noPublishToPublic', TType.BOOL, 12)
            oprot.writeBool(self.noPublishToPublic)
            oprot.writeFieldEnd()
        if self.noPublishToBusinessLibrary is not None:
            oprot.writeFieldBegin('noPublishToBusinessLibrary', TType.BOOL, 13)
            oprot.writeBool(self.noPublishToBusinessLibrary)
            oprot.writeFieldEnd()
        if self.noCreateTags is not None:
            oprot.writeFieldBegin('noCreateTags', TType.BOOL, 14)
            oprot.writeBool(self.noCreateTags)
            oprot.writeFieldEnd()
        if self.noUpdateTags is not None:
            oprot.writeFieldBegin('noUpdateTags', TType.BOOL, 15)
            oprot.writeBool(self.noUpdateTags)
            oprot.writeFieldEnd()
        if self.noExpungeTags is not None:
            oprot.writeFieldBegin('noExpungeTags', TType.BOOL, 16)
            oprot.writeBool(self.noExpungeTags)
            oprot.writeFieldEnd()
        if self.noSetParentTag is not None:
            oprot.writeFieldBegin('noSetParentTag', TType.BOOL, 17)
            oprot.writeBool(self.noSetParentTag)
            oprot.writeFieldEnd()
        if self.noCreateSharedNotebooks is not None:
            oprot.writeFieldBegin('noCreateSharedNotebooks', TType.BOOL, 18)
            oprot.writeBool(self.noCreateSharedNotebooks)
            oprot.writeFieldEnd()
        if self.updateWhichSharedNotebookRestrictions is not None:
            oprot.writeFieldBegin('updateWhichSharedNotebookRestrictions', TType.I32, 19)
            oprot.writeI32(self.updateWhichSharedNotebookRestrictions.value)
            oprot.writeFieldEnd()
        if self.expungeWhichSharedNotebookRestrictions is not None:
            oprot.writeFieldBegin('expungeWhichSharedNotebookRestrictions', TType.I32, 20)
            oprot.writeI32(self.expungeWhichSharedNotebookRestrictions.value)
            oprot.writeFieldEnd()
        if self.noShareNotesWithBusiness is not None:
            oprot.writeFieldBegin('noShareNotesWithBusiness', TType.BOOL, 21)
            oprot.writeBool(self.noShareNotesWithBusiness)
            oprot.writeFieldEnd()
        if self.noRenameNotebook is not None:
            oprot.writeFieldBegin('noRenameNotebook', TType.BOOL, 22)
            oprot.writeBool(self.noRenameNotebook)
            oprot.writeFieldEnd()
        if self.noSetInMyList is not None:
            oprot.writeFieldBegin('noSetInMyList', TType.BOOL, 23)
            oprot.writeBool(self.noSetInMyList)
            oprot.writeFieldEnd()
        if self.noChangeContact is not None:
            oprot.writeFieldBegin('noChangeContact', TType.BOOL, 24)
            oprot.writeBool(self.noChangeContact)
            oprot.writeFieldEnd()
        if self.canMoveToContainerRestrictions is not None:
            oprot.writeFieldBegin('canMoveToContainerRestrictions', TType.STRUCT, 26)
            self.canMoveToContainerRestrictions.write(oprot)
            oprot.writeFieldEnd()
        if self.noSetReminderNotifyEmail is not None:
            oprot.writeFieldBegin('noSetReminderNotifyEmail', TType.BOOL, 27)
            oprot.writeBool(self.noSetReminderNotifyEmail)
            oprot.writeFieldEnd()
        if self.noSetReminderNotifyInApp is not None:
            oprot.writeFieldBegin('noSetReminderNotifyInApp', TType.BOOL, 28)
            oprot.writeBool(self.noSetReminderNotifyInApp)
            oprot.writeFieldEnd()
        if self.noSetRecipientSettingsStack is not None:
            oprot.writeFieldBegin('noSetRecipientSettingsStack', TType.BOOL, 29)
            oprot.writeBool(self.noSetRecipientSettingsStack)
            oprot.writeFieldEnd()
        if self.noCanMoveNote is not None:
            oprot.writeFieldBegin('noCanMoveNote', TType.BOOL, 30)
            oprot.writeBool(self.noCanMoveNote)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Notebook(object):
    """
    A unique container for a set of notes.
    <dl>
    <dt>guid</dt>
      <dd>The unique identifier of this notebook.
      <br/>
      Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
      <br/>
      Regex:  EDAM_GUID_REGEX
      </dd>

    <dt>name</dt>
      <dd>A sequence of characters representing the name of the
      notebook.  May be changed by clients, but the account may not contain two
      notebooks with names that are equal via a case-insensitive comparison.
      Can't begin or end with a space.
      <br/>
      Length:  EDAM_NOTEBOOK_NAME_LEN_MIN - EDAM_NOTEBOOK_NAME_LEN_MAX
      <br/>
      Regex:  EDAM_NOTEBOOK_NAME_REGEX
      </dd>

    <dt>updateSequenceNum</dt>
      <dd>A number identifying the last transaction to
      modify the state of this object.  The USN values are sequential within an
      account, and can be used to compare the order of modifications within the
      service.
      </dd>

    <dt>defaultNotebook</dt>
      <dd>If true, this notebook should be used for new notes
      whenever the user has not (or cannot) specify a desired target notebook.
      For example, if a note is submitted via SMTP email.
      The service will maintain at most one defaultNotebook per account.
      If a second notebook is created or updated with defaultNotebook set to
      true, the service will automatically update the prior notebook's
      defaultNotebook field to false.  If the default notebook is deleted
      (i.e. "active" set to false), the "defaultNotebook" field will be
      set to false by the service.  If the account has no default notebook
      set, the service will use the most recent notebook as the default.
      </dd>

    <dt>serviceCreated</dt>
      <dd>The time when this notebook was created on the
      service. This will be set on the service during creation, and the service
      will provide this value when it returns a Notebook to a client.
      The service will ignore this value if it is sent by clients.
      </dd>

    <dt>serviceUpdated</dt>
      <dd>The time when this notebook was last modified on the
      service.  This will be set on the service during creation, and the service
      will provide this value when it returns a Notebook to a client.
      The service will ignore this value if it is sent by clients.
      </dd>

    <dt>publishing</dt>
      <dd>If the Notebook has been opened for public access, then this will point to the set of
      publishing information for the Notebook (URI, description, etc.). A Notebook cannot be
      published without providing this information, but it will persist for later use if publishing
      is ever disabled on the Notebook. Clients that do not wish to change the publishing behavior
      of a Notebook should not set this value when calling NoteStore.updateNotebook().
      Note that this structure is never populated for business notebooks, see the businessNotebook
      field.
      </dd>

    <dt>published</dt>
      <dd>If this is set to true, then the Notebook will be
      accessible either to the public, or for business users to their business,
      via the 'publishing' or 'businessNotebook' specifications, which must also be set. If this is
      set to false, the Notebook will not be available to the public (or business).
      Clients that do not wish to change the publishing behavior of a Notebook
      should not set this value when calling NoteStore.updateNotebook().
      </dd>

    <dt>stack</dt>
      <dd>If this is set, then the notebook is visually contained within a stack
      of notebooks with this name.  All notebooks in the same account with the
      same 'stack' field are considered to be in the same stack.
      Notebooks with no stack set are "top level" and not contained within a
      stack.
      </dd>

    <dt>sharedNotebookIds</dt>
      <dd><i>DEPRECATED</i> - replaced by sharedNotebooks.</dd>

    <dt>sharedNotebooks</dt>
      <dd>The list of recipients to whom this notebook has been shared
      (one SharedNotebook object per recipient email address). This field will
      be unset if you do not have permission to access this data. If you are
      accessing the notebook as the owner or via a shared notebook that is
      modifiable, then you have access to this data and the value will be set.
      This field is read-only. Clients may not make changes to shared notebooks
      via this field.
      </dd>

    <dt>businessNotebook</dt>
      <dd>If the notebook is part of a business account and has been shared with the entire
      business, this will contain sharing information. The presence or absence of this field
      is not a reliable test of whether a given notebook is in fact a business notebook - the
      field is only used when a notebook is or has been shared with the entire business.
      </dd>

    <dt>contact</dt>
      <dd>Intended for use with Business accounts, this field identifies the user who
      has been designated as the "contact".  For notebooks created in business
      accounts, the server will automatically set this value to the user who created
      the notebook unless Notebook.contact.username has been set, in which that value
      will be used.  When updating a notebook, it is common to leave Notebook.contact
      field unset, indicating that no change to the value is being requested and that
      the existing value, if any, should be preserved.
      </dd>

    <dt>recipientSettings</dt>
      <dd>This represents the preferences/settings that a recipient has set for this
      notebook. These are intended to be changed only by the recipient, and each
      recipient has their own recipient settings.
      </dd>
    </dl>

    Attributes:
     - guid
     - name
     - updateSequenceNum
     - defaultNotebook
     - serviceCreated
     - serviceUpdated
     - publishing
     - published
     - stack
     - sharedNotebookIds
     - sharedNotebooks
     - businessNotebook
     - contact
     - restrictions
     - recipientSettings

    """
    thrift_spec: typing.Any = None


    def __init__(self, guid: typing.Optional[str] = None, name: typing.Optional[str] = None, updateSequenceNum: typing.Optional[int] = None, defaultNotebook: typing.Optional[bool] = None, serviceCreated: typing.Optional[int] = None, serviceUpdated: typing.Optional[int] = None, publishing: typing.Optional[Publishing] = None, published: typing.Optional[bool] = None, stack: typing.Optional[str] = None, sharedNotebookIds: typing.Optional[list[int]] = None, sharedNotebooks: typing.Optional[list[SharedNotebook]] = None, businessNotebook: typing.Optional[BusinessNotebook] = None, contact: typing.Optional[User] = None, restrictions: typing.Optional[NotebookRestrictions] = None, recipientSettings: typing.Optional[NotebookRecipientSettings] = None,):
        self.guid: typing.Optional[str] = guid
        self.name: typing.Optional[str] = name
        self.updateSequenceNum: typing.Optional[int] = updateSequenceNum
        self.defaultNotebook: typing.Optional[bool] = defaultNotebook
        self.serviceCreated: typing.Optional[int] = serviceCreated
        self.serviceUpdated: typing.Optional[int] = serviceUpdated
        self.publishing: typing.Optional[Publishing] = publishing
        self.published: typing.Optional[bool] = published
        self.stack: typing.Optional[str] = stack
        self.sharedNotebookIds: typing.Optional[list[int]] = sharedNotebookIds
        self.sharedNotebooks: typing.Optional[list[SharedNotebook]] = sharedNotebooks
        self.businessNotebook: typing.Optional[BusinessNotebook] = businessNotebook
        self.contact: typing.Optional[User] = contact
        self.restrictions: typing.Optional[NotebookRestrictions] = restrictions
        self.recipientSettings: typing.Optional[NotebookRecipientSettings] = recipientSettings

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.updateSequenceNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.defaultNotebook = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.serviceCreated = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.serviceUpdated = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.publishing = Publishing()
                    self.publishing.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.BOOL:
                    self.published = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRING:
                    self.stack = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.LIST:
                    self.sharedNotebookIds = []
                    (_etype70, _size67) = iprot.readListBegin()
                    for _i71 in range(_size67):
                        _elem72 = iprot.readI64()
                        self.sharedNotebookIds.append(_elem72)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.LIST:
                    self.sharedNotebooks = []
                    (_etype76, _size73) = iprot.readListBegin()
                    for _i77 in range(_size73):
                        _elem78 = SharedNotebook()
                        _elem78.read(iprot)
                        self.sharedNotebooks.append(_elem78)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.STRUCT:
                    self.businessNotebook = BusinessNotebook()
                    self.businessNotebook.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.STRUCT:
                    self.contact = User()
                    self.contact.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.STRUCT:
                    self.restrictions = NotebookRestrictions()
                    self.restrictions.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.STRUCT:
                    self.recipientSettings = NotebookRecipientSettings()
                    self.recipientSettings.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Notebook')
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 1)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.updateSequenceNum is not None:
            oprot.writeFieldBegin('updateSequenceNum', TType.I32, 5)
            oprot.writeI32(self.updateSequenceNum)
            oprot.writeFieldEnd()
        if self.defaultNotebook is not None:
            oprot.writeFieldBegin('defaultNotebook', TType.BOOL, 6)
            oprot.writeBool(self.defaultNotebook)
            oprot.writeFieldEnd()
        if self.serviceCreated is not None:
            oprot.writeFieldBegin('serviceCreated', TType.I64, 7)
            oprot.writeI64(self.serviceCreated)
            oprot.writeFieldEnd()
        if self.serviceUpdated is not None:
            oprot.writeFieldBegin('serviceUpdated', TType.I64, 8)
            oprot.writeI64(self.serviceUpdated)
            oprot.writeFieldEnd()
        if self.publishing is not None:
            oprot.writeFieldBegin('publishing', TType.STRUCT, 10)
            self.publishing.write(oprot)
            oprot.writeFieldEnd()
        if self.published is not None:
            oprot.writeFieldBegin('published', TType.BOOL, 11)
            oprot.writeBool(self.published)
            oprot.writeFieldEnd()
        if self.stack is not None:
            oprot.writeFieldBegin('stack', TType.STRING, 12)
            oprot.writeString(self.stack.encode('utf-8') if sys.version_info[0] == 2 else self.stack)
            oprot.writeFieldEnd()
        if self.sharedNotebookIds is not None:
            oprot.writeFieldBegin('sharedNotebookIds', TType.LIST, 13)
            oprot.writeListBegin(TType.I64, len(self.sharedNotebookIds))
            for iter79 in self.sharedNotebookIds:
                oprot.writeI64(iter79)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sharedNotebooks is not None:
            oprot.writeFieldBegin('sharedNotebooks', TType.LIST, 14)
            oprot.writeListBegin(TType.STRUCT, len(self.sharedNotebooks))
            for iter80 in self.sharedNotebooks:
                iter80.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.businessNotebook is not None:
            oprot.writeFieldBegin('businessNotebook', TType.STRUCT, 15)
            self.businessNotebook.write(oprot)
            oprot.writeFieldEnd()
        if self.contact is not None:
            oprot.writeFieldBegin('contact', TType.STRUCT, 16)
            self.contact.write(oprot)
            oprot.writeFieldEnd()
        if self.restrictions is not None:
            oprot.writeFieldBegin('restrictions', TType.STRUCT, 17)
            self.restrictions.write(oprot)
            oprot.writeFieldEnd()
        if self.recipientSettings is not None:
            oprot.writeFieldBegin('recipientSettings', TType.STRUCT, 18)
            self.recipientSettings.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LinkedNotebook(object):
    """
    A link in a user's account that refers them to a public or
    individual shared notebook in another user's account.

    <dl>
    <dt>shareName</dt>
    <dd>The display name of the shared notebook. The link owner can change this.</dd>

    <dt>username</dt>
    <dd>The username of the user who owns the shared or public notebook.</dd>

    <dt>shardId</dt>
    <dd>The shard ID of the notebook if the notebook is not public.</dt>

    <dt>uri</dt>
    <dd>The identifier of the public notebook.</dd>

    <dt>guid</dt>
      <dd>The unique identifier of this linked notebook.  Will be set whenever
      a linked notebook is retrieved from the service, but may be null when a client
      is creating a linked notebook.
      <br/>
      Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
      <br/>
      Regex:  EDAM_GUID_REGEX
      </dd>

    <dt>updateSequenceNum</dt>
      <dd>A number identifying the last transaction to
      modify the state of this object.  The USN values are sequential within an
      account, and can be used to compare the order of modifications within the
      service.
      </dd>

    <dt>noteStoreUrl</dt>
      <dd>
      This field will contain the full URL that clients should use to make
      NoteStore requests to the server shard that contains that notebook's data.
      I.e. this is the URL that should be used to create the Thrift HTTP client
      transport to send messages to the NoteStore service for the account.
      </dd>

    <dt>webApiUrlPrefix:</dt>
      <dd>
      This field will contain the initial part of the URLs that should be used
      to make requests to Evernote's thin client "web API", which provide
      optimized operations for clients that aren't capable of manipulating
      the full contents of accounts via the full Thrift data model. Clients
      should concatenate the relative path for the various servlets onto the
      end of this string to construct the full URL, as documented on our
      developer web site.
      </dd>

    <dt>stack</dt>
      <dd>If this is set, then the notebook is visually contained within a stack
      of notebooks with this name.  All notebooks in the same account with the
      same 'stack' field are considered to be in the same stack.
      Notebooks with no stack set are "top level" and not contained within a
      stack.  The link owner can change this and this field is for the benefit
      of the link owner.
      </dd>

    <dt>businessId</dt>
      <dd>If set, this will be the unique identifier for the business that owns
      the notebook to which the linked notebook refers.</dd>

    <dt>sharedNotebookGlobalId</dt>
      <dd>The globally unique identifier (globalId) of the shared notebook that
      corresponds to the share key, or the GUID of the Notebook that the linked notebook
      refers to. This field must be filled in with the SharedNotebook.globalId or
      Notebook.GUID value when creating new LinkedNotebooks. This field replaces the
      deprecated "shareKey" field.
      </dd>
    </dl>

    Attributes:
     - shareName
     - username
     - shardId
     - sharedNotebookGlobalId
     - uri
     - guid
     - updateSequenceNum
     - noteStoreUrl
     - webApiUrlPrefix
     - stack
     - businessId

    """
    thrift_spec: typing.Any = None


    def __init__(self, shareName: typing.Optional[str] = None, username: typing.Optional[str] = None, shardId: typing.Optional[str] = None, sharedNotebookGlobalId: typing.Optional[str] = None, uri: typing.Optional[str] = None, guid: typing.Optional[str] = None, updateSequenceNum: typing.Optional[int] = None, noteStoreUrl: typing.Optional[str] = None, webApiUrlPrefix: typing.Optional[str] = None, stack: typing.Optional[str] = None, businessId: typing.Optional[int] = None,):
        self.shareName: typing.Optional[str] = shareName
        self.username: typing.Optional[str] = username
        self.shardId: typing.Optional[str] = shardId
        self.sharedNotebookGlobalId: typing.Optional[str] = sharedNotebookGlobalId
        self.uri: typing.Optional[str] = uri
        self.guid: typing.Optional[str] = guid
        self.updateSequenceNum: typing.Optional[int] = updateSequenceNum
        self.noteStoreUrl: typing.Optional[str] = noteStoreUrl
        self.webApiUrlPrefix: typing.Optional[str] = webApiUrlPrefix
        self.stack: typing.Optional[str] = stack
        self.businessId: typing.Optional[int] = businessId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.shareName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.shardId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.sharedNotebookGlobalId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.uri = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.updateSequenceNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.noteStoreUrl = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.webApiUrlPrefix = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRING:
                    self.stack = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I32:
                    self.businessId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LinkedNotebook')
        if self.shareName is not None:
            oprot.writeFieldBegin('shareName', TType.STRING, 2)
            oprot.writeString(self.shareName.encode('utf-8') if sys.version_info[0] == 2 else self.shareName)
            oprot.writeFieldEnd()
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 3)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        if self.shardId is not None:
            oprot.writeFieldBegin('shardId', TType.STRING, 4)
            oprot.writeString(self.shardId.encode('utf-8') if sys.version_info[0] == 2 else self.shardId)
            oprot.writeFieldEnd()
        if self.sharedNotebookGlobalId is not None:
            oprot.writeFieldBegin('sharedNotebookGlobalId', TType.STRING, 5)
            oprot.writeString(self.sharedNotebookGlobalId.encode('utf-8') if sys.version_info[0] == 2 else self.sharedNotebookGlobalId)
            oprot.writeFieldEnd()
        if self.uri is not None:
            oprot.writeFieldBegin('uri', TType.STRING, 6)
            oprot.writeString(self.uri.encode('utf-8') if sys.version_info[0] == 2 else self.uri)
            oprot.writeFieldEnd()
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 7)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        if self.updateSequenceNum is not None:
            oprot.writeFieldBegin('updateSequenceNum', TType.I32, 8)
            oprot.writeI32(self.updateSequenceNum)
            oprot.writeFieldEnd()
        if self.noteStoreUrl is not None:
            oprot.writeFieldBegin('noteStoreUrl', TType.STRING, 9)
            oprot.writeString(self.noteStoreUrl.encode('utf-8') if sys.version_info[0] == 2 else self.noteStoreUrl)
            oprot.writeFieldEnd()
        if self.webApiUrlPrefix is not None:
            oprot.writeFieldBegin('webApiUrlPrefix', TType.STRING, 10)
            oprot.writeString(self.webApiUrlPrefix.encode('utf-8') if sys.version_info[0] == 2 else self.webApiUrlPrefix)
            oprot.writeFieldEnd()
        if self.stack is not None:
            oprot.writeFieldBegin('stack', TType.STRING, 11)
            oprot.writeString(self.stack.encode('utf-8') if sys.version_info[0] == 2 else self.stack)
            oprot.writeFieldEnd()
        if self.businessId is not None:
            oprot.writeFieldBegin('businessId', TType.I32, 12)
            oprot.writeI32(self.businessId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NotebookDescriptor(object):
    """
    A structure that describes a notebook or a user's relationship with
    a notebook. NotebookDescriptor is expected to remain a lighter-weight
    structure when compared to Notebook.
    <dl>
    <dt>guid</dt>
      <dd>The unique identifier of the notebook.
      </dd>

    <dt>notebookDisplayName</dt>
      <dd>A sequence of characters representing the name of the
      notebook.
      </dd>

    <dt>contactName</dt>
      <dd>The User.name value of the notebook's "contact".
      </dd>

    <dt>hasSharedNotebook</dt>
      <dd>Whether a SharedNotebook record exists between the calling user and this
      notebook.
      </dd>

    <dt>joinedUserCount</dt>
      <dd>The number of users who have joined this notebook.
      </dd>

    </dl>

    Attributes:
     - guid
     - notebookDisplayName
     - contactName
     - hasSharedNotebook
     - joinedUserCount

    """
    thrift_spec: typing.Any = None


    def __init__(self, guid: typing.Optional[str] = None, notebookDisplayName: typing.Optional[str] = None, contactName: typing.Optional[str] = None, hasSharedNotebook: typing.Optional[bool] = None, joinedUserCount: typing.Optional[int] = None,):
        self.guid: typing.Optional[str] = guid
        self.notebookDisplayName: typing.Optional[str] = notebookDisplayName
        self.contactName: typing.Optional[str] = contactName
        self.hasSharedNotebook: typing.Optional[bool] = hasSharedNotebook
        self.joinedUserCount: typing.Optional[int] = joinedUserCount

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.notebookDisplayName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.contactName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.hasSharedNotebook = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.joinedUserCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NotebookDescriptor')
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 1)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        if self.notebookDisplayName is not None:
            oprot.writeFieldBegin('notebookDisplayName', TType.STRING, 2)
            oprot.writeString(self.notebookDisplayName.encode('utf-8') if sys.version_info[0] == 2 else self.notebookDisplayName)
            oprot.writeFieldEnd()
        if self.contactName is not None:
            oprot.writeFieldBegin('contactName', TType.STRING, 3)
            oprot.writeString(self.contactName.encode('utf-8') if sys.version_info[0] == 2 else self.contactName)
            oprot.writeFieldEnd()
        if self.hasSharedNotebook is not None:
            oprot.writeFieldBegin('hasSharedNotebook', TType.BOOL, 4)
            oprot.writeBool(self.hasSharedNotebook)
            oprot.writeFieldEnd()
        if self.joinedUserCount is not None:
            oprot.writeFieldBegin('joinedUserCount', TType.I32, 5)
            oprot.writeI32(self.joinedUserCount)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UserProfile(object):
    """
    This structure represents profile information for a user in a business.

    <dl>
    <dt>id</dt>
    <dd>The numeric identifier that uniquely identifies a user.</dd>

    <dt>name</dt>
    <dd>The full name of the user.</dd>

    <dt>email</dt>
    <dd>The user's business email address. If the user has not registered their business
      email address, this field will be empty.
    </dd>

    <dt>username</dt>
    <dd>The user's Evernote username.</dd>

    <dt>attributes</dt>
    <dd>The user's business specific attributes.</dd>

    <dt>joined</dt>
    <dd>The time when the user joined the business</dd>

    <dt>photoLastUpdated</dt>
    <dd>The time when the user's profile photo was most recently updated</dd>

    <dt>photoUrl</dt>
    <dd>A URL identifying a copy of the user's current profile photo</dd>

    <dt>role</dt>
    <dd>The BusinessUserRole for the user</dd>

    <dt>status</dt>
    <dd>The BusinessUserStatus for the user</dd>

    </dl>

    Attributes:
     - id
     - name
     - email
     - username
     - attributes
     - joined
     - photoLastUpdated
     - photoUrl
     - role
     - status

    """
    thrift_spec: typing.Any = None


    def __init__(self, id: typing.Optional[int] = None, name: typing.Optional[str] = None, email: typing.Optional[str] = None, username: typing.Optional[str] = None, attributes: typing.Optional[BusinessUserAttributes] = None, joined: typing.Optional[int] = None, photoLastUpdated: typing.Optional[int] = None, photoUrl: typing.Optional[str] = None, role: typing.Optional[BusinessUserRole] = None, status: typing.Optional[BusinessUserStatus] = None,):
        self.id: typing.Optional[int] = id
        self.name: typing.Optional[str] = name
        self.email: typing.Optional[str] = email
        self.username: typing.Optional[str] = username
        self.attributes: typing.Optional[BusinessUserAttributes] = attributes
        self.joined: typing.Optional[int] = joined
        self.photoLastUpdated: typing.Optional[int] = photoLastUpdated
        self.photoUrl: typing.Optional[str] = photoUrl
        self.role: typing.Optional[BusinessUserRole] = role
        self.status: typing.Optional[BusinessUserStatus] = status

    def __setattr__(self, name, value):
        if name == "role":
            super().__setattr__(name, value if hasattr(value, 'value') else BusinessUserRole.__members__.get(value))
            return
        if name == "status":
            super().__setattr__(name, value if hasattr(value, 'value') else BusinessUserStatus.__members__.get(value))
            return
        super().__setattr__(name, value)


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.email = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.attributes = BusinessUserAttributes()
                    self.attributes.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.joined = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.photoLastUpdated = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.photoUrl = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.role = BusinessUserRole(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.status = BusinessUserStatus(iprot.readI32())
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UserProfile')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I32, 1)
            oprot.writeI32(self.id)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.email is not None:
            oprot.writeFieldBegin('email', TType.STRING, 3)
            oprot.writeString(self.email.encode('utf-8') if sys.version_info[0] == 2 else self.email)
            oprot.writeFieldEnd()
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 4)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.STRUCT, 5)
            self.attributes.write(oprot)
            oprot.writeFieldEnd()
        if self.joined is not None:
            oprot.writeFieldBegin('joined', TType.I64, 6)
            oprot.writeI64(self.joined)
            oprot.writeFieldEnd()
        if self.photoLastUpdated is not None:
            oprot.writeFieldBegin('photoLastUpdated', TType.I64, 7)
            oprot.writeI64(self.photoLastUpdated)
            oprot.writeFieldEnd()
        if self.photoUrl is not None:
            oprot.writeFieldBegin('photoUrl', TType.STRING, 8)
            oprot.writeString(self.photoUrl.encode('utf-8') if sys.version_info[0] == 2 else self.photoUrl)
            oprot.writeFieldEnd()
        if self.role is not None:
            oprot.writeFieldBegin('role', TType.I32, 9)
            oprot.writeI32(self.role.value)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.I32, 10)
            oprot.writeI32(self.status.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RelatedContentImage(object):
    """
    An external image that can be shown with a related content snippet,
    usually either a JPEG or PNG image. It is up to the client which image(s) are shown,
    depending on available screen real estate, resolution and aspect ratio.

    <dl>
     <dt>url</dt>
       <dd>The external URL of the image</dd>
     <dt>width</dt>
       <dd>The width of the image, in pixels.</dd>
     <dt>height</dt>
       <dd>The height of the image, in pixels.</dd>
     <dt>pixelRatio</dt>
       <dd>the pixel ratio (usually either 1.0, 1.5 or 2.0)</dd>
     <dt>fileSize</dt>
       <dd>the size of the image file, in bytes</dd>
    </dl>

    Attributes:
     - url
     - width
     - height
     - pixelRatio
     - fileSize

    """
    thrift_spec: typing.Any = None


    def __init__(self, url: typing.Optional[str] = None, width: typing.Optional[int] = None, height: typing.Optional[int] = None, pixelRatio: typing.Optional[float] = None, fileSize: typing.Optional[int] = None,):
        self.url: typing.Optional[str] = url
        self.width: typing.Optional[int] = width
        self.height: typing.Optional[int] = height
        self.pixelRatio: typing.Optional[float] = pixelRatio
        self.fileSize: typing.Optional[int] = fileSize

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.url = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.width = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.height = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.pixelRatio = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.fileSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RelatedContentImage')
        if self.url is not None:
            oprot.writeFieldBegin('url', TType.STRING, 1)
            oprot.writeString(self.url.encode('utf-8') if sys.version_info[0] == 2 else self.url)
            oprot.writeFieldEnd()
        if self.width is not None:
            oprot.writeFieldBegin('width', TType.I32, 2)
            oprot.writeI32(self.width)
            oprot.writeFieldEnd()
        if self.height is not None:
            oprot.writeFieldBegin('height', TType.I32, 3)
            oprot.writeI32(self.height)
            oprot.writeFieldEnd()
        if self.pixelRatio is not None:
            oprot.writeFieldBegin('pixelRatio', TType.DOUBLE, 4)
            oprot.writeDouble(self.pixelRatio)
            oprot.writeFieldEnd()
        if self.fileSize is not None:
            oprot.writeFieldBegin('fileSize', TType.I32, 5)
            oprot.writeI32(self.fileSize)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RelatedContent(object):
    """
    A structure identifying one snippet of related content (some information that is not
    part of an Evernote account but might still be relevant to the user).

    <dl>

    <dt>contentId</dt>
    <dd>An identifier that uniquely identifies the content.</dd>

    <dt>title</dt>
    <dd>The main title to show.</dd>

    <dt>url</dt>
    <dd>The URL the client can use to retrieve the content.</dd>

    <dt>sourceId</dt>
    <dd>An identifier that uniquely identifies the source.</dd>

    <dt>sourceUrl</dt>
    <dd>A URL the client can access to know more about the source.</dd>

    <dt>sourceFaviconUrl</dt>
    <dd>The favicon URL of the source which the content belongs to.</dd>
    </dl>

    <dt>sourceName</dt>
    <dd>A human-readable name of the source that provided this content.</dd>

    <dt>date</dt>
    <dd>A timestamp telling the user about the recency of the content.</dd>

    <dt>teaser</dt>
    <dd>A teaser text to show to the user; usually the first few sentences of the content,
        excluding the title.</dd>

    <dt>thumbnails</dt>
    <dd>A list of thumbnails the client can show in the snippet.</dd>

    <dt>contentType</dt>
    <dd>The type of this related content.</dd>

    <dt>accessType</dt>
    <dd>An indication of how this content can be accessed. This type influences the
        semantics of the <code>url</code> parameter.</dd>

    <dt>visibleUrl</dt>
    <dd>If set, the client should show this URL to the user, instead of the URL that was
        used to retrieve the content. This URL should be used when opening the content
        in an external browser window, or when sharing with another person.</dd>

    <dt>clipUrl</dt>
    <dd>If set, the client should use this URL for clipping purposes, instead of the URL
        that was used to retrieve the content. The clipUrl may directly point to an .enex
        file, for example.</dd>

    <dt>contact</dt>
    <dd>If set, the client may use this Contact for messaging purposes. This will typically
        only be set for user profiles.</dd>

    <dt>authors</dt>
    <dd>For News articles only. A list of names of the article authors, if available.</dd>

    </dl>

    Attributes:
     - contentId
     - title
     - url
     - sourceId
     - sourceUrl
     - sourceFaviconUrl
     - sourceName
     - date
     - teaser
     - thumbnails
     - contentType
     - accessType
     - visibleUrl
     - clipUrl
     - contact
     - authors

    """
    thrift_spec: typing.Any = None


    def __init__(self, contentId: typing.Optional[str] = None, title: typing.Optional[str] = None, url: typing.Optional[str] = None, sourceId: typing.Optional[str] = None, sourceUrl: typing.Optional[str] = None, sourceFaviconUrl: typing.Optional[str] = None, sourceName: typing.Optional[str] = None, date: typing.Optional[int] = None, teaser: typing.Optional[str] = None, thumbnails: typing.Optional[list[RelatedContentImage]] = None, contentType: typing.Optional[RelatedContentType] = None, accessType: typing.Optional[RelatedContentAccess] = None, visibleUrl: typing.Optional[str] = None, clipUrl: typing.Optional[str] = None, contact: typing.Optional[Contact] = None, authors: typing.Optional[list[str]] = None,):
        self.contentId: typing.Optional[str] = contentId
        self.title: typing.Optional[str] = title
        self.url: typing.Optional[str] = url
        self.sourceId: typing.Optional[str] = sourceId
        self.sourceUrl: typing.Optional[str] = sourceUrl
        self.sourceFaviconUrl: typing.Optional[str] = sourceFaviconUrl
        self.sourceName: typing.Optional[str] = sourceName
        self.date: typing.Optional[int] = date
        self.teaser: typing.Optional[str] = teaser
        self.thumbnails: typing.Optional[list[RelatedContentImage]] = thumbnails
        self.contentType: typing.Optional[RelatedContentType] = contentType
        self.accessType: typing.Optional[RelatedContentAccess] = accessType
        self.visibleUrl: typing.Optional[str] = visibleUrl
        self.clipUrl: typing.Optional[str] = clipUrl
        self.contact: typing.Optional[Contact] = contact
        self.authors: typing.Optional[list[str]] = authors

    def __setattr__(self, name, value):
        if name == "contentType":
            super().__setattr__(name, value if hasattr(value, 'value') else RelatedContentType.__members__.get(value))
            return
        if name == "accessType":
            super().__setattr__(name, value if hasattr(value, 'value') else RelatedContentAccess.__members__.get(value))
            return
        super().__setattr__(name, value)


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.contentId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.title = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.url = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.sourceId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.sourceUrl = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.sourceFaviconUrl = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.sourceName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.date = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.teaser = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.LIST:
                    self.thumbnails = []
                    (_etype84, _size81) = iprot.readListBegin()
                    for _i85 in range(_size81):
                        _elem86 = RelatedContentImage()
                        _elem86.read(iprot)
                        self.thumbnails.append(_elem86)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.contentType = RelatedContentType(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I32:
                    self.accessType = RelatedContentAccess(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRING:
                    self.visibleUrl = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.STRING:
                    self.clipUrl = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.STRUCT:
                    self.contact = Contact()
                    self.contact.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.LIST:
                    self.authors = []
                    (_etype90, _size87) = iprot.readListBegin()
                    for _i91 in range(_size87):
                        _elem92 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.authors.append(_elem92)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RelatedContent')
        if self.contentId is not None:
            oprot.writeFieldBegin('contentId', TType.STRING, 1)
            oprot.writeString(self.contentId.encode('utf-8') if sys.version_info[0] == 2 else self.contentId)
            oprot.writeFieldEnd()
        if self.title is not None:
            oprot.writeFieldBegin('title', TType.STRING, 2)
            oprot.writeString(self.title.encode('utf-8') if sys.version_info[0] == 2 else self.title)
            oprot.writeFieldEnd()
        if self.url is not None:
            oprot.writeFieldBegin('url', TType.STRING, 3)
            oprot.writeString(self.url.encode('utf-8') if sys.version_info[0] == 2 else self.url)
            oprot.writeFieldEnd()
        if self.sourceId is not None:
            oprot.writeFieldBegin('sourceId', TType.STRING, 4)
            oprot.writeString(self.sourceId.encode('utf-8') if sys.version_info[0] == 2 else self.sourceId)
            oprot.writeFieldEnd()
        if self.sourceUrl is not None:
            oprot.writeFieldBegin('sourceUrl', TType.STRING, 5)
            oprot.writeString(self.sourceUrl.encode('utf-8') if sys.version_info[0] == 2 else self.sourceUrl)
            oprot.writeFieldEnd()
        if self.sourceFaviconUrl is not None:
            oprot.writeFieldBegin('sourceFaviconUrl', TType.STRING, 6)
            oprot.writeString(self.sourceFaviconUrl.encode('utf-8') if sys.version_info[0] == 2 else self.sourceFaviconUrl)
            oprot.writeFieldEnd()
        if self.sourceName is not None:
            oprot.writeFieldBegin('sourceName', TType.STRING, 7)
            oprot.writeString(self.sourceName.encode('utf-8') if sys.version_info[0] == 2 else self.sourceName)
            oprot.writeFieldEnd()
        if self.date is not None:
            oprot.writeFieldBegin('date', TType.I64, 8)
            oprot.writeI64(self.date)
            oprot.writeFieldEnd()
        if self.teaser is not None:
            oprot.writeFieldBegin('teaser', TType.STRING, 9)
            oprot.writeString(self.teaser.encode('utf-8') if sys.version_info[0] == 2 else self.teaser)
            oprot.writeFieldEnd()
        if self.thumbnails is not None:
            oprot.writeFieldBegin('thumbnails', TType.LIST, 10)
            oprot.writeListBegin(TType.STRUCT, len(self.thumbnails))
            for iter93 in self.thumbnails:
                iter93.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.contentType is not None:
            oprot.writeFieldBegin('contentType', TType.I32, 11)
            oprot.writeI32(self.contentType.value)
            oprot.writeFieldEnd()
        if self.accessType is not None:
            oprot.writeFieldBegin('accessType', TType.I32, 12)
            oprot.writeI32(self.accessType.value)
            oprot.writeFieldEnd()
        if self.visibleUrl is not None:
            oprot.writeFieldBegin('visibleUrl', TType.STRING, 13)
            oprot.writeString(self.visibleUrl.encode('utf-8') if sys.version_info[0] == 2 else self.visibleUrl)
            oprot.writeFieldEnd()
        if self.clipUrl is not None:
            oprot.writeFieldBegin('clipUrl', TType.STRING, 14)
            oprot.writeString(self.clipUrl.encode('utf-8') if sys.version_info[0] == 2 else self.clipUrl)
            oprot.writeFieldEnd()
        if self.contact is not None:
            oprot.writeFieldBegin('contact', TType.STRUCT, 15)
            self.contact.write(oprot)
            oprot.writeFieldEnd()
        if self.authors is not None:
            oprot.writeFieldBegin('authors', TType.LIST, 16)
            oprot.writeListBegin(TType.STRING, len(self.authors))
            for iter94 in self.authors:
                oprot.writeString(iter94.encode('utf-8') if sys.version_info[0] == 2 else iter94)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BusinessInvitation(object):
    """
    A structure describing an invitation to join a business account.

    <dl>
      <dt>businessId</dt>
        <dd>
          The ID of the business to which the invitation grants access.
        </dd>

      <dt>email</dt>
        <dd>
          The email address that was invited to join the business.
        </dd>

      <dt>role</dt>
        <dd>
          The role to grant the user after the invitation is accepted.
        </dd>

      <dt>status</dt>
        <dd>
          The status of the invitation.
        </dd>

      <dt>requesterId</dt>
        <dd>
          For invitations that were initially requested by a non-admin member of the business,
          this field specifies the user ID of the requestor. For all other invitations, this field
          will be unset.
        </dd>
      <dt>fromWorkChat</dt>
        <dd>
          If this invitation was created implicitly via a WorkChat, this field
          will be true.
        </dd>
      <dt>created</dt>
        <dd>
          The timestamp at which this invitation was created.
        </dd>
      <dt>mostRecentReminder</dt>
        <dd>
          The timestamp at which the most recent reminder was sent.
        </dd>
    </dl>

    Attributes:
     - businessId
     - email
     - role
     - status
     - requesterId
     - fromWorkChat
     - created
     - mostRecentReminder

    """
    thrift_spec: typing.Any = None


    def __init__(self, businessId: typing.Optional[int] = None, email: typing.Optional[str] = None, role: typing.Optional[BusinessUserRole] = None, status: typing.Optional[BusinessInvitationStatus] = None, requesterId: typing.Optional[int] = None, fromWorkChat: typing.Optional[bool] = None, created: typing.Optional[int] = None, mostRecentReminder: typing.Optional[int] = None,):
        self.businessId: typing.Optional[int] = businessId
        self.email: typing.Optional[str] = email
        self.role: typing.Optional[BusinessUserRole] = role
        self.status: typing.Optional[BusinessInvitationStatus] = status
        self.requesterId: typing.Optional[int] = requesterId
        self.fromWorkChat: typing.Optional[bool] = fromWorkChat
        self.created: typing.Optional[int] = created
        self.mostRecentReminder: typing.Optional[int] = mostRecentReminder

    def __setattr__(self, name, value):
        if name == "role":
            super().__setattr__(name, value if hasattr(value, 'value') else BusinessUserRole.__members__.get(value))
            return
        if name == "status":
            super().__setattr__(name, value if hasattr(value, 'value') else BusinessInvitationStatus.__members__.get(value))
            return
        super().__setattr__(name, value)


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.businessId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.email = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.role = BusinessUserRole(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.status = BusinessInvitationStatus(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.requesterId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.fromWorkChat = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.created = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.mostRecentReminder = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BusinessInvitation')
        if self.businessId is not None:
            oprot.writeFieldBegin('businessId', TType.I32, 1)
            oprot.writeI32(self.businessId)
            oprot.writeFieldEnd()
        if self.email is not None:
            oprot.writeFieldBegin('email', TType.STRING, 2)
            oprot.writeString(self.email.encode('utf-8') if sys.version_info[0] == 2 else self.email)
            oprot.writeFieldEnd()
        if self.role is not None:
            oprot.writeFieldBegin('role', TType.I32, 3)
            oprot.writeI32(self.role.value)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.I32, 4)
            oprot.writeI32(self.status.value)
            oprot.writeFieldEnd()
        if self.requesterId is not None:
            oprot.writeFieldBegin('requesterId', TType.I32, 5)
            oprot.writeI32(self.requesterId)
            oprot.writeFieldEnd()
        if self.fromWorkChat is not None:
            oprot.writeFieldBegin('fromWorkChat', TType.BOOL, 6)
            oprot.writeBool(self.fromWorkChat)
            oprot.writeFieldEnd()
        if self.created is not None:
            oprot.writeFieldBegin('created', TType.I64, 7)
            oprot.writeI64(self.created)
            oprot.writeFieldEnd()
        if self.mostRecentReminder is not None:
            oprot.writeFieldBegin('mostRecentReminder', TType.I64, 8)
            oprot.writeI64(self.mostRecentReminder)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UserIdentity(object):
    """
    A structure that holds user identifying information such as an
    email address, Evernote user ID, or an identifier from a 3rd party
    service.  An instance consists of a type and a value, where the
    value will be stored in one of the value fields depending upon the
    data type required for the identity type.

    When used with shared notebook invitations, a UserIdentity
    identifies a particular person who may not (yet) have an Evernote
    UserID UserIdentity but who has (almost) unique access to the
    service endpoint described by the UserIdentity.  For example, an
    e-mail UserIdentity can identify the person who receives e-mail at
    the given address, and who can therefore read the share key that
    has a cryptographic signature from the Evernote service. With the
    share key, this person can supply their Evernote UserID via an
    authentication token to join the notebook
    (authenticateToSharedNotebook), at which time we have associated
    the e-mail UserIdentity with an Evernote UserID UserIdentity. Note
    that using shared notebook records, the relationship between
    Evernote UserIDs and e-mail addresses is many to many.

    Note that the identifier may not directly identify a
    particular Evernote UserID UserIdentity without further
    verification.  For example, an e-mail UserIdentity may be
    associated with an invitation to join a notebook (via a shared
    notebook record), but until a user uses a share key, that was sent
    to that e-mail address, to join the notebook, we do not know an
    Evernote UserID UserIdentity ID to match the e-mail address.

    Attributes:
     - type
     - stringIdentifier
     - longIdentifier

    """
    thrift_spec: typing.Any = None


    def __init__(self, type: typing.Optional[UserIdentityType] = None, stringIdentifier: typing.Optional[str] = None, longIdentifier: typing.Optional[int] = None,):
        self.type: typing.Optional[UserIdentityType] = type
        self.stringIdentifier: typing.Optional[str] = stringIdentifier
        self.longIdentifier: typing.Optional[int] = longIdentifier

    def __setattr__(self, name, value):
        if name == "type":
            super().__setattr__(name, value if hasattr(value, 'value') else UserIdentityType.__members__.get(value))
            return
        super().__setattr__(name, value)


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.type = UserIdentityType(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.stringIdentifier = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.longIdentifier = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UserIdentity')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 1)
            oprot.writeI32(self.type.value)
            oprot.writeFieldEnd()
        if self.stringIdentifier is not None:
            oprot.writeFieldBegin('stringIdentifier', TType.STRING, 2)
            oprot.writeString(self.stringIdentifier.encode('utf-8') if sys.version_info[0] == 2 else self.stringIdentifier)
            oprot.writeFieldEnd()
        if self.longIdentifier is not None:
            oprot.writeFieldBegin('longIdentifier', TType.I64, 3)
            oprot.writeI64(self.longIdentifier)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Data)
Data.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'bodyHash', 'BINARY', None, ),  # 1
    (2, TType.I32, 'size', None, None, ),  # 2
    (3, TType.STRING, 'body', 'BINARY', None, ),  # 3
)
all_structs.append(UserAttributes)
UserAttributes.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'defaultLocationName', 'UTF8', None, ),  # 1
    (2, TType.DOUBLE, 'defaultLatitude', None, None, ),  # 2
    (3, TType.DOUBLE, 'defaultLongitude', None, None, ),  # 3
    (4, TType.BOOL, 'preactivation', None, None, ),  # 4
    (5, TType.LIST, 'viewedPromotions', (TType.STRING, 'UTF8', False), None, ),  # 5
    (6, TType.STRING, 'incomingEmailAddress', 'UTF8', None, ),  # 6
    (7, TType.LIST, 'recentMailedAddresses', (TType.STRING, 'UTF8', False), None, ),  # 7
    None,  # 8
    (9, TType.STRING, 'comments', 'UTF8', None, ),  # 9
    None,  # 10
    (11, TType.I64, 'dateAgreedToTermsOfService', None, None, ),  # 11
    (12, TType.I32, 'maxReferrals', None, None, ),  # 12
    (13, TType.I32, 'referralCount', None, None, ),  # 13
    (14, TType.STRING, 'refererCode', 'UTF8', None, ),  # 14
    (15, TType.I64, 'sentEmailDate', None, None, ),  # 15
    (16, TType.I32, 'sentEmailCount', None, None, ),  # 16
    (17, TType.I32, 'dailyEmailLimit', None, None, ),  # 17
    (18, TType.I64, 'emailOptOutDate', None, None, ),  # 18
    (19, TType.I64, 'partnerEmailOptInDate', None, None, ),  # 19
    (20, TType.STRING, 'preferredLanguage', 'UTF8', None, ),  # 20
    (21, TType.STRING, 'preferredCountry', 'UTF8', None, ),  # 21
    (22, TType.BOOL, 'clipFullPage', None, None, ),  # 22
    (23, TType.STRING, 'twitterUserName', 'UTF8', None, ),  # 23
    (24, TType.STRING, 'twitterId', 'UTF8', None, ),  # 24
    (25, TType.STRING, 'groupName', 'UTF8', None, ),  # 25
    (26, TType.STRING, 'recognitionLanguage', 'UTF8', None, ),  # 26
    None,  # 27
    (28, TType.STRING, 'referralProof', 'UTF8', None, ),  # 28
    (29, TType.BOOL, 'educationalDiscount', None, None, ),  # 29
    (30, TType.STRING, 'businessAddress', 'UTF8', None, ),  # 30
    (31, TType.BOOL, 'hideSponsorBilling', None, None, ),  # 31
    None,  # 32
    (33, TType.BOOL, 'useEmailAutoFiling', None, None, ),  # 33
    (34, TType.I32, 'reminderEmailConfig', None, None, ),  # 34
    (35, TType.I64, 'emailAddressLastConfirmed', None, None, ),  # 35
    (36, TType.I64, 'passwordUpdated', None, None, ),  # 36
    (37, TType.BOOL, 'salesforcePushEnabled', None, None, ),  # 37
    (38, TType.BOOL, 'shouldLogClientEvent', None, None, ),  # 38
    (39, TType.BOOL, 'optOutMachineLearning', None, None, ),  # 39
)
all_structs.append(BusinessUserAttributes)
BusinessUserAttributes.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'title', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'location', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'department', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'mobilePhone', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'linkedInProfileUrl', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'workPhone', 'UTF8', None, ),  # 6
    (7, TType.I64, 'companyStartDate', None, None, ),  # 7
)
all_structs.append(Accounting)
Accounting.thrift_spec = (
    None,  # 0
    None,  # 1
    (2, TType.I64, 'uploadLimitEnd', None, None, ),  # 2
    (3, TType.I64, 'uploadLimitNextMonth', None, None, ),  # 3
    (4, TType.I32, 'premiumServiceStatus', None, None, ),  # 4
    (5, TType.STRING, 'premiumOrderNumber', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'premiumCommerceService', 'UTF8', None, ),  # 6
    (7, TType.I64, 'premiumServiceStart', None, None, ),  # 7
    (8, TType.STRING, 'premiumServiceSKU', 'UTF8', None, ),  # 8
    (9, TType.I64, 'lastSuccessfulCharge', None, None, ),  # 9
    (10, TType.I64, 'lastFailedCharge', None, None, ),  # 10
    (11, TType.STRING, 'lastFailedChargeReason', 'UTF8', None, ),  # 11
    (12, TType.I64, 'nextPaymentDue', None, None, ),  # 12
    (13, TType.I64, 'premiumLockUntil', None, None, ),  # 13
    (14, TType.I64, 'updated', None, None, ),  # 14
    None,  # 15
    (16, TType.STRING, 'premiumSubscriptionNumber', 'UTF8', None, ),  # 16
    (17, TType.I64, 'lastRequestedCharge', None, None, ),  # 17
    (18, TType.STRING, 'currency', 'UTF8', None, ),  # 18
    (19, TType.I32, 'unitPrice', None, None, ),  # 19
    (20, TType.I32, 'businessId', None, None, ),  # 20
    (21, TType.STRING, 'businessName', 'UTF8', None, ),  # 21
    (22, TType.I32, 'businessRole', None, None, ),  # 22
    (23, TType.I32, 'unitDiscount', None, None, ),  # 23
    (24, TType.I64, 'nextChargeDate', None, None, ),  # 24
    (25, TType.I32, 'availablePoints', None, None, ),  # 25
)
all_structs.append(BusinessUserInfo)
BusinessUserInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'businessId', None, None, ),  # 1
    (2, TType.STRING, 'businessName', 'UTF8', None, ),  # 2
    (3, TType.I32, 'role', None, None, ),  # 3
    (4, TType.STRING, 'email', 'UTF8', None, ),  # 4
    (5, TType.I64, 'updated', None, None, ),  # 5
)
all_structs.append(AccountLimits)
AccountLimits.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'userMailLimitDaily', None, None, ),  # 1
    (2, TType.I64, 'noteSizeMax', None, None, ),  # 2
    (3, TType.I64, 'resourceSizeMax', None, None, ),  # 3
    (4, TType.I32, 'userLinkedNotebookMax', None, None, ),  # 4
    (5, TType.I64, 'uploadLimit', None, None, ),  # 5
    (6, TType.I32, 'userNoteCountMax', None, None, ),  # 6
    (7, TType.I32, 'userNotebookCountMax', None, None, ),  # 7
    (8, TType.I32, 'userTagCountMax', None, None, ),  # 8
    (9, TType.I32, 'noteTagCountMax', None, None, ),  # 9
    (10, TType.I32, 'userSavedSearchesMax', None, None, ),  # 10
    (11, TType.I32, 'noteResourceCountMax', None, None, ),  # 11
)
all_structs.append(User)
User.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'id', None, None, ),  # 1
    (2, TType.STRING, 'username', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'email', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'name', 'UTF8', None, ),  # 4
    None,  # 5
    (6, TType.STRING, 'timezone', 'UTF8', None, ),  # 6
    (7, TType.I32, 'privilege', None, None, ),  # 7
    None,  # 8
    (9, TType.I64, 'created', None, None, ),  # 9
    (10, TType.I64, 'updated', None, None, ),  # 10
    (11, TType.I64, 'deleted', None, None, ),  # 11
    None,  # 12
    (13, TType.BOOL, 'active', None, None, ),  # 13
    (14, TType.STRING, 'shardId', 'UTF8', None, ),  # 14
    (15, TType.STRUCT, 'attributes', [UserAttributes, None], None, ),  # 15
    (16, TType.STRUCT, 'accounting', [Accounting, None], None, ),  # 16
    None,  # 17
    (18, TType.STRUCT, 'businessUserInfo', [BusinessUserInfo, None], None, ),  # 18
    (19, TType.STRING, 'photoUrl', 'UTF8', None, ),  # 19
    (20, TType.I64, 'photoLastUpdated', None, None, ),  # 20
    (21, TType.I32, 'serviceLevel', None, None, ),  # 21
    (22, TType.STRUCT, 'accountLimits', [AccountLimits, None], None, ),  # 22
)
all_structs.append(Contact)
Contact.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'id', 'UTF8', None, ),  # 2
    (3, TType.I32, 'type', None, None, ),  # 3
    (4, TType.STRING, 'photoUrl', 'UTF8', None, ),  # 4
    (5, TType.I64, 'photoLastUpdated', None, None, ),  # 5
    (6, TType.STRING, 'messagingPermit', 'BINARY', None, ),  # 6
    (7, TType.I64, 'messagingPermitExpires', None, None, ),  # 7
)
all_structs.append(Identity)
Identity.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
    (2, TType.STRUCT, 'contact', [Contact, None], None, ),  # 2
    (3, TType.I32, 'userId', None, None, ),  # 3
    (4, TType.BOOL, 'deactivated', None, None, ),  # 4
    (5, TType.BOOL, 'sameBusiness', None, None, ),  # 5
    (6, TType.BOOL, 'blocked', None, None, ),  # 6
    (7, TType.BOOL, 'userConnected', None, None, ),  # 7
    (8, TType.I64, 'eventId', None, None, ),  # 8
)
all_structs.append(Tag)
Tag.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'guid', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'parentGuid', 'UTF8', None, ),  # 3
    (4, TType.I32, 'updateSequenceNum', None, None, ),  # 4
)
all_structs.append(LazyMap)
LazyMap.thrift_spec = (
    None,  # 0
    (1, TType.SET, 'keysOnly', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.MAP, 'fullMap', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(ResourceAttributes)
ResourceAttributes.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sourceURL', 'UTF8', None, ),  # 1
    (2, TType.I64, 'timestamp', None, None, ),  # 2
    (3, TType.DOUBLE, 'latitude', None, None, ),  # 3
    (4, TType.DOUBLE, 'longitude', None, None, ),  # 4
    (5, TType.DOUBLE, 'altitude', None, None, ),  # 5
    (6, TType.STRING, 'cameraMake', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'cameraModel', 'UTF8', None, ),  # 7
    (8, TType.BOOL, 'clientWillIndex', None, None, ),  # 8
    (9, TType.STRING, 'recoType', 'UTF8', None, ),  # 9
    (10, TType.STRING, 'fileName', 'UTF8', None, ),  # 10
    (11, TType.BOOL, 'attachment', None, None, ),  # 11
    (12, TType.STRUCT, 'applicationData', [LazyMap, None], None, ),  # 12
)
all_structs.append(Resource)
Resource.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'guid', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'noteGuid', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'data', [Data, None], None, ),  # 3
    (4, TType.STRING, 'mime', 'UTF8', None, ),  # 4
    (5, TType.I16, 'width', None, None, ),  # 5
    (6, TType.I16, 'height', None, None, ),  # 6
    (7, TType.I16, 'duration', None, None, ),  # 7
    (8, TType.BOOL, 'active', None, None, ),  # 8
    (9, TType.STRUCT, 'recognition', [Data, None], None, ),  # 9
    None,  # 10
    (11, TType.STRUCT, 'attributes', [ResourceAttributes, None], None, ),  # 11
    (12, TType.I32, 'updateSequenceNum', None, None, ),  # 12
    (13, TType.STRUCT, 'alternateData', [Data, None], None, ),  # 13
)
all_structs.append(NoteAttributes)
NoteAttributes.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'subjectDate', None, None, ),  # 1
    None,  # 2
    None,  # 3
    None,  # 4
    None,  # 5
    None,  # 6
    None,  # 7
    None,  # 8
    None,  # 9
    (10, TType.DOUBLE, 'latitude', None, None, ),  # 10
    (11, TType.DOUBLE, 'longitude', None, None, ),  # 11
    (12, TType.DOUBLE, 'altitude', None, None, ),  # 12
    (13, TType.STRING, 'author', 'UTF8', None, ),  # 13
    (14, TType.STRING, 'source', 'UTF8', None, ),  # 14
    (15, TType.STRING, 'sourceURL', 'UTF8', None, ),  # 15
    (16, TType.STRING, 'sourceApplication', 'UTF8', None, ),  # 16
    (17, TType.I64, 'shareDate', None, None, ),  # 17
    (18, TType.I64, 'reminderOrder', None, None, ),  # 18
    (19, TType.I64, 'reminderDoneTime', None, None, ),  # 19
    (20, TType.I64, 'reminderTime', None, None, ),  # 20
    (21, TType.STRING, 'placeName', 'UTF8', None, ),  # 21
    (22, TType.STRING, 'contentClass', 'UTF8', None, ),  # 22
    (23, TType.STRUCT, 'applicationData', [LazyMap, None], None, ),  # 23
    (24, TType.STRING, 'lastEditedBy', 'UTF8', None, ),  # 24
    None,  # 25
    (26, TType.MAP, 'classifications', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 26
    (27, TType.I32, 'creatorId', None, None, ),  # 27
    (28, TType.I32, 'lastEditorId', None, None, ),  # 28
    (29, TType.BOOL, 'sharedWithBusiness', None, None, ),  # 29
    (30, TType.STRING, 'conflictSourceNoteGuid', 'UTF8', None, ),  # 30
    (31, TType.I32, 'noteTitleQuality', None, None, ),  # 31
)
all_structs.append(SharedNote)
SharedNote.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sharerUserID', None, None, ),  # 1
    (2, TType.STRUCT, 'recipientIdentity', [Identity, None], None, ),  # 2
    (3, TType.I32, 'privilege', None, None, ),  # 3
    (4, TType.I64, 'serviceCreated', None, None, ),  # 4
    (5, TType.I64, 'serviceUpdated', None, None, ),  # 5
    (6, TType.I64, 'serviceAssigned', None, None, ),  # 6
)
all_structs.append(NoteRestrictions)
NoteRestrictions.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'noUpdateTitle', None, None, ),  # 1
    (2, TType.BOOL, 'noUpdateContent', None, None, ),  # 2
    (3, TType.BOOL, 'noEmail', None, None, ),  # 3
    (4, TType.BOOL, 'noShare', None, None, ),  # 4
    (5, TType.BOOL, 'noSharePublicly', None, None, ),  # 5
)
all_structs.append(NoteLimits)
NoteLimits.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'noteResourceCountMax', None, None, ),  # 1
    (2, TType.I64, 'uploadLimit', None, None, ),  # 2
    (3, TType.I64, 'resourceSizeMax', None, None, ),  # 3
    (4, TType.I64, 'noteSizeMax', None, None, ),  # 4
    (5, TType.I64, 'uploaded', None, None, ),  # 5
)
all_structs.append(Note)
Note.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'guid', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'title', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'content', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'contentHash', 'BINARY', None, ),  # 4
    (5, TType.I32, 'contentLength', None, None, ),  # 5
    (6, TType.I64, 'created', None, None, ),  # 6
    (7, TType.I64, 'updated', None, None, ),  # 7
    (8, TType.I64, 'deleted', None, None, ),  # 8
    (9, TType.BOOL, 'active', None, None, ),  # 9
    (10, TType.I32, 'updateSequenceNum', None, None, ),  # 10
    (11, TType.STRING, 'notebookGuid', 'UTF8', None, ),  # 11
    (12, TType.LIST, 'tagGuids', (TType.STRING, 'UTF8', False), None, ),  # 12
    (13, TType.LIST, 'resources', (TType.STRUCT, [Resource, None], False), None, ),  # 13
    (14, TType.STRUCT, 'attributes', [NoteAttributes, None], None, ),  # 14
    (15, TType.LIST, 'tagNames', (TType.STRING, 'UTF8', False), None, ),  # 15
    (16, TType.LIST, 'sharedNotes', (TType.STRUCT, [SharedNote, None], False), None, ),  # 16
    (17, TType.STRUCT, 'restrictions', [NoteRestrictions, None], None, ),  # 17
    (18, TType.STRUCT, 'limits', [NoteLimits, None], None, ),  # 18
)
all_structs.append(Publishing)
Publishing.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'uri', 'UTF8', None, ),  # 1
    (2, TType.I32, 'order', None, None, ),  # 2
    (3, TType.BOOL, 'ascending', None, None, ),  # 3
    (4, TType.STRING, 'publicDescription', 'UTF8', None, ),  # 4
)
all_structs.append(BusinessNotebook)
BusinessNotebook.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'notebookDescription', 'UTF8', None, ),  # 1
    (2, TType.I32, 'privilege', None, None, ),  # 2
    (3, TType.BOOL, 'recommended', None, None, ),  # 3
)
all_structs.append(SavedSearchScope)
SavedSearchScope.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'includeAccount', None, None, ),  # 1
    (2, TType.BOOL, 'includePersonalLinkedNotebooks', None, None, ),  # 2
    (3, TType.BOOL, 'includeBusinessLinkedNotebooks', None, None, ),  # 3
)
all_structs.append(SavedSearch)
SavedSearch.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'guid', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'query', 'UTF8', None, ),  # 3
    (4, TType.I32, 'format', None, None, ),  # 4
    (5, TType.I32, 'updateSequenceNum', None, None, ),  # 5
    (6, TType.STRUCT, 'scope', [SavedSearchScope, None], None, ),  # 6
)
all_structs.append(SharedNotebookRecipientSettings)
SharedNotebookRecipientSettings.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'reminderNotifyEmail', None, None, ),  # 1
    (2, TType.BOOL, 'reminderNotifyInApp', None, None, ),  # 2
)
all_structs.append(NotebookRecipientSettings)
NotebookRecipientSettings.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'reminderNotifyEmail', None, None, ),  # 1
    (2, TType.BOOL, 'reminderNotifyInApp', None, None, ),  # 2
    (3, TType.BOOL, 'inMyList', None, None, ),  # 3
    (4, TType.STRING, 'stack', 'UTF8', None, ),  # 4
    (5, TType.I32, 'recipientStatus', None, None, ),  # 5
)
all_structs.append(SharedNotebook)
SharedNotebook.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
    (2, TType.I32, 'userId', None, None, ),  # 2
    (3, TType.STRING, 'notebookGuid', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'email', 'UTF8', None, ),  # 4
    (5, TType.BOOL, 'notebookModifiable', None, None, ),  # 5
    None,  # 6
    (7, TType.I64, 'serviceCreated', None, None, ),  # 7
    (8, TType.STRING, 'globalId', 'UTF8', None, ),  # 8
    (9, TType.STRING, 'username', 'UTF8', None, ),  # 9
    (10, TType.I64, 'serviceUpdated', None, None, ),  # 10
    (11, TType.I32, 'privilege', None, None, ),  # 11
    None,  # 12
    (13, TType.STRUCT, 'recipientSettings', [SharedNotebookRecipientSettings, None], None, ),  # 13
    (14, TType.I32, 'sharerUserId', None, None, ),  # 14
    (15, TType.STRING, 'recipientUsername', 'UTF8', None, ),  # 15
    (16, TType.I64, 'serviceAssigned', None, None, ),  # 16
    (17, TType.I32, 'recipientUserId', None, None, ),  # 17
    (18, TType.I64, 'recipientIdentityId', None, None, ),  # 18
)
all_structs.append(CanMoveToContainerRestrictions)
CanMoveToContainerRestrictions.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'canMoveToContainer', None, None, ),  # 1
)
all_structs.append(NotebookRestrictions)
NotebookRestrictions.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'noReadNotes', None, None, ),  # 1
    (2, TType.BOOL, 'noCreateNotes', None, None, ),  # 2
    (3, TType.BOOL, 'noUpdateNotes', None, None, ),  # 3
    (4, TType.BOOL, 'noExpungeNotes', None, None, ),  # 4
    (5, TType.BOOL, 'noShareNotes', None, None, ),  # 5
    (6, TType.BOOL, 'noEmailNotes', None, None, ),  # 6
    (7, TType.BOOL, 'noSendMessageToRecipients', None, None, ),  # 7
    (8, TType.BOOL, 'noUpdateNotebook', None, None, ),  # 8
    (9, TType.BOOL, 'noExpungeNotebook', None, None, ),  # 9
    (10, TType.BOOL, 'noSetDefaultNotebook', None, None, ),  # 10
    (11, TType.BOOL, 'noSetNotebookStack', None, None, ),  # 11
    (12, TType.BOOL, 'noPublishToPublic', None, None, ),  # 12
    (13, TType.BOOL, 'noPublishToBusinessLibrary', None, None, ),  # 13
    (14, TType.BOOL, 'noCreateTags', None, None, ),  # 14
    (15, TType.BOOL, 'noUpdateTags', None, None, ),  # 15
    (16, TType.BOOL, 'noExpungeTags', None, None, ),  # 16
    (17, TType.BOOL, 'noSetParentTag', None, None, ),  # 17
    (18, TType.BOOL, 'noCreateSharedNotebooks', None, None, ),  # 18
    (19, TType.I32, 'updateWhichSharedNotebookRestrictions', None, None, ),  # 19
    (20, TType.I32, 'expungeWhichSharedNotebookRestrictions', None, None, ),  # 20
    (21, TType.BOOL, 'noShareNotesWithBusiness', None, None, ),  # 21
    (22, TType.BOOL, 'noRenameNotebook', None, None, ),  # 22
    (23, TType.BOOL, 'noSetInMyList', None, None, ),  # 23
    (24, TType.BOOL, 'noChangeContact', None, None, ),  # 24
    None,  # 25
    (26, TType.STRUCT, 'canMoveToContainerRestrictions', [CanMoveToContainerRestrictions, None], None, ),  # 26
    (27, TType.BOOL, 'noSetReminderNotifyEmail', None, None, ),  # 27
    (28, TType.BOOL, 'noSetReminderNotifyInApp', None, None, ),  # 28
    (29, TType.BOOL, 'noSetRecipientSettingsStack', None, None, ),  # 29
    (30, TType.BOOL, 'noCanMoveNote', None, None, ),  # 30
)
all_structs.append(Notebook)
Notebook.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'guid', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    None,  # 3
    None,  # 4
    (5, TType.I32, 'updateSequenceNum', None, None, ),  # 5
    (6, TType.BOOL, 'defaultNotebook', None, None, ),  # 6
    (7, TType.I64, 'serviceCreated', None, None, ),  # 7
    (8, TType.I64, 'serviceUpdated', None, None, ),  # 8
    None,  # 9
    (10, TType.STRUCT, 'publishing', [Publishing, None], None, ),  # 10
    (11, TType.BOOL, 'published', None, None, ),  # 11
    (12, TType.STRING, 'stack', 'UTF8', None, ),  # 12
    (13, TType.LIST, 'sharedNotebookIds', (TType.I64, None, False), None, ),  # 13
    (14, TType.LIST, 'sharedNotebooks', (TType.STRUCT, [SharedNotebook, None], False), None, ),  # 14
    (15, TType.STRUCT, 'businessNotebook', [BusinessNotebook, None], None, ),  # 15
    (16, TType.STRUCT, 'contact', [User, None], None, ),  # 16
    (17, TType.STRUCT, 'restrictions', [NotebookRestrictions, None], None, ),  # 17
    (18, TType.STRUCT, 'recipientSettings', [NotebookRecipientSettings, None], None, ),  # 18
)
all_structs.append(LinkedNotebook)
LinkedNotebook.thrift_spec = (
    None,  # 0
    None,  # 1
    (2, TType.STRING, 'shareName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'username', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'shardId', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'sharedNotebookGlobalId', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'uri', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'guid', 'UTF8', None, ),  # 7
    (8, TType.I32, 'updateSequenceNum', None, None, ),  # 8
    (9, TType.STRING, 'noteStoreUrl', 'UTF8', None, ),  # 9
    (10, TType.STRING, 'webApiUrlPrefix', 'UTF8', None, ),  # 10
    (11, TType.STRING, 'stack', 'UTF8', None, ),  # 11
    (12, TType.I32, 'businessId', None, None, ),  # 12
)
all_structs.append(NotebookDescriptor)
NotebookDescriptor.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'guid', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'notebookDisplayName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'contactName', 'UTF8', None, ),  # 3
    (4, TType.BOOL, 'hasSharedNotebook', None, None, ),  # 4
    (5, TType.I32, 'joinedUserCount', None, None, ),  # 5
)
all_structs.append(UserProfile)
UserProfile.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'id', None, None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'email', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'username', 'UTF8', None, ),  # 4
    (5, TType.STRUCT, 'attributes', [BusinessUserAttributes, None], None, ),  # 5
    (6, TType.I64, 'joined', None, None, ),  # 6
    (7, TType.I64, 'photoLastUpdated', None, None, ),  # 7
    (8, TType.STRING, 'photoUrl', 'UTF8', None, ),  # 8
    (9, TType.I32, 'role', None, None, ),  # 9
    (10, TType.I32, 'status', None, None, ),  # 10
)
all_structs.append(RelatedContentImage)
RelatedContentImage.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'url', 'UTF8', None, ),  # 1
    (2, TType.I32, 'width', None, None, ),  # 2
    (3, TType.I32, 'height', None, None, ),  # 3
    (4, TType.DOUBLE, 'pixelRatio', None, None, ),  # 4
    (5, TType.I32, 'fileSize', None, None, ),  # 5
)
all_structs.append(RelatedContent)
RelatedContent.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'contentId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'title', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'url', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'sourceId', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'sourceUrl', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'sourceFaviconUrl', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'sourceName', 'UTF8', None, ),  # 7
    (8, TType.I64, 'date', None, None, ),  # 8
    (9, TType.STRING, 'teaser', 'UTF8', None, ),  # 9
    (10, TType.LIST, 'thumbnails', (TType.STRUCT, [RelatedContentImage, None], False), None, ),  # 10
    (11, TType.I32, 'contentType', None, None, ),  # 11
    (12, TType.I32, 'accessType', None, None, ),  # 12
    (13, TType.STRING, 'visibleUrl', 'UTF8', None, ),  # 13
    (14, TType.STRING, 'clipUrl', 'UTF8', None, ),  # 14
    (15, TType.STRUCT, 'contact', [Contact, None], None, ),  # 15
    (16, TType.LIST, 'authors', (TType.STRING, 'UTF8', False), None, ),  # 16
)
all_structs.append(BusinessInvitation)
BusinessInvitation.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'businessId', None, None, ),  # 1
    (2, TType.STRING, 'email', 'UTF8', None, ),  # 2
    (3, TType.I32, 'role', None, None, ),  # 3
    (4, TType.I32, 'status', None, None, ),  # 4
    (5, TType.I32, 'requesterId', None, None, ),  # 5
    (6, TType.BOOL, 'fromWorkChat', None, None, ),  # 6
    (7, TType.I64, 'created', None, None, ),  # 7
    (8, TType.I64, 'mostRecentReminder', None, None, ),  # 8
)
all_structs.append(UserIdentity)
UserIdentity.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None, None, ),  # 1
    (2, TType.STRING, 'stringIdentifier', 'UTF8', None, ),  # 2
    (3, TType.I64, 'longIdentifier', None, None, ),  # 3
)
fix_spec(all_structs)
del all_structs

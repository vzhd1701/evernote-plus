#
# Autogenerated by Thrift Compiler (0.21.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:enum,type_hints
#

from __future__ import annotations
import typing
from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec
from uuid import UUID
from enum import IntEnum

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    """
    Service:  UserStore
    <p>
    The UserStore service is primarily used by EDAM clients to establish
    authentication via username and password over a trusted connection (e.g.
    SSL).  A client's first call to this interface should be checkVersion() to
    ensure that the client's software is up to date.
    </p>
    All calls which require an authenticationToken may throw an
    EDAMUserException for the following reasons:
     <ul>
      <li> AUTH_EXPIRED "authenticationToken" - token has expired
      <li> BAD_DATA_FORMAT "authenticationToken" - token is malformed
      <li> DATA_REQUIRED "authenticationToken" - token is empty
      <li> INVALID_AUTH "authenticationToken" - token signature is invalid
      <li> PERMISSION_DENIED "authenticationToken" - token does not convey sufficient
        privileges
    </ul>

    """
    def checkVersion(self, clientName: str, edamVersionMajor: int, edamVersionMinor: int) -> bool:
        """
        This should be the first call made by a client to the EDAM service.  It
        tells the service what protocol version is used by the client.  The
        service will then return true if the client is capable of talking to
        the service, and false if the client's protocol version is incompatible
        with the service, so the client must upgrade.  If a client receives a
        false value, it should report the incompatibility to the user and not
        continue with any more EDAM requests (UserStore or NoteStore).

        @param clientName
          This string provides some information about the client for
          tracking/logging on the service.  It should provide information about
          the client's software and platform. The structure should be:
          application/version; platform/version; [ device/version ]
          E.g. "Evernote Windows/3.0.1; Windows/XP SP3".

        @param edamVersionMajor
          This should be the major protocol version that was compiled by the
          client.  This should be the current value of the EDAM_VERSION_MAJOR
          constant for the client.

        @param edamVersionMinor
          This should be the major protocol version that was compiled by the
          client.  This should be the current value of the EDAM_VERSION_MINOR
          constant for the client.

        Parameters:
         - clientName
         - edamVersionMajor
         - edamVersionMinor

        """
        pass

    def getBootstrapInfo(self, locale: str) -> BootstrapInfo:
        """
        This provides bootstrap information to the client. Various bootstrap
        profiles and settings may be used by the client to configure itself.

        @param locale
          The client's current locale, expressed in language[_country]
          format. E.g., "en_US". See ISO-639 and ISO-3166 for valid
          language and country codes.

        @return
          The bootstrap information suitable for this client.

        Parameters:
         - locale

        """
        pass

    def authenticateLongSession(self, username: str, password: str, consumerKey: str, consumerSecret: str, deviceIdentifier: str, deviceDescription: str, supportsTwoFactor: bool) -> AuthenticationResult:
        """
        This is used to check a username and password in order to create a
        long-lived authentication token that can be used for further actions.

        This function is not available to most third party applications,
        which typically authenticate using OAuth as
        described at
        <a href="http://dev.evernote.com/documentation/cloud/">dev.evernote.com</a>.
        If you believe that your application requires permission to authenticate
        using username and password instead of OAuth, please contact Evernote
        developer support by visiting
        <a href="http://dev.evernote.com">dev.evernote.com</a>.

        @param username
          The username or registered email address of the account to
          authenticate against.

        @param password
          The plaintext password to check against the account.  Since
          this is not protected by the EDAM protocol, this information must be
          provided over a protected transport (i.e. SSL).

        @param consumerKey
          The "consumer key" portion of the API key issued to the client application
          by Evernote.

        @param consumerSecret
          The "consumer secret" portion of the API key issued to the client application
          by Evernote.

        @param deviceIdentifier
          An optional string that uniquely identifies the device from which the
          authentication is being performed. This string allows the service to return the
          same authentication token when a given application requests authentication
          repeatedly from the same device. This may happen when the user logs out of an
          application and then logs back in, or when the application is uninstalled
          and later reinstalled. If no reliable device identifier can be created,
          this value should be omitted. If set, the device identifier must be between
          1 and EDAM_DEVICE_ID_LEN_MAX characters long and must match the regular expression
          EDAM_DEVICE_ID_REGEX.

        @param deviceDescription
          A description of the device from which the authentication is being performed.
          This field is displayed to the user in a list of authorized applications to
          allow them to distinguish between multiple tokens issued to the same client
          application on different devices. For example, the Evernote iOS client on
          a user's iPhone and iPad might pass the iOS device names "Bob's iPhone" and
          "Bob's iPad". The device description must be between 1 and
          EDAM_DEVICE_DESCRIPTION_LEN_MAX characters long and must match the regular
          expression EDAM_DEVICE_DESCRIPTION_REGEX.

        @param supportsTwoFactor
          Whether the calling application supports two-factor authentication. If this
          parameter is false, this method will fail with the error code INVALID_AUTH and the
          parameter "password" when called for a user who has enabled two-factor
          authentication.

        @return
          <p>The result of the authentication. The level of detail provided in the returned
          AuthenticationResult.User structure depends on the access level granted by
          calling application's API key.</p>
          <p>If the user has two-factor authentication enabled,
          AuthenticationResult.secondFactorRequired will be set and
          AuthenticationResult.authenticationToken will contain a short-lived token
          that may only be used to complete the two-factor authentication process by calling
          UserStore.completeTwoFactorAuthentication.</p>

        @throws EDAMUserException <ul>
          <li> DATA_REQUIRED "username" - username is empty
          <li> DATA_REQUIRED "password" - password is empty
          <li> DATA_REQUIRED "consumerKey" - consumerKey is empty
          <li> DATA_REQUIRED "consumerSecret" - consumerSecret is empty
          <li> DATA_REQUIRED "deviceDescription" - deviceDescription is empty
          <li> BAD_DATA_FORMAT "deviceDescription" - deviceDescription is not valid.
          <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid.
          <li> INVALID_AUTH "username" - username not found
          <li> INVALID_AUTH "password" - password did not match
          <li> INVALID_AUTH "consumerKey" - consumerKey is not authorized
          <li> INVALID_AUTH "consumerSecret" - consumerSecret is incorrect
          <li> INVALID_AUTH "businessOnly" - the user is a business-only account
          <li> PERMISSION_DENIED "User.active" - user account is closed
          <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
            failed authentication too often
          <li> AUTH_EXPIRED "password" - user password is expired
        </ul>

        Parameters:
         - username
         - password
         - consumerKey
         - consumerSecret
         - deviceIdentifier
         - deviceDescription
         - supportsTwoFactor

        """
        pass

    def authenticateLongSessionV2(self, authParams: AuthenticationParameters) -> AuthenticationResult:
        """
        Used to be the main username/password login endpoint for the desktop app.
        Still useful, but only for Yinxiang.

        Parameters:
         - authParams

        """
        pass

    def completeTwoFactorAuthentication(self, authenticationToken: str, oneTimeCode: str, deviceIdentifier: str, deviceDescription: str) -> AuthenticationResult:
        """
        Complete the authentication process when a second factor is required. This
        call is made after a successful call to authenticate or authenticateLongSession
        when the authenticating user has enabled two-factor authentication.

        @param authenticationToken An authentication token returned by a previous
          call to UserStore.authenticate or UserStore.authenticateLongSession that
          could not be completed in a single call because a second factor was required.

        @param oneTimeCode The one time code entered by the user. This value is delivered
          out-of-band, typically via SMS or an authenticator application.

        @param deviceIdentifier See the corresponding parameter in authenticateLongSession.

        @param deviceDescription See the corresponding parameter in authenticateLongSession.

        @return
          The result of the authentication. The level of detail provided in the returned
          AuthenticationResult.User structure depends on the access level granted by the
          calling application's API key. If the initial authentication call was made to
          authenticateLongSession, the AuthenticationResult will contain a long-lived
          authentication token.

        @throws EDAMUserException <ul>
          <li> DATA_REQUIRED "authenticationToken" - authenticationToken is empty
          <li> DATA_REQUIRED "oneTimeCode" - oneTimeCode is empty
          <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid
          <li> BAD_DATA_FORMAT "authenticationToken" - authenticationToken is not well formed
          <li> INVALID_AUTH "oneTimeCode" - oneTimeCode did not match
          <li> AUTH_EXPIRED "authenticationToken" - authenticationToken has expired
          <li> PERMISSION_DENIED "authenticationToken" - authenticationToken is not valid
          <li> PERMISSION_DENIED "User.active" - user account is closed
          <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
            failed authentication too often
          <li> DATA_CONFLICT "User.twoFactorAuthentication" - The user has not enabled
             two-factor authentication.</li>
        </ul>

        Parameters:
         - authenticationToken
         - oneTimeCode
         - deviceIdentifier
         - deviceDescription

        """
        pass

    def revokeLongSession(self, authenticationToken: str) -> None:
        """
        Revoke an existing long lived authentication token. This can be used to
        revoke OAuth tokens or tokens created by calling authenticateLongSession,
        and allows a user to effectively log out of Evernote from the perspective
        of the application that holds the token. The authentication token that is
        passed is immediately revoked and may not be used to call any authenticated
        EDAM function.

        @param authenticationToken the authentication token to revoke.

        @throws EDAMUserException <ul>
          <li> DATA_REQUIRED "authenticationToken" - no authentication token provided
          <li> BAD_DATA_FORMAT "authenticationToken" - the authentication token is not well formed
          <li> INVALID_AUTH "authenticationToken" - the authentication token is invalid
          <li> AUTH_EXPIRED "authenticationToken" - the authentication token is expired or
            is already revoked.
        </ul>

        Parameters:
         - authenticationToken

        """
        pass

    def authenticateToBusiness(self, authenticationToken: str) -> AuthenticationResult:
        """
        This is used to take an existing authentication token that grants access
        to an individual user account (returned from 'authenticate',
        'authenticateLongSession' or an OAuth authorization) and obtain an additional
        authentication token that may be used to access business notebooks if the user
        is a member of an Evernote Business account.

        The resulting authentication token may be used to make NoteStore API calls
        against the business using the NoteStore URL returned in the result.

        @param authenticationToken
          The authentication token for the user. This may not be a shared authentication
          token (returned by NoteStore.authenticateToSharedNotebook or
          NoteStore.authenticateToSharedNote) or a business authentication token.

        @return
          The result of the authentication, with the token granting access to the
          business in the result's 'authenticationToken' field. The URL that must
          be used to access the business account NoteStore will be returned in the
          result's 'noteStoreUrl' field.  The 'User' field will
          not be set in the result.

        @throws EDAMUserException <ul>
          <li> PERMISSION_DENIED "authenticationToken" - the provided authentication token
               is a shared or business authentication token. </li>
          <li> PERMISSION_DENIED "Business" - the user identified by the provided
               authentication token is not currently a member of a business. </li>
          <li> PERMISSION_DENIED "Business.status" - the business that the user is a
               member of is not currently in an active status. </li>
          <li> BUSINESS_SECURITY_LOGIN_REQUIRED "sso" - the user must complete single
               sign-on before authenticating to the business.
        </ul>

        Parameters:
         - authenticationToken

        """
        pass

    def getUser(self, authenticationToken: str) -> evernote.edam.type.ttypes.User:
        """
        Returns the User corresponding to the provided authentication token,
        or throws an exception if this token is not valid.
        The level of detail provided in the returned User structure depends on
        the access level granted by the token, so a web service client may receive
        fewer fields than an integrated desktop client.

        Parameters:
         - authenticationToken

        """
        pass

    def getPublicUserInfo(self, username: str) -> PublicUserInfo:
        """
        Asks the UserStore about the publicly available location information for
        a particular username.

        @throws EDAMUserException <ul>
          <li> DATA_REQUIRED "username" - username is empty
        </ul>

        Parameters:
         - username

        """
        pass

    def getUserUrls(self, authenticationToken: str) -> UserUrls:
        """
        <p>Returns the URLs that should be used when sending requests to the service on
        behalf of the account represented by the provided authenticationToken.</p>

        <p>This method isn't needed by most clients, who can retreive the correct set of
        UserUrls from the AuthenticationResult returned from
        UserStore#authenticateLongSession(). This method is typically only needed to look up
        the correct URLs for an existing long-lived authentication token.</p>

        Parameters:
         - authenticationToken

        """
        pass

    def inviteToBusiness(self, authenticationToken: str, emailAddress: str) -> None:
        """
        Invite a user to join an Evernote Business account.

        Behavior will depend on the auth token. <ol>
          <li>
            auth token with privileges to manage Evernote Business membership.
              "External Provisioning" - The user will receive an email inviting
              them to join the business. They do not need to have an existing Evernote
              account. If the user has already been invited, a new invitation email
              will be sent.
          </li>
          <li>
            business auth token issued to an admin user. Only for first-party clients:
              "Approve Invitation" - If there has been a request to invite the email,
              approve it. Invited user will receive email with a link to join business.
              "Invite User" - If no invitation for the email exists, create an approved
              invitation for the email. An email will be sent to the emailAddress with
              a link to join the caller's business.
          </li>
          </li>
            business auth token:
              "Request Invitation" - If no invitation exists, create a request to
              invite the user to the business. These requests do not count towards a
              business' max active user limit.
          </li>
        </ol>

        @param authenticationToken
          the authentication token with sufficient privileges to manage Evernote Business
          membership or a business auth token.

        @param emailAddress
          the email address of the user to invite to join the Evernote Business account.

        @throws EDAMUserException <ul>
          <li> DATA_REQUIRED "email" - if no email address was provided </li>
          <li> BAD_DATA_FORMAT "email" - if the email address is not well formed </li>
          <li> DATA_CONFLICT "BusinessUser.email" - if there is already a user in the business
            whose business email address matches the specified email address. </li>
          <li> LIMIT_REACHED "Business.maxActiveUsers" - if the business has reached its
            user limit. </li>
        </ul>

        Parameters:
         - authenticationToken
         - emailAddress

        """
        pass

    def removeFromBusiness(self, authenticationToken: str, emailAddress: str) -> None:
        """
        Remove a user from an Evernote Business account. Once removed, the user will no
        longer be able to access content within the Evernote Business account.

        <p>The email address of the user to remove from the business must match the email
        address used to invite a user to join the business via UserStore.inviteToBusiness.
        This function will only remove users who were invited by external provisioning</p>

        @param authenticationToken
          An authentication token with sufficient privileges to manage Evernote Business
          membership.

        @param emailAddress
          The email address of the user to remove from the Evernote Business account.

        @throws EDAMUserException <ul>
          <li> DATA_REQUIRED "email" - if no email address was provided </li>
          <li> BAD_DATA_FORMAT "email" - The email address is not well formed </li>
        </ul>
        @throws EDAMNotFoundException <ul>
          <li> "email" - If there is no user with the specified email address in the
            business or that user was not invited via external provisioning. </li>
        </ul>

        Parameters:
         - authenticationToken
         - emailAddress

        """
        pass

    def updateBusinessUserIdentifier(self, authenticationToken: str, oldEmailAddress: str, newEmailAddress: str) -> None:
        """
        Update the email address used to uniquely identify an Evernote Business user.

        This will update the identifier for a user who was previously invited using
        inviteToBusiness, ensuring that caller and the Evernote service maintain an
        agreed-upon identifier for a specific user.

        For example, the following sequence of calls would invite a user to join
        a business, update their email address, and then remove the user
        from the business using the updated email address.

        inviteToBusiness("foo@bar.com")
        updateBusinessUserIdentifier("foo@bar.com", "baz@bar.com")
        removeFromBusiness("baz@bar.com")

        @param authenticationToken
          An authentication token with sufficient privileges to manage Evernote Business
          membership.

        @param oldEmailAddress
          The existing email address used to uniquely identify the user.

        @param newEmailAddress
          The new email address used to uniquely identify the user.

        @throws EDAMUserException <ul>
          <li>DATA_REQUIRED "oldEmailAddress" - No old email address was provided</li>
          <li>DATA_REQUIRED "newEmailAddress" - No new email address was provided</li>
          <li>BAD_DATA_FORMAT "oldEmailAddress" - The old email address is not well formed</li>
          <li>BAD_DATA_FORMAT "newEmailAddress" - The new email address is not well formed</li>
          <li>DATA_CONFLICT "oldEmailAddress" - The old and new email addresses were the same</li>
          <li>DATA_CONFLICT "newEmailAddress" - There is already an invitation or registered user with
            the provided new email address.</li>
          <li>DATA_CONFLICT "invitation.externallyProvisioned" - The user identified by
            oldEmailAddress was not added via UserStore.inviteToBusiness and therefore cannot be
            updated.</li>
        </ul>
        @throws EDAMNotFoundException <ul>
          <li>"oldEmailAddress" - If there is no user or invitation with the specified oldEmailAddress
            in the business.</li>
        </ul>

        Parameters:
         - authenticationToken
         - oldEmailAddress
         - newEmailAddress

        """
        pass

    def listBusinessUsers(self, authenticationToken: str) -> list[evernote.edam.type.ttypes.UserProfile]:
        """
        Returns a list of active business users in a given business.

        Clients are required to cache this information and re-fetch no more than once per day
        or when they encountered a user ID or username that was not known to them.

        To avoid excessive look ups, clients should also track user IDs and usernames that belong
        to users who are not in the business, since they will not be included in the result.

        I.e., when a client encounters a previously unknown user ID as a note's creator, it may query
        listBusinessUsers to find information about this user. If the user is not in the resulting
        list, the client should track that fact and not re-query the service the next time that it sees
        this user on a note.

        @param authenticationToken
          A business authentication token returned by authenticateToBusiness or with sufficient
          privileges to manage Evernote Business membership.

        Parameters:
         - authenticationToken

        """
        pass

    def listBusinessInvitations(self, authenticationToken: str, includeRequestedInvitations: bool) -> list[evernote.edam.type.ttypes.BusinessInvitation]:
        """
        Returns a list of outstanding invitations to join an Evernote Business account.

        Only outstanding invitations are returned by this function. Users who have accepted an
        invitation and joined a business are listed using listBusinessUsers.

        @param authenticationToken
          An authentication token with sufficient privileges to manage Evernote Business membership.

        @param includeRequestedInvitations
          If true, invitations with a status of BusinessInvitationStatus.REQUESTED will be included
          in the returned list. If false, only invitations with a status of
          BusinessInvitationStatus.APPROVED will be included.

        Parameters:
         - authenticationToken
         - includeRequestedInvitations

        """
        pass

    def getAccountLimits(self, serviceLevel: evernote.edam.type.ttypes.ServiceLevel) -> evernote.edam.type.ttypes.AccountLimits:
        """
        Retrieve the standard account limits for a given service level. This should only be
        called when necessary, e.g. to determine if a higher level is available should the
        user upgrade, and should be cached for long periods (e.g. 30 days) as the values are
        not expected to fluctuate frequently.

        @throws EDAMUserException <ul>
          <li>DATA_REQUIRED "serviceLevel" - serviceLevel is null</li>
        </ul>

        Parameters:
         - serviceLevel

        """
        pass

    def getNAPAccessToken(self, authenticationToken: str) -> str:
        """
        Endpoints for getting the JWT auth token for the new API.

        Parameters:
         - authenticationToken

        """
        pass

    def getNAPAccessJWT(self, authenticationToken: str, request: GetNAPAccessJWTRequest) -> str:
        """
        Parameters:
         - authenticationToken
         - request

        """
        pass


class Client(Iface):
    """
    Service:  UserStore
    <p>
    The UserStore service is primarily used by EDAM clients to establish
    authentication via username and password over a trusted connection (e.g.
    SSL).  A client's first call to this interface should be checkVersion() to
    ensure that the client's software is up to date.
    </p>
    All calls which require an authenticationToken may throw an
    EDAMUserException for the following reasons:
     <ul>
      <li> AUTH_EXPIRED "authenticationToken" - token has expired
      <li> BAD_DATA_FORMAT "authenticationToken" - token is malformed
      <li> DATA_REQUIRED "authenticationToken" - token is empty
      <li> INVALID_AUTH "authenticationToken" - token signature is invalid
      <li> PERMISSION_DENIED "authenticationToken" - token does not convey sufficient
        privileges
    </ul>

    """
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def checkVersion(self, clientName: str, edamVersionMajor: int, edamVersionMinor: int) -> bool:
        """
        This should be the first call made by a client to the EDAM service.  It
        tells the service what protocol version is used by the client.  The
        service will then return true if the client is capable of talking to
        the service, and false if the client's protocol version is incompatible
        with the service, so the client must upgrade.  If a client receives a
        false value, it should report the incompatibility to the user and not
        continue with any more EDAM requests (UserStore or NoteStore).

        @param clientName
          This string provides some information about the client for
          tracking/logging on the service.  It should provide information about
          the client's software and platform. The structure should be:
          application/version; platform/version; [ device/version ]
          E.g. "Evernote Windows/3.0.1; Windows/XP SP3".

        @param edamVersionMajor
          This should be the major protocol version that was compiled by the
          client.  This should be the current value of the EDAM_VERSION_MAJOR
          constant for the client.

        @param edamVersionMinor
          This should be the major protocol version that was compiled by the
          client.  This should be the current value of the EDAM_VERSION_MINOR
          constant for the client.

        Parameters:
         - clientName
         - edamVersionMajor
         - edamVersionMinor

        """
        self.send_checkVersion(clientName, edamVersionMajor, edamVersionMinor)
        return self.recv_checkVersion()

    def send_checkVersion(self, clientName: str, edamVersionMajor: int, edamVersionMinor: int):
        self._oprot.writeMessageBegin('checkVersion', TMessageType.CALL, self._seqid)
        args = checkVersion_args()
        args.clientName = clientName
        args.edamVersionMajor = edamVersionMajor
        args.edamVersionMinor = edamVersionMinor
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_checkVersion(self) -> bool:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = checkVersion_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "checkVersion failed: unknown result")

    def getBootstrapInfo(self, locale: str) -> BootstrapInfo:
        """
        This provides bootstrap information to the client. Various bootstrap
        profiles and settings may be used by the client to configure itself.

        @param locale
          The client's current locale, expressed in language[_country]
          format. E.g., "en_US". See ISO-639 and ISO-3166 for valid
          language and country codes.

        @return
          The bootstrap information suitable for this client.

        Parameters:
         - locale

        """
        self.send_getBootstrapInfo(locale)
        return self.recv_getBootstrapInfo()

    def send_getBootstrapInfo(self, locale: str):
        self._oprot.writeMessageBegin('getBootstrapInfo', TMessageType.CALL, self._seqid)
        args = getBootstrapInfo_args()
        args.locale = locale
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getBootstrapInfo(self) -> BootstrapInfo:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getBootstrapInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getBootstrapInfo failed: unknown result")

    def authenticateLongSession(self, username: str, password: str, consumerKey: str, consumerSecret: str, deviceIdentifier: str, deviceDescription: str, supportsTwoFactor: bool) -> AuthenticationResult:
        """
        This is used to check a username and password in order to create a
        long-lived authentication token that can be used for further actions.

        This function is not available to most third party applications,
        which typically authenticate using OAuth as
        described at
        <a href="http://dev.evernote.com/documentation/cloud/">dev.evernote.com</a>.
        If you believe that your application requires permission to authenticate
        using username and password instead of OAuth, please contact Evernote
        developer support by visiting
        <a href="http://dev.evernote.com">dev.evernote.com</a>.

        @param username
          The username or registered email address of the account to
          authenticate against.

        @param password
          The plaintext password to check against the account.  Since
          this is not protected by the EDAM protocol, this information must be
          provided over a protected transport (i.e. SSL).

        @param consumerKey
          The "consumer key" portion of the API key issued to the client application
          by Evernote.

        @param consumerSecret
          The "consumer secret" portion of the API key issued to the client application
          by Evernote.

        @param deviceIdentifier
          An optional string that uniquely identifies the device from which the
          authentication is being performed. This string allows the service to return the
          same authentication token when a given application requests authentication
          repeatedly from the same device. This may happen when the user logs out of an
          application and then logs back in, or when the application is uninstalled
          and later reinstalled. If no reliable device identifier can be created,
          this value should be omitted. If set, the device identifier must be between
          1 and EDAM_DEVICE_ID_LEN_MAX characters long and must match the regular expression
          EDAM_DEVICE_ID_REGEX.

        @param deviceDescription
          A description of the device from which the authentication is being performed.
          This field is displayed to the user in a list of authorized applications to
          allow them to distinguish between multiple tokens issued to the same client
          application on different devices. For example, the Evernote iOS client on
          a user's iPhone and iPad might pass the iOS device names "Bob's iPhone" and
          "Bob's iPad". The device description must be between 1 and
          EDAM_DEVICE_DESCRIPTION_LEN_MAX characters long and must match the regular
          expression EDAM_DEVICE_DESCRIPTION_REGEX.

        @param supportsTwoFactor
          Whether the calling application supports two-factor authentication. If this
          parameter is false, this method will fail with the error code INVALID_AUTH and the
          parameter "password" when called for a user who has enabled two-factor
          authentication.

        @return
          <p>The result of the authentication. The level of detail provided in the returned
          AuthenticationResult.User structure depends on the access level granted by
          calling application's API key.</p>
          <p>If the user has two-factor authentication enabled,
          AuthenticationResult.secondFactorRequired will be set and
          AuthenticationResult.authenticationToken will contain a short-lived token
          that may only be used to complete the two-factor authentication process by calling
          UserStore.completeTwoFactorAuthentication.</p>

        @throws EDAMUserException <ul>
          <li> DATA_REQUIRED "username" - username is empty
          <li> DATA_REQUIRED "password" - password is empty
          <li> DATA_REQUIRED "consumerKey" - consumerKey is empty
          <li> DATA_REQUIRED "consumerSecret" - consumerSecret is empty
          <li> DATA_REQUIRED "deviceDescription" - deviceDescription is empty
          <li> BAD_DATA_FORMAT "deviceDescription" - deviceDescription is not valid.
          <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid.
          <li> INVALID_AUTH "username" - username not found
          <li> INVALID_AUTH "password" - password did not match
          <li> INVALID_AUTH "consumerKey" - consumerKey is not authorized
          <li> INVALID_AUTH "consumerSecret" - consumerSecret is incorrect
          <li> INVALID_AUTH "businessOnly" - the user is a business-only account
          <li> PERMISSION_DENIED "User.active" - user account is closed
          <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
            failed authentication too often
          <li> AUTH_EXPIRED "password" - user password is expired
        </ul>

        Parameters:
         - username
         - password
         - consumerKey
         - consumerSecret
         - deviceIdentifier
         - deviceDescription
         - supportsTwoFactor

        """
        self.send_authenticateLongSession(username, password, consumerKey, consumerSecret, deviceIdentifier, deviceDescription, supportsTwoFactor)
        return self.recv_authenticateLongSession()

    def send_authenticateLongSession(self, username: str, password: str, consumerKey: str, consumerSecret: str, deviceIdentifier: str, deviceDescription: str, supportsTwoFactor: bool):
        self._oprot.writeMessageBegin('authenticateLongSession', TMessageType.CALL, self._seqid)
        args = authenticateLongSession_args()
        args.username = username
        args.password = password
        args.consumerKey = consumerKey
        args.consumerSecret = consumerSecret
        args.deviceIdentifier = deviceIdentifier
        args.deviceDescription = deviceDescription
        args.supportsTwoFactor = supportsTwoFactor
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_authenticateLongSession(self) -> AuthenticationResult:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = authenticateLongSession_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "authenticateLongSession failed: unknown result")

    def authenticateLongSessionV2(self, authParams: AuthenticationParameters) -> AuthenticationResult:
        """
        Used to be the main username/password login endpoint for the desktop app.
        Still useful, but only for Yinxiang.

        Parameters:
         - authParams

        """
        self.send_authenticateLongSessionV2(authParams)
        return self.recv_authenticateLongSessionV2()

    def send_authenticateLongSessionV2(self, authParams: AuthenticationParameters):
        self._oprot.writeMessageBegin('authenticateLongSessionV2', TMessageType.CALL, self._seqid)
        args = authenticateLongSessionV2_args()
        args.authParams = authParams
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_authenticateLongSessionV2(self) -> AuthenticationResult:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = authenticateLongSessionV2_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "authenticateLongSessionV2 failed: unknown result")

    def completeTwoFactorAuthentication(self, authenticationToken: str, oneTimeCode: str, deviceIdentifier: str, deviceDescription: str) -> AuthenticationResult:
        """
        Complete the authentication process when a second factor is required. This
        call is made after a successful call to authenticate or authenticateLongSession
        when the authenticating user has enabled two-factor authentication.

        @param authenticationToken An authentication token returned by a previous
          call to UserStore.authenticate or UserStore.authenticateLongSession that
          could not be completed in a single call because a second factor was required.

        @param oneTimeCode The one time code entered by the user. This value is delivered
          out-of-band, typically via SMS or an authenticator application.

        @param deviceIdentifier See the corresponding parameter in authenticateLongSession.

        @param deviceDescription See the corresponding parameter in authenticateLongSession.

        @return
          The result of the authentication. The level of detail provided in the returned
          AuthenticationResult.User structure depends on the access level granted by the
          calling application's API key. If the initial authentication call was made to
          authenticateLongSession, the AuthenticationResult will contain a long-lived
          authentication token.

        @throws EDAMUserException <ul>
          <li> DATA_REQUIRED "authenticationToken" - authenticationToken is empty
          <li> DATA_REQUIRED "oneTimeCode" - oneTimeCode is empty
          <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid
          <li> BAD_DATA_FORMAT "authenticationToken" - authenticationToken is not well formed
          <li> INVALID_AUTH "oneTimeCode" - oneTimeCode did not match
          <li> AUTH_EXPIRED "authenticationToken" - authenticationToken has expired
          <li> PERMISSION_DENIED "authenticationToken" - authenticationToken is not valid
          <li> PERMISSION_DENIED "User.active" - user account is closed
          <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
            failed authentication too often
          <li> DATA_CONFLICT "User.twoFactorAuthentication" - The user has not enabled
             two-factor authentication.</li>
        </ul>

        Parameters:
         - authenticationToken
         - oneTimeCode
         - deviceIdentifier
         - deviceDescription

        """
        self.send_completeTwoFactorAuthentication(authenticationToken, oneTimeCode, deviceIdentifier, deviceDescription)
        return self.recv_completeTwoFactorAuthentication()

    def send_completeTwoFactorAuthentication(self, authenticationToken: str, oneTimeCode: str, deviceIdentifier: str, deviceDescription: str):
        self._oprot.writeMessageBegin('completeTwoFactorAuthentication', TMessageType.CALL, self._seqid)
        args = completeTwoFactorAuthentication_args()
        args.authenticationToken = authenticationToken
        args.oneTimeCode = oneTimeCode
        args.deviceIdentifier = deviceIdentifier
        args.deviceDescription = deviceDescription
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_completeTwoFactorAuthentication(self) -> AuthenticationResult:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = completeTwoFactorAuthentication_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "completeTwoFactorAuthentication failed: unknown result")

    def revokeLongSession(self, authenticationToken: str) -> None:
        """
        Revoke an existing long lived authentication token. This can be used to
        revoke OAuth tokens or tokens created by calling authenticateLongSession,
        and allows a user to effectively log out of Evernote from the perspective
        of the application that holds the token. The authentication token that is
        passed is immediately revoked and may not be used to call any authenticated
        EDAM function.

        @param authenticationToken the authentication token to revoke.

        @throws EDAMUserException <ul>
          <li> DATA_REQUIRED "authenticationToken" - no authentication token provided
          <li> BAD_DATA_FORMAT "authenticationToken" - the authentication token is not well formed
          <li> INVALID_AUTH "authenticationToken" - the authentication token is invalid
          <li> AUTH_EXPIRED "authenticationToken" - the authentication token is expired or
            is already revoked.
        </ul>

        Parameters:
         - authenticationToken

        """
        self.send_revokeLongSession(authenticationToken)
        self.recv_revokeLongSession()

    def send_revokeLongSession(self, authenticationToken: str):
        self._oprot.writeMessageBegin('revokeLongSession', TMessageType.CALL, self._seqid)
        args = revokeLongSession_args()
        args.authenticationToken = authenticationToken
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_revokeLongSession(self) -> None:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = revokeLongSession_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        return

    def authenticateToBusiness(self, authenticationToken: str) -> AuthenticationResult:
        """
        This is used to take an existing authentication token that grants access
        to an individual user account (returned from 'authenticate',
        'authenticateLongSession' or an OAuth authorization) and obtain an additional
        authentication token that may be used to access business notebooks if the user
        is a member of an Evernote Business account.

        The resulting authentication token may be used to make NoteStore API calls
        against the business using the NoteStore URL returned in the result.

        @param authenticationToken
          The authentication token for the user. This may not be a shared authentication
          token (returned by NoteStore.authenticateToSharedNotebook or
          NoteStore.authenticateToSharedNote) or a business authentication token.

        @return
          The result of the authentication, with the token granting access to the
          business in the result's 'authenticationToken' field. The URL that must
          be used to access the business account NoteStore will be returned in the
          result's 'noteStoreUrl' field.  The 'User' field will
          not be set in the result.

        @throws EDAMUserException <ul>
          <li> PERMISSION_DENIED "authenticationToken" - the provided authentication token
               is a shared or business authentication token. </li>
          <li> PERMISSION_DENIED "Business" - the user identified by the provided
               authentication token is not currently a member of a business. </li>
          <li> PERMISSION_DENIED "Business.status" - the business that the user is a
               member of is not currently in an active status. </li>
          <li> BUSINESS_SECURITY_LOGIN_REQUIRED "sso" - the user must complete single
               sign-on before authenticating to the business.
        </ul>

        Parameters:
         - authenticationToken

        """
        self.send_authenticateToBusiness(authenticationToken)
        return self.recv_authenticateToBusiness()

    def send_authenticateToBusiness(self, authenticationToken: str):
        self._oprot.writeMessageBegin('authenticateToBusiness', TMessageType.CALL, self._seqid)
        args = authenticateToBusiness_args()
        args.authenticationToken = authenticationToken
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_authenticateToBusiness(self) -> AuthenticationResult:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = authenticateToBusiness_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "authenticateToBusiness failed: unknown result")

    def getUser(self, authenticationToken: str) -> evernote.edam.type.ttypes.User:
        """
        Returns the User corresponding to the provided authentication token,
        or throws an exception if this token is not valid.
        The level of detail provided in the returned User structure depends on
        the access level granted by the token, so a web service client may receive
        fewer fields than an integrated desktop client.

        Parameters:
         - authenticationToken

        """
        self.send_getUser(authenticationToken)
        return self.recv_getUser()

    def send_getUser(self, authenticationToken: str):
        self._oprot.writeMessageBegin('getUser', TMessageType.CALL, self._seqid)
        args = getUser_args()
        args.authenticationToken = authenticationToken
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getUser(self) -> evernote.edam.type.ttypes.User:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getUser_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getUser failed: unknown result")

    def getPublicUserInfo(self, username: str) -> PublicUserInfo:
        """
        Asks the UserStore about the publicly available location information for
        a particular username.

        @throws EDAMUserException <ul>
          <li> DATA_REQUIRED "username" - username is empty
        </ul>

        Parameters:
         - username

        """
        self.send_getPublicUserInfo(username)
        return self.recv_getPublicUserInfo()

    def send_getPublicUserInfo(self, username: str):
        self._oprot.writeMessageBegin('getPublicUserInfo', TMessageType.CALL, self._seqid)
        args = getPublicUserInfo_args()
        args.username = username
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getPublicUserInfo(self) -> PublicUserInfo:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getPublicUserInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.notFoundException is not None:
            raise result.notFoundException
        if result.systemException is not None:
            raise result.systemException
        if result.userException is not None:
            raise result.userException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getPublicUserInfo failed: unknown result")

    def getUserUrls(self, authenticationToken: str) -> UserUrls:
        """
        <p>Returns the URLs that should be used when sending requests to the service on
        behalf of the account represented by the provided authenticationToken.</p>

        <p>This method isn't needed by most clients, who can retreive the correct set of
        UserUrls from the AuthenticationResult returned from
        UserStore#authenticateLongSession(). This method is typically only needed to look up
        the correct URLs for an existing long-lived authentication token.</p>

        Parameters:
         - authenticationToken

        """
        self.send_getUserUrls(authenticationToken)
        return self.recv_getUserUrls()

    def send_getUserUrls(self, authenticationToken: str):
        self._oprot.writeMessageBegin('getUserUrls', TMessageType.CALL, self._seqid)
        args = getUserUrls_args()
        args.authenticationToken = authenticationToken
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getUserUrls(self) -> UserUrls:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getUserUrls_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getUserUrls failed: unknown result")

    def inviteToBusiness(self, authenticationToken: str, emailAddress: str) -> None:
        """
        Invite a user to join an Evernote Business account.

        Behavior will depend on the auth token. <ol>
          <li>
            auth token with privileges to manage Evernote Business membership.
              "External Provisioning" - The user will receive an email inviting
              them to join the business. They do not need to have an existing Evernote
              account. If the user has already been invited, a new invitation email
              will be sent.
          </li>
          <li>
            business auth token issued to an admin user. Only for first-party clients:
              "Approve Invitation" - If there has been a request to invite the email,
              approve it. Invited user will receive email with a link to join business.
              "Invite User" - If no invitation for the email exists, create an approved
              invitation for the email. An email will be sent to the emailAddress with
              a link to join the caller's business.
          </li>
          </li>
            business auth token:
              "Request Invitation" - If no invitation exists, create a request to
              invite the user to the business. These requests do not count towards a
              business' max active user limit.
          </li>
        </ol>

        @param authenticationToken
          the authentication token with sufficient privileges to manage Evernote Business
          membership or a business auth token.

        @param emailAddress
          the email address of the user to invite to join the Evernote Business account.

        @throws EDAMUserException <ul>
          <li> DATA_REQUIRED "email" - if no email address was provided </li>
          <li> BAD_DATA_FORMAT "email" - if the email address is not well formed </li>
          <li> DATA_CONFLICT "BusinessUser.email" - if there is already a user in the business
            whose business email address matches the specified email address. </li>
          <li> LIMIT_REACHED "Business.maxActiveUsers" - if the business has reached its
            user limit. </li>
        </ul>

        Parameters:
         - authenticationToken
         - emailAddress

        """
        self.send_inviteToBusiness(authenticationToken, emailAddress)
        self.recv_inviteToBusiness()

    def send_inviteToBusiness(self, authenticationToken: str, emailAddress: str):
        self._oprot.writeMessageBegin('inviteToBusiness', TMessageType.CALL, self._seqid)
        args = inviteToBusiness_args()
        args.authenticationToken = authenticationToken
        args.emailAddress = emailAddress
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_inviteToBusiness(self) -> None:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = inviteToBusiness_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        return

    def removeFromBusiness(self, authenticationToken: str, emailAddress: str) -> None:
        """
        Remove a user from an Evernote Business account. Once removed, the user will no
        longer be able to access content within the Evernote Business account.

        <p>The email address of the user to remove from the business must match the email
        address used to invite a user to join the business via UserStore.inviteToBusiness.
        This function will only remove users who were invited by external provisioning</p>

        @param authenticationToken
          An authentication token with sufficient privileges to manage Evernote Business
          membership.

        @param emailAddress
          The email address of the user to remove from the Evernote Business account.

        @throws EDAMUserException <ul>
          <li> DATA_REQUIRED "email" - if no email address was provided </li>
          <li> BAD_DATA_FORMAT "email" - The email address is not well formed </li>
        </ul>
        @throws EDAMNotFoundException <ul>
          <li> "email" - If there is no user with the specified email address in the
            business or that user was not invited via external provisioning. </li>
        </ul>

        Parameters:
         - authenticationToken
         - emailAddress

        """
        self.send_removeFromBusiness(authenticationToken, emailAddress)
        self.recv_removeFromBusiness()

    def send_removeFromBusiness(self, authenticationToken: str, emailAddress: str):
        self._oprot.writeMessageBegin('removeFromBusiness', TMessageType.CALL, self._seqid)
        args = removeFromBusiness_args()
        args.authenticationToken = authenticationToken
        args.emailAddress = emailAddress
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_removeFromBusiness(self) -> None:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = removeFromBusiness_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        return

    def updateBusinessUserIdentifier(self, authenticationToken: str, oldEmailAddress: str, newEmailAddress: str) -> None:
        """
        Update the email address used to uniquely identify an Evernote Business user.

        This will update the identifier for a user who was previously invited using
        inviteToBusiness, ensuring that caller and the Evernote service maintain an
        agreed-upon identifier for a specific user.

        For example, the following sequence of calls would invite a user to join
        a business, update their email address, and then remove the user
        from the business using the updated email address.

        inviteToBusiness("foo@bar.com")
        updateBusinessUserIdentifier("foo@bar.com", "baz@bar.com")
        removeFromBusiness("baz@bar.com")

        @param authenticationToken
          An authentication token with sufficient privileges to manage Evernote Business
          membership.

        @param oldEmailAddress
          The existing email address used to uniquely identify the user.

        @param newEmailAddress
          The new email address used to uniquely identify the user.

        @throws EDAMUserException <ul>
          <li>DATA_REQUIRED "oldEmailAddress" - No old email address was provided</li>
          <li>DATA_REQUIRED "newEmailAddress" - No new email address was provided</li>
          <li>BAD_DATA_FORMAT "oldEmailAddress" - The old email address is not well formed</li>
          <li>BAD_DATA_FORMAT "newEmailAddress" - The new email address is not well formed</li>
          <li>DATA_CONFLICT "oldEmailAddress" - The old and new email addresses were the same</li>
          <li>DATA_CONFLICT "newEmailAddress" - There is already an invitation or registered user with
            the provided new email address.</li>
          <li>DATA_CONFLICT "invitation.externallyProvisioned" - The user identified by
            oldEmailAddress was not added via UserStore.inviteToBusiness and therefore cannot be
            updated.</li>
        </ul>
        @throws EDAMNotFoundException <ul>
          <li>"oldEmailAddress" - If there is no user or invitation with the specified oldEmailAddress
            in the business.</li>
        </ul>

        Parameters:
         - authenticationToken
         - oldEmailAddress
         - newEmailAddress

        """
        self.send_updateBusinessUserIdentifier(authenticationToken, oldEmailAddress, newEmailAddress)
        self.recv_updateBusinessUserIdentifier()

    def send_updateBusinessUserIdentifier(self, authenticationToken: str, oldEmailAddress: str, newEmailAddress: str):
        self._oprot.writeMessageBegin('updateBusinessUserIdentifier', TMessageType.CALL, self._seqid)
        args = updateBusinessUserIdentifier_args()
        args.authenticationToken = authenticationToken
        args.oldEmailAddress = oldEmailAddress
        args.newEmailAddress = newEmailAddress
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateBusinessUserIdentifier(self) -> None:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateBusinessUserIdentifier_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        return

    def listBusinessUsers(self, authenticationToken: str) -> list[evernote.edam.type.ttypes.UserProfile]:
        """
        Returns a list of active business users in a given business.

        Clients are required to cache this information and re-fetch no more than once per day
        or when they encountered a user ID or username that was not known to them.

        To avoid excessive look ups, clients should also track user IDs and usernames that belong
        to users who are not in the business, since they will not be included in the result.

        I.e., when a client encounters a previously unknown user ID as a note's creator, it may query
        listBusinessUsers to find information about this user. If the user is not in the resulting
        list, the client should track that fact and not re-query the service the next time that it sees
        this user on a note.

        @param authenticationToken
          A business authentication token returned by authenticateToBusiness or with sufficient
          privileges to manage Evernote Business membership.

        Parameters:
         - authenticationToken

        """
        self.send_listBusinessUsers(authenticationToken)
        return self.recv_listBusinessUsers()

    def send_listBusinessUsers(self, authenticationToken: str):
        self._oprot.writeMessageBegin('listBusinessUsers', TMessageType.CALL, self._seqid)
        args = listBusinessUsers_args()
        args.authenticationToken = authenticationToken
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listBusinessUsers(self) -> list[evernote.edam.type.ttypes.UserProfile]:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listBusinessUsers_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "listBusinessUsers failed: unknown result")

    def listBusinessInvitations(self, authenticationToken: str, includeRequestedInvitations: bool) -> list[evernote.edam.type.ttypes.BusinessInvitation]:
        """
        Returns a list of outstanding invitations to join an Evernote Business account.

        Only outstanding invitations are returned by this function. Users who have accepted an
        invitation and joined a business are listed using listBusinessUsers.

        @param authenticationToken
          An authentication token with sufficient privileges to manage Evernote Business membership.

        @param includeRequestedInvitations
          If true, invitations with a status of BusinessInvitationStatus.REQUESTED will be included
          in the returned list. If false, only invitations with a status of
          BusinessInvitationStatus.APPROVED will be included.

        Parameters:
         - authenticationToken
         - includeRequestedInvitations

        """
        self.send_listBusinessInvitations(authenticationToken, includeRequestedInvitations)
        return self.recv_listBusinessInvitations()

    def send_listBusinessInvitations(self, authenticationToken: str, includeRequestedInvitations: bool):
        self._oprot.writeMessageBegin('listBusinessInvitations', TMessageType.CALL, self._seqid)
        args = listBusinessInvitations_args()
        args.authenticationToken = authenticationToken
        args.includeRequestedInvitations = includeRequestedInvitations
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listBusinessInvitations(self) -> list[evernote.edam.type.ttypes.BusinessInvitation]:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listBusinessInvitations_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "listBusinessInvitations failed: unknown result")

    def getAccountLimits(self, serviceLevel: evernote.edam.type.ttypes.ServiceLevel) -> evernote.edam.type.ttypes.AccountLimits:
        """
        Retrieve the standard account limits for a given service level. This should only be
        called when necessary, e.g. to determine if a higher level is available should the
        user upgrade, and should be cached for long periods (e.g. 30 days) as the values are
        not expected to fluctuate frequently.

        @throws EDAMUserException <ul>
          <li>DATA_REQUIRED "serviceLevel" - serviceLevel is null</li>
        </ul>

        Parameters:
         - serviceLevel

        """
        self.send_getAccountLimits(serviceLevel)
        return self.recv_getAccountLimits()

    def send_getAccountLimits(self, serviceLevel: evernote.edam.type.ttypes.ServiceLevel):
        self._oprot.writeMessageBegin('getAccountLimits', TMessageType.CALL, self._seqid)
        args = getAccountLimits_args()
        args.serviceLevel = serviceLevel
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAccountLimits(self) -> evernote.edam.type.ttypes.AccountLimits:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAccountLimits_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAccountLimits failed: unknown result")

    def getNAPAccessToken(self, authenticationToken: str) -> str:
        """
        Endpoints for getting the JWT auth token for the new API.

        Parameters:
         - authenticationToken

        """
        self.send_getNAPAccessToken(authenticationToken)
        return self.recv_getNAPAccessToken()

    def send_getNAPAccessToken(self, authenticationToken: str):
        self._oprot.writeMessageBegin('getNAPAccessToken', TMessageType.CALL, self._seqid)
        args = getNAPAccessToken_args()
        args.authenticationToken = authenticationToken
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getNAPAccessToken(self) -> str:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getNAPAccessToken_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getNAPAccessToken failed: unknown result")

    def getNAPAccessJWT(self, authenticationToken: str, request: GetNAPAccessJWTRequest) -> str:
        """
        Parameters:
         - authenticationToken
         - request

        """
        self.send_getNAPAccessJWT(authenticationToken, request)
        return self.recv_getNAPAccessJWT()

    def send_getNAPAccessJWT(self, authenticationToken: str, request: GetNAPAccessJWTRequest):
        self._oprot.writeMessageBegin('getNAPAccessJWT', TMessageType.CALL, self._seqid)
        args = getNAPAccessJWT_args()
        args.authenticationToken = authenticationToken
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getNAPAccessJWT(self) -> str:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getNAPAccessJWT_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getNAPAccessJWT failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["checkVersion"] = Processor.process_checkVersion
        self._processMap["getBootstrapInfo"] = Processor.process_getBootstrapInfo
        self._processMap["authenticateLongSession"] = Processor.process_authenticateLongSession
        self._processMap["authenticateLongSessionV2"] = Processor.process_authenticateLongSessionV2
        self._processMap["completeTwoFactorAuthentication"] = Processor.process_completeTwoFactorAuthentication
        self._processMap["revokeLongSession"] = Processor.process_revokeLongSession
        self._processMap["authenticateToBusiness"] = Processor.process_authenticateToBusiness
        self._processMap["getUser"] = Processor.process_getUser
        self._processMap["getPublicUserInfo"] = Processor.process_getPublicUserInfo
        self._processMap["getUserUrls"] = Processor.process_getUserUrls
        self._processMap["inviteToBusiness"] = Processor.process_inviteToBusiness
        self._processMap["removeFromBusiness"] = Processor.process_removeFromBusiness
        self._processMap["updateBusinessUserIdentifier"] = Processor.process_updateBusinessUserIdentifier
        self._processMap["listBusinessUsers"] = Processor.process_listBusinessUsers
        self._processMap["listBusinessInvitations"] = Processor.process_listBusinessInvitations
        self._processMap["getAccountLimits"] = Processor.process_getAccountLimits
        self._processMap["getNAPAccessToken"] = Processor.process_getNAPAccessToken
        self._processMap["getNAPAccessJWT"] = Processor.process_getNAPAccessJWT
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_checkVersion(self, seqid, iprot, oprot):
        args = checkVersion_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = checkVersion_result()
        try:
            result.success = self._handler.checkVersion(args.clientName, args.edamVersionMajor, args.edamVersionMinor)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("checkVersion", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getBootstrapInfo(self, seqid, iprot, oprot):
        args = getBootstrapInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getBootstrapInfo_result()
        try:
            result.success = self._handler.getBootstrapInfo(args.locale)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getBootstrapInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_authenticateLongSession(self, seqid, iprot, oprot):
        args = authenticateLongSession_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = authenticateLongSession_result()
        try:
            result.success = self._handler.authenticateLongSession(args.username, args.password, args.consumerKey, args.consumerSecret, args.deviceIdentifier, args.deviceDescription, args.supportsTwoFactor)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("authenticateLongSession", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_authenticateLongSessionV2(self, seqid, iprot, oprot):
        args = authenticateLongSessionV2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = authenticateLongSessionV2_result()
        try:
            result.success = self._handler.authenticateLongSessionV2(args.authParams)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("authenticateLongSessionV2", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_completeTwoFactorAuthentication(self, seqid, iprot, oprot):
        args = completeTwoFactorAuthentication_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = completeTwoFactorAuthentication_result()
        try:
            result.success = self._handler.completeTwoFactorAuthentication(args.authenticationToken, args.oneTimeCode, args.deviceIdentifier, args.deviceDescription)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("completeTwoFactorAuthentication", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_revokeLongSession(self, seqid, iprot, oprot):
        args = revokeLongSession_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = revokeLongSession_result()
        try:
            self._handler.revokeLongSession(args.authenticationToken)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("revokeLongSession", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_authenticateToBusiness(self, seqid, iprot, oprot):
        args = authenticateToBusiness_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = authenticateToBusiness_result()
        try:
            result.success = self._handler.authenticateToBusiness(args.authenticationToken)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("authenticateToBusiness", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getUser(self, seqid, iprot, oprot):
        args = getUser_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getUser_result()
        try:
            result.success = self._handler.getUser(args.authenticationToken)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getUser", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getPublicUserInfo(self, seqid, iprot, oprot):
        args = getPublicUserInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getPublicUserInfo_result()
        try:
            result.success = self._handler.getPublicUserInfo(args.username)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except evernote.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getPublicUserInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getUserUrls(self, seqid, iprot, oprot):
        args = getUserUrls_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getUserUrls_result()
        try:
            result.success = self._handler.getUserUrls(args.authenticationToken)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getUserUrls", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_inviteToBusiness(self, seqid, iprot, oprot):
        args = inviteToBusiness_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = inviteToBusiness_result()
        try:
            self._handler.inviteToBusiness(args.authenticationToken, args.emailAddress)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("inviteToBusiness", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_removeFromBusiness(self, seqid, iprot, oprot):
        args = removeFromBusiness_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeFromBusiness_result()
        try:
            self._handler.removeFromBusiness(args.authenticationToken, args.emailAddress)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("removeFromBusiness", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateBusinessUserIdentifier(self, seqid, iprot, oprot):
        args = updateBusinessUserIdentifier_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateBusinessUserIdentifier_result()
        try:
            self._handler.updateBusinessUserIdentifier(args.authenticationToken, args.oldEmailAddress, args.newEmailAddress)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateBusinessUserIdentifier", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listBusinessUsers(self, seqid, iprot, oprot):
        args = listBusinessUsers_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listBusinessUsers_result()
        try:
            result.success = self._handler.listBusinessUsers(args.authenticationToken)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("listBusinessUsers", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listBusinessInvitations(self, seqid, iprot, oprot):
        args = listBusinessInvitations_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listBusinessInvitations_result()
        try:
            result.success = self._handler.listBusinessInvitations(args.authenticationToken, args.includeRequestedInvitations)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("listBusinessInvitations", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAccountLimits(self, seqid, iprot, oprot):
        args = getAccountLimits_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAccountLimits_result()
        try:
            result.success = self._handler.getAccountLimits(args.serviceLevel)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAccountLimits", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getNAPAccessToken(self, seqid, iprot, oprot):
        args = getNAPAccessToken_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getNAPAccessToken_result()
        try:
            result.success = self._handler.getNAPAccessToken(args.authenticationToken)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getNAPAccessToken", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getNAPAccessJWT(self, seqid, iprot, oprot):
        args = getNAPAccessJWT_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getNAPAccessJWT_result()
        try:
            result.success = self._handler.getNAPAccessJWT(args.authenticationToken, args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getNAPAccessJWT", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class checkVersion_args(object):
    """
    Attributes:
     - clientName
     - edamVersionMajor
     - edamVersionMinor

    """
    thrift_spec: typing.Any = None


    def __init__(self, clientName: typing.Optional[str] = None, edamVersionMajor: typing.Optional[int] = 1, edamVersionMinor: typing.Optional[int] = 28,):
        self.clientName: typing.Optional[str] = clientName
        self.edamVersionMajor: typing.Optional[int] = edamVersionMajor
        self.edamVersionMinor: typing.Optional[int] = edamVersionMinor

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clientName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.edamVersionMajor = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.edamVersionMinor = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('checkVersion_args')
        if self.clientName is not None:
            oprot.writeFieldBegin('clientName', TType.STRING, 1)
            oprot.writeString(self.clientName.encode('utf-8') if sys.version_info[0] == 2 else self.clientName)
            oprot.writeFieldEnd()
        if self.edamVersionMajor is not None:
            oprot.writeFieldBegin('edamVersionMajor', TType.I16, 2)
            oprot.writeI16(self.edamVersionMajor)
            oprot.writeFieldEnd()
        if self.edamVersionMinor is not None:
            oprot.writeFieldBegin('edamVersionMinor', TType.I16, 3)
            oprot.writeI16(self.edamVersionMinor)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(checkVersion_args)
checkVersion_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clientName', 'UTF8', None, ),  # 1
    (2, TType.I16, 'edamVersionMajor', None, 1, ),  # 2
    (3, TType.I16, 'edamVersionMinor', None, 28, ),  # 3
)


class checkVersion_result(object):
    """
    Attributes:
     - success

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[bool] = None,):
        self.success: typing.Optional[bool] = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('checkVersion_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(checkVersion_result)
checkVersion_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class getBootstrapInfo_args(object):
    """
    Attributes:
     - locale

    """
    thrift_spec: typing.Any = None


    def __init__(self, locale: typing.Optional[str] = None,):
        self.locale: typing.Optional[str] = locale

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.locale = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getBootstrapInfo_args')
        if self.locale is not None:
            oprot.writeFieldBegin('locale', TType.STRING, 1)
            oprot.writeString(self.locale.encode('utf-8') if sys.version_info[0] == 2 else self.locale)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getBootstrapInfo_args)
getBootstrapInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'locale', 'UTF8', None, ),  # 1
)


class getBootstrapInfo_result(object):
    """
    Attributes:
     - success

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[BootstrapInfo] = None,):
        self.success: typing.Optional[BootstrapInfo] = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = BootstrapInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getBootstrapInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getBootstrapInfo_result)
getBootstrapInfo_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [BootstrapInfo, None], None, ),  # 0
)


class authenticateLongSession_args(object):
    """
    Attributes:
     - username
     - password
     - consumerKey
     - consumerSecret
     - deviceIdentifier
     - deviceDescription
     - supportsTwoFactor

    """
    thrift_spec: typing.Any = None


    def __init__(self, username: typing.Optional[str] = None, password: typing.Optional[str] = None, consumerKey: typing.Optional[str] = None, consumerSecret: typing.Optional[str] = None, deviceIdentifier: typing.Optional[str] = None, deviceDescription: typing.Optional[str] = None, supportsTwoFactor: typing.Optional[bool] = None,):
        self.username: typing.Optional[str] = username
        self.password: typing.Optional[str] = password
        self.consumerKey: typing.Optional[str] = consumerKey
        self.consumerSecret: typing.Optional[str] = consumerSecret
        self.deviceIdentifier: typing.Optional[str] = deviceIdentifier
        self.deviceDescription: typing.Optional[str] = deviceDescription
        self.supportsTwoFactor: typing.Optional[bool] = supportsTwoFactor

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.password = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.consumerKey = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.consumerSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.deviceIdentifier = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.deviceDescription = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.supportsTwoFactor = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('authenticateLongSession_args')
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 1)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 2)
            oprot.writeString(self.password.encode('utf-8') if sys.version_info[0] == 2 else self.password)
            oprot.writeFieldEnd()
        if self.consumerKey is not None:
            oprot.writeFieldBegin('consumerKey', TType.STRING, 3)
            oprot.writeString(self.consumerKey.encode('utf-8') if sys.version_info[0] == 2 else self.consumerKey)
            oprot.writeFieldEnd()
        if self.consumerSecret is not None:
            oprot.writeFieldBegin('consumerSecret', TType.STRING, 4)
            oprot.writeString(self.consumerSecret.encode('utf-8') if sys.version_info[0] == 2 else self.consumerSecret)
            oprot.writeFieldEnd()
        if self.deviceIdentifier is not None:
            oprot.writeFieldBegin('deviceIdentifier', TType.STRING, 5)
            oprot.writeString(self.deviceIdentifier.encode('utf-8') if sys.version_info[0] == 2 else self.deviceIdentifier)
            oprot.writeFieldEnd()
        if self.deviceDescription is not None:
            oprot.writeFieldBegin('deviceDescription', TType.STRING, 6)
            oprot.writeString(self.deviceDescription.encode('utf-8') if sys.version_info[0] == 2 else self.deviceDescription)
            oprot.writeFieldEnd()
        if self.supportsTwoFactor is not None:
            oprot.writeFieldBegin('supportsTwoFactor', TType.BOOL, 7)
            oprot.writeBool(self.supportsTwoFactor)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(authenticateLongSession_args)
authenticateLongSession_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'username', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'password', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'consumerKey', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'consumerSecret', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'deviceIdentifier', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'deviceDescription', 'UTF8', None, ),  # 6
    (7, TType.BOOL, 'supportsTwoFactor', None, None, ),  # 7
)


class authenticateLongSession_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[AuthenticationResult] = None, userException: typing.Optional[evernote.edam.error.ttypes.EDAMUserException] = None, systemException: typing.Optional[evernote.edam.error.ttypes.EDAMSystemException] = None,):
        self.success: typing.Optional[AuthenticationResult] = success
        self.userException: typing.Optional[evernote.edam.error.ttypes.EDAMUserException] = userException
        self.systemException: typing.Optional[evernote.edam.error.ttypes.EDAMSystemException] = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = AuthenticationResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote.edam.error.ttypes.EDAMUserException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote.edam.error.ttypes.EDAMSystemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('authenticateLongSession_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(authenticateLongSession_result)
authenticateLongSession_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [AuthenticationResult, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
)


class authenticateLongSessionV2_args(object):
    """
    Attributes:
     - authParams

    """
    thrift_spec: typing.Any = None


    def __init__(self, authParams: typing.Optional[AuthenticationParameters] = None,):
        self.authParams: typing.Optional[AuthenticationParameters] = authParams

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.authParams = AuthenticationParameters()
                    self.authParams.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('authenticateLongSessionV2_args')
        if self.authParams is not None:
            oprot.writeFieldBegin('authParams', TType.STRUCT, 1)
            self.authParams.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(authenticateLongSessionV2_args)
authenticateLongSessionV2_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'authParams', [AuthenticationParameters, None], None, ),  # 1
)


class authenticateLongSessionV2_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[AuthenticationResult] = None, userException: typing.Optional[evernote.edam.error.ttypes.EDAMUserException] = None, systemException: typing.Optional[evernote.edam.error.ttypes.EDAMSystemException] = None,):
        self.success: typing.Optional[AuthenticationResult] = success
        self.userException: typing.Optional[evernote.edam.error.ttypes.EDAMUserException] = userException
        self.systemException: typing.Optional[evernote.edam.error.ttypes.EDAMSystemException] = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = AuthenticationResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote.edam.error.ttypes.EDAMUserException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote.edam.error.ttypes.EDAMSystemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('authenticateLongSessionV2_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(authenticateLongSessionV2_result)
authenticateLongSessionV2_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [AuthenticationResult, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
)


class completeTwoFactorAuthentication_args(object):
    """
    Attributes:
     - authenticationToken
     - oneTimeCode
     - deviceIdentifier
     - deviceDescription

    """
    thrift_spec: typing.Any = None


    def __init__(self, authenticationToken: typing.Optional[str] = None, oneTimeCode: typing.Optional[str] = None, deviceIdentifier: typing.Optional[str] = None, deviceDescription: typing.Optional[str] = None,):
        self.authenticationToken: typing.Optional[str] = authenticationToken
        self.oneTimeCode: typing.Optional[str] = oneTimeCode
        self.deviceIdentifier: typing.Optional[str] = deviceIdentifier
        self.deviceDescription: typing.Optional[str] = deviceDescription

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.oneTimeCode = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.deviceIdentifier = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.deviceDescription = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('completeTwoFactorAuthentication_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.oneTimeCode is not None:
            oprot.writeFieldBegin('oneTimeCode', TType.STRING, 2)
            oprot.writeString(self.oneTimeCode.encode('utf-8') if sys.version_info[0] == 2 else self.oneTimeCode)
            oprot.writeFieldEnd()
        if self.deviceIdentifier is not None:
            oprot.writeFieldBegin('deviceIdentifier', TType.STRING, 3)
            oprot.writeString(self.deviceIdentifier.encode('utf-8') if sys.version_info[0] == 2 else self.deviceIdentifier)
            oprot.writeFieldEnd()
        if self.deviceDescription is not None:
            oprot.writeFieldBegin('deviceDescription', TType.STRING, 4)
            oprot.writeString(self.deviceDescription.encode('utf-8') if sys.version_info[0] == 2 else self.deviceDescription)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(completeTwoFactorAuthentication_args)
completeTwoFactorAuthentication_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'oneTimeCode', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'deviceIdentifier', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'deviceDescription', 'UTF8', None, ),  # 4
)


class completeTwoFactorAuthentication_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[AuthenticationResult] = None, userException: typing.Optional[evernote.edam.error.ttypes.EDAMUserException] = None, systemException: typing.Optional[evernote.edam.error.ttypes.EDAMSystemException] = None,):
        self.success: typing.Optional[AuthenticationResult] = success
        self.userException: typing.Optional[evernote.edam.error.ttypes.EDAMUserException] = userException
        self.systemException: typing.Optional[evernote.edam.error.ttypes.EDAMSystemException] = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = AuthenticationResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote.edam.error.ttypes.EDAMUserException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote.edam.error.ttypes.EDAMSystemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('completeTwoFactorAuthentication_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(completeTwoFactorAuthentication_result)
completeTwoFactorAuthentication_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [AuthenticationResult, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
)


class revokeLongSession_args(object):
    """
    Attributes:
     - authenticationToken

    """
    thrift_spec: typing.Any = None


    def __init__(self, authenticationToken: typing.Optional[str] = None,):
        self.authenticationToken: typing.Optional[str] = authenticationToken

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revokeLongSession_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revokeLongSession_args)
revokeLongSession_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
)


class revokeLongSession_result(object):
    """
    Attributes:
     - userException
     - systemException

    """
    thrift_spec: typing.Any = None


    def __init__(self, userException: typing.Optional[evernote.edam.error.ttypes.EDAMUserException] = None, systemException: typing.Optional[evernote.edam.error.ttypes.EDAMSystemException] = None,):
        self.userException: typing.Optional[evernote.edam.error.ttypes.EDAMUserException] = userException
        self.systemException: typing.Optional[evernote.edam.error.ttypes.EDAMSystemException] = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote.edam.error.ttypes.EDAMUserException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote.edam.error.ttypes.EDAMSystemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revokeLongSession_result')
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revokeLongSession_result)
revokeLongSession_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'userException', [evernote.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
)


class authenticateToBusiness_args(object):
    """
    Attributes:
     - authenticationToken

    """
    thrift_spec: typing.Any = None


    def __init__(self, authenticationToken: typing.Optional[str] = None,):
        self.authenticationToken: typing.Optional[str] = authenticationToken

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('authenticateToBusiness_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(authenticateToBusiness_args)
authenticateToBusiness_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
)


class authenticateToBusiness_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[AuthenticationResult] = None, userException: typing.Optional[evernote.edam.error.ttypes.EDAMUserException] = None, systemException: typing.Optional[evernote.edam.error.ttypes.EDAMSystemException] = None,):
        self.success: typing.Optional[AuthenticationResult] = success
        self.userException: typing.Optional[evernote.edam.error.ttypes.EDAMUserException] = userException
        self.systemException: typing.Optional[evernote.edam.error.ttypes.EDAMSystemException] = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = AuthenticationResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote.edam.error.ttypes.EDAMUserException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote.edam.error.ttypes.EDAMSystemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('authenticateToBusiness_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(authenticateToBusiness_result)
authenticateToBusiness_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [AuthenticationResult, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
)


class getUser_args(object):
    """
    Attributes:
     - authenticationToken

    """
    thrift_spec: typing.Any = None


    def __init__(self, authenticationToken: typing.Optional[str] = None,):
        self.authenticationToken: typing.Optional[str] = authenticationToken

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getUser_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getUser_args)
getUser_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
)


class getUser_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[evernote.edam.type.ttypes.User] = None, userException: typing.Optional[evernote.edam.error.ttypes.EDAMUserException] = None, systemException: typing.Optional[evernote.edam.error.ttypes.EDAMSystemException] = None,):
        self.success: typing.Optional[evernote.edam.type.ttypes.User] = success
        self.userException: typing.Optional[evernote.edam.error.ttypes.EDAMUserException] = userException
        self.systemException: typing.Optional[evernote.edam.error.ttypes.EDAMSystemException] = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = evernote.edam.type.ttypes.User()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote.edam.error.ttypes.EDAMUserException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote.edam.error.ttypes.EDAMSystemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getUser_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getUser_result)
getUser_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [evernote.edam.type.ttypes.User, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
)


class getPublicUserInfo_args(object):
    """
    Attributes:
     - username

    """
    thrift_spec: typing.Any = None


    def __init__(self, username: typing.Optional[str] = None,):
        self.username: typing.Optional[str] = username

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getPublicUserInfo_args')
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 1)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getPublicUserInfo_args)
getPublicUserInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'username', 'UTF8', None, ),  # 1
)


class getPublicUserInfo_result(object):
    """
    Attributes:
     - success
     - notFoundException
     - systemException
     - userException

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[PublicUserInfo] = None, notFoundException: typing.Optional[evernote.edam.error.ttypes.EDAMNotFoundException] = None, systemException: typing.Optional[evernote.edam.error.ttypes.EDAMSystemException] = None, userException: typing.Optional[evernote.edam.error.ttypes.EDAMUserException] = None,):
        self.success: typing.Optional[PublicUserInfo] = success
        self.notFoundException: typing.Optional[evernote.edam.error.ttypes.EDAMNotFoundException] = notFoundException
        self.systemException: typing.Optional[evernote.edam.error.ttypes.EDAMSystemException] = systemException
        self.userException: typing.Optional[evernote.edam.error.ttypes.EDAMUserException] = userException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PublicUserInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote.edam.error.ttypes.EDAMSystemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.userException = evernote.edam.error.ttypes.EDAMUserException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getPublicUserInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 1)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 3)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getPublicUserInfo_result)
getPublicUserInfo_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [PublicUserInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'notFoundException', [evernote.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'userException', [evernote.edam.error.ttypes.EDAMUserException, None], None, ),  # 3
)


class getUserUrls_args(object):
    """
    Attributes:
     - authenticationToken

    """
    thrift_spec: typing.Any = None


    def __init__(self, authenticationToken: typing.Optional[str] = None,):
        self.authenticationToken: typing.Optional[str] = authenticationToken

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getUserUrls_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getUserUrls_args)
getUserUrls_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
)


class getUserUrls_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[UserUrls] = None, userException: typing.Optional[evernote.edam.error.ttypes.EDAMUserException] = None, systemException: typing.Optional[evernote.edam.error.ttypes.EDAMSystemException] = None,):
        self.success: typing.Optional[UserUrls] = success
        self.userException: typing.Optional[evernote.edam.error.ttypes.EDAMUserException] = userException
        self.systemException: typing.Optional[evernote.edam.error.ttypes.EDAMSystemException] = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = UserUrls()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote.edam.error.ttypes.EDAMUserException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote.edam.error.ttypes.EDAMSystemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getUserUrls_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getUserUrls_result)
getUserUrls_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [UserUrls, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
)


class inviteToBusiness_args(object):
    """
    Attributes:
     - authenticationToken
     - emailAddress

    """
    thrift_spec: typing.Any = None


    def __init__(self, authenticationToken: typing.Optional[str] = None, emailAddress: typing.Optional[str] = None,):
        self.authenticationToken: typing.Optional[str] = authenticationToken
        self.emailAddress: typing.Optional[str] = emailAddress

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.emailAddress = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('inviteToBusiness_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.emailAddress is not None:
            oprot.writeFieldBegin('emailAddress', TType.STRING, 2)
            oprot.writeString(self.emailAddress.encode('utf-8') if sys.version_info[0] == 2 else self.emailAddress)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(inviteToBusiness_args)
inviteToBusiness_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'emailAddress', 'UTF8', None, ),  # 2
)


class inviteToBusiness_result(object):
    """
    Attributes:
     - userException
     - systemException

    """
    thrift_spec: typing.Any = None


    def __init__(self, userException: typing.Optional[evernote.edam.error.ttypes.EDAMUserException] = None, systemException: typing.Optional[evernote.edam.error.ttypes.EDAMSystemException] = None,):
        self.userException: typing.Optional[evernote.edam.error.ttypes.EDAMUserException] = userException
        self.systemException: typing.Optional[evernote.edam.error.ttypes.EDAMSystemException] = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote.edam.error.ttypes.EDAMUserException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote.edam.error.ttypes.EDAMSystemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('inviteToBusiness_result')
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(inviteToBusiness_result)
inviteToBusiness_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'userException', [evernote.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
)


class removeFromBusiness_args(object):
    """
    Attributes:
     - authenticationToken
     - emailAddress

    """
    thrift_spec: typing.Any = None


    def __init__(self, authenticationToken: typing.Optional[str] = None, emailAddress: typing.Optional[str] = None,):
        self.authenticationToken: typing.Optional[str] = authenticationToken
        self.emailAddress: typing.Optional[str] = emailAddress

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.emailAddress = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeFromBusiness_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.emailAddress is not None:
            oprot.writeFieldBegin('emailAddress', TType.STRING, 2)
            oprot.writeString(self.emailAddress.encode('utf-8') if sys.version_info[0] == 2 else self.emailAddress)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeFromBusiness_args)
removeFromBusiness_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'emailAddress', 'UTF8', None, ),  # 2
)


class removeFromBusiness_result(object):
    """
    Attributes:
     - userException
     - systemException
     - notFoundException

    """
    thrift_spec: typing.Any = None


    def __init__(self, userException: typing.Optional[evernote.edam.error.ttypes.EDAMUserException] = None, systemException: typing.Optional[evernote.edam.error.ttypes.EDAMSystemException] = None, notFoundException: typing.Optional[evernote.edam.error.ttypes.EDAMNotFoundException] = None,):
        self.userException: typing.Optional[evernote.edam.error.ttypes.EDAMUserException] = userException
        self.systemException: typing.Optional[evernote.edam.error.ttypes.EDAMSystemException] = systemException
        self.notFoundException: typing.Optional[evernote.edam.error.ttypes.EDAMNotFoundException] = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote.edam.error.ttypes.EDAMUserException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote.edam.error.ttypes.EDAMSystemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeFromBusiness_result')
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeFromBusiness_result)
removeFromBusiness_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'userException', [evernote.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class updateBusinessUserIdentifier_args(object):
    """
    Attributes:
     - authenticationToken
     - oldEmailAddress
     - newEmailAddress

    """
    thrift_spec: typing.Any = None


    def __init__(self, authenticationToken: typing.Optional[str] = None, oldEmailAddress: typing.Optional[str] = None, newEmailAddress: typing.Optional[str] = None,):
        self.authenticationToken: typing.Optional[str] = authenticationToken
        self.oldEmailAddress: typing.Optional[str] = oldEmailAddress
        self.newEmailAddress: typing.Optional[str] = newEmailAddress

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.oldEmailAddress = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.newEmailAddress = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateBusinessUserIdentifier_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.oldEmailAddress is not None:
            oprot.writeFieldBegin('oldEmailAddress', TType.STRING, 2)
            oprot.writeString(self.oldEmailAddress.encode('utf-8') if sys.version_info[0] == 2 else self.oldEmailAddress)
            oprot.writeFieldEnd()
        if self.newEmailAddress is not None:
            oprot.writeFieldBegin('newEmailAddress', TType.STRING, 3)
            oprot.writeString(self.newEmailAddress.encode('utf-8') if sys.version_info[0] == 2 else self.newEmailAddress)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateBusinessUserIdentifier_args)
updateBusinessUserIdentifier_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'oldEmailAddress', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'newEmailAddress', 'UTF8', None, ),  # 3
)


class updateBusinessUserIdentifier_result(object):
    """
    Attributes:
     - userException
     - systemException
     - notFoundException

    """
    thrift_spec: typing.Any = None


    def __init__(self, userException: typing.Optional[evernote.edam.error.ttypes.EDAMUserException] = None, systemException: typing.Optional[evernote.edam.error.ttypes.EDAMSystemException] = None, notFoundException: typing.Optional[evernote.edam.error.ttypes.EDAMNotFoundException] = None,):
        self.userException: typing.Optional[evernote.edam.error.ttypes.EDAMUserException] = userException
        self.systemException: typing.Optional[evernote.edam.error.ttypes.EDAMSystemException] = systemException
        self.notFoundException: typing.Optional[evernote.edam.error.ttypes.EDAMNotFoundException] = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote.edam.error.ttypes.EDAMUserException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote.edam.error.ttypes.EDAMSystemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateBusinessUserIdentifier_result')
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateBusinessUserIdentifier_result)
updateBusinessUserIdentifier_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'userException', [evernote.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class listBusinessUsers_args(object):
    """
    Attributes:
     - authenticationToken

    """
    thrift_spec: typing.Any = None


    def __init__(self, authenticationToken: typing.Optional[str] = None,):
        self.authenticationToken: typing.Optional[str] = authenticationToken

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listBusinessUsers_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listBusinessUsers_args)
listBusinessUsers_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
)


class listBusinessUsers_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[list[evernote.edam.type.ttypes.UserProfile]] = None, userException: typing.Optional[evernote.edam.error.ttypes.EDAMUserException] = None, systemException: typing.Optional[evernote.edam.error.ttypes.EDAMSystemException] = None,):
        self.success: typing.Optional[list[evernote.edam.type.ttypes.UserProfile]] = success
        self.userException: typing.Optional[evernote.edam.error.ttypes.EDAMUserException] = userException
        self.systemException: typing.Optional[evernote.edam.error.ttypes.EDAMSystemException] = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = evernote.edam.type.ttypes.UserProfile()
                        _elem12.read(iprot)
                        self.success.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote.edam.error.ttypes.EDAMUserException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote.edam.error.ttypes.EDAMSystemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listBusinessUsers_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter13 in self.success:
                iter13.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listBusinessUsers_result)
listBusinessUsers_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [evernote.edam.type.ttypes.UserProfile, None], False), None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
)


class listBusinessInvitations_args(object):
    """
    Attributes:
     - authenticationToken
     - includeRequestedInvitations

    """
    thrift_spec: typing.Any = None


    def __init__(self, authenticationToken: typing.Optional[str] = None, includeRequestedInvitations: typing.Optional[bool] = None,):
        self.authenticationToken: typing.Optional[str] = authenticationToken
        self.includeRequestedInvitations: typing.Optional[bool] = includeRequestedInvitations

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.includeRequestedInvitations = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listBusinessInvitations_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.includeRequestedInvitations is not None:
            oprot.writeFieldBegin('includeRequestedInvitations', TType.BOOL, 2)
            oprot.writeBool(self.includeRequestedInvitations)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listBusinessInvitations_args)
listBusinessInvitations_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'includeRequestedInvitations', None, None, ),  # 2
)


class listBusinessInvitations_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[list[evernote.edam.type.ttypes.BusinessInvitation]] = None, userException: typing.Optional[evernote.edam.error.ttypes.EDAMUserException] = None, systemException: typing.Optional[evernote.edam.error.ttypes.EDAMSystemException] = None,):
        self.success: typing.Optional[list[evernote.edam.type.ttypes.BusinessInvitation]] = success
        self.userException: typing.Optional[evernote.edam.error.ttypes.EDAMUserException] = userException
        self.systemException: typing.Optional[evernote.edam.error.ttypes.EDAMSystemException] = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = evernote.edam.type.ttypes.BusinessInvitation()
                        _elem19.read(iprot)
                        self.success.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote.edam.error.ttypes.EDAMUserException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote.edam.error.ttypes.EDAMSystemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listBusinessInvitations_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter20 in self.success:
                iter20.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listBusinessInvitations_result)
listBusinessInvitations_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [evernote.edam.type.ttypes.BusinessInvitation, None], False), None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
)


class getAccountLimits_args(object):
    """
    Attributes:
     - serviceLevel

    """
    thrift_spec: typing.Any = None


    def __init__(self, serviceLevel: typing.Optional[evernote.edam.type.ttypes.ServiceLevel] = None,):
        self.serviceLevel: typing.Optional[evernote.edam.type.ttypes.ServiceLevel] = serviceLevel

    def __setattr__(self, name, value):
        if name == "serviceLevel":
            super().__setattr__(name, value if hasattr(value, 'value') else evernote.edam.type.ttypes.ServiceLevel.__members__.get(value))
            return
        super().__setattr__(name, value)


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.serviceLevel = evernote.edam.type.ttypes.ServiceLevel(iprot.readI32())
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAccountLimits_args')
        if self.serviceLevel is not None:
            oprot.writeFieldBegin('serviceLevel', TType.I32, 1)
            oprot.writeI32(self.serviceLevel.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAccountLimits_args)
getAccountLimits_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'serviceLevel', None, None, ),  # 1
)


class getAccountLimits_result(object):
    """
    Attributes:
     - success
     - userException

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[evernote.edam.type.ttypes.AccountLimits] = None, userException: typing.Optional[evernote.edam.error.ttypes.EDAMUserException] = None,):
        self.success: typing.Optional[evernote.edam.type.ttypes.AccountLimits] = success
        self.userException: typing.Optional[evernote.edam.error.ttypes.EDAMUserException] = userException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = evernote.edam.type.ttypes.AccountLimits()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote.edam.error.ttypes.EDAMUserException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAccountLimits_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAccountLimits_result)
getAccountLimits_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [evernote.edam.type.ttypes.AccountLimits, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
)


class getNAPAccessToken_args(object):
    """
    Attributes:
     - authenticationToken

    """
    thrift_spec: typing.Any = None


    def __init__(self, authenticationToken: typing.Optional[str] = None,):
        self.authenticationToken: typing.Optional[str] = authenticationToken

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNAPAccessToken_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNAPAccessToken_args)
getNAPAccessToken_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
)


class getNAPAccessToken_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[str] = None, userException: typing.Optional[evernote.edam.error.ttypes.EDAMUserException] = None, systemException: typing.Optional[evernote.edam.error.ttypes.EDAMSystemException] = None,):
        self.success: typing.Optional[str] = success
        self.userException: typing.Optional[evernote.edam.error.ttypes.EDAMUserException] = userException
        self.systemException: typing.Optional[evernote.edam.error.ttypes.EDAMSystemException] = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote.edam.error.ttypes.EDAMUserException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote.edam.error.ttypes.EDAMSystemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNAPAccessToken_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNAPAccessToken_result)
getNAPAccessToken_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
)


class getNAPAccessJWT_args(object):
    """
    Attributes:
     - authenticationToken
     - request

    """
    thrift_spec: typing.Any = None


    def __init__(self, authenticationToken: typing.Optional[str] = None, request: typing.Optional[GetNAPAccessJWTRequest] = None,):
        self.authenticationToken: typing.Optional[str] = authenticationToken
        self.request: typing.Optional[GetNAPAccessJWTRequest] = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.request = GetNAPAccessJWTRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNAPAccessJWT_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 2)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNAPAccessJWT_args)
getNAPAccessJWT_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'request', [GetNAPAccessJWTRequest, None], None, ),  # 2
)


class getNAPAccessJWT_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[str] = None, userException: typing.Optional[evernote.edam.error.ttypes.EDAMUserException] = None, systemException: typing.Optional[evernote.edam.error.ttypes.EDAMSystemException] = None,):
        self.success: typing.Optional[str] = success
        self.userException: typing.Optional[evernote.edam.error.ttypes.EDAMUserException] = userException
        self.systemException: typing.Optional[evernote.edam.error.ttypes.EDAMSystemException] = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote.edam.error.ttypes.EDAMUserException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote.edam.error.ttypes.EDAMSystemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNAPAccessJWT_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNAPAccessJWT_result)
getNAPAccessJWT_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
)
fix_spec(all_structs)
del all_structs
